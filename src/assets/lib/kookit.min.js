import Chinese from 'chinese-s2t';
import _ from 'underscore';
import rangy from 'rangy/lib/rangy-core.js';
import 'rangy/lib/rangy-textrange';
import JSZip from 'jszip';
import { unzlibSync } from 'fflate';
import chardet from 'chardet';
import untar from 'js-untar';
import mammoth from 'mammoth';
import { marked } from 'marked';
import mhtml2html from 'mhtml2html';

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

const convertStyleNum = (value) => {
    if (!value)
        return 0;
    return parseFloat(value + "");
};
const convertComputedNum = (value) => {
    return parseFloat(value.substring(0, value.length - 2));
};
const handleIframeHeight = (element, readerMode, format, iframe, doc) => __awaiter(void 0, void 0, void 0, function* () {
    yield Promise.all(Array.from([...doc.images, ...doc.querySelectorAll("image")]).map((img) => {
        if (img.complete)
            return Promise.resolve(img.naturalHeight !== 0);
        return new Promise((resolve) => {
            img.addEventListener("load", () => resolve(true));
            img.addEventListener("error", () => resolve(false));
        });
    })).then((results) => {
        if (results.every((res) => res))
            console.info("all images loaded successfully!!");
        else
            console.error("some images failed to load, all finished loading");
    });
    yield handleImageSize(element, readerMode, format, doc);
    if (format !== "PDF") {
        handleTextStyle(doc);
    }
    if (readerMode !== "scroll") {
        iframe.height = element.clientHeight + "px";
        if (readerMode === "double") {
            let section = Math.floor(element.clientWidth / 12);
            let gap = section % 2 === 0 ? section : section - 1;
            let pageWidth = (element.clientWidth + gap) / 2;
            if (((doc.body.scrollWidth - doc.body.clientWidth) / pageWidth) % 2 ===
                1) {
                let tailElem = document.createElement("div");
                tailElem.setAttribute("style", "height: " +
                    doc.body.clientHeight +
                    "px; display: inline-block; width: " +
                    (pageWidth - gap) +
                    "px");
                doc.body.appendChild(tailElem);
            }
        }
    }
    else if (format === "PDF") {
        let docLayer = doc.querySelector(".koodoPDFLayer");
        if (!docLayer)
            return;
        iframe.height = docLayer.getBoundingClientRect().height + 100 + "px";
    }
    else {
        //fix text blocked issue under scroll readerMode, don't ask me why
        iframe.height = doc.body.scrollHeight + "px";
        iframe.height = doc.body.scrollHeight + 300 + "px";
    }
    // await new Promise((r) => setTimeout(r, 1));
});
const handleOneChapterDoc = (item, isSearch) => __awaiter(void 0, void 0, void 0, function* () {
    let chapterText = "";
    // return;
    if (item.load) {
        let blob = yield fetch(yield item.load()).then((r) => r.blob());
        chapterText = yield blob.text();
    }
    if (isSearch) {
        return chapterText;
    }
    if (item.loadAsset) {
        chapterText = yield handlePrecacheAssets(chapterText, item.loadAsset);
    }
    chapterText = handleImageMarker(chapterText);
    return chapterText;
});
const getImageElement = (Element) => {
    return Array.from(Element.querySelectorAll("img, image"));
};
const handlePrecacheAssets = (bookStr, loadAsset) => __awaiter(void 0, void 0, void 0, function* () {
    let chapterDoc = new DOMParser().parseFromString(bookStr, "text/html");
    let imgDomList = getImageElement(chapterDoc);
    for (let subindex = 0; subindex < imgDomList.length; subindex++) {
        if (imgDomList[subindex].getAttribute("src")) {
            imgDomList[subindex].src = yield loadAsset(imgDomList[subindex].getAttribute("src"));
        }
        else if (imgDomList[subindex].getAttribute("xlink:href")) {
            imgDomList[subindex].setAttribute("xlink:href", yield loadAsset(imgDomList[subindex].getAttribute("xlink:href")));
        }
    }
    let linkList = Array.from(chapterDoc.getElementsByTagName("link"));
    for (let index = 0; index < linkList.length; index++) {
        const link = linkList[index];
        if (link.getAttribute("href")) {
            link.href = yield loadAsset(link.getAttribute("href"));
        }
    }
    return chapterDoc.documentElement.innerHTML;
});
const handleImageMarker = (bookStr) => {
    var _a;
    let chapterDoc = new DOMParser().parseFromString(bookStr, "text/html");
    let imgDomList = getImageElement(chapterDoc);
    if (imgDomList.length === 0) {
        return bookStr;
    }
    else {
        for (let i = 0; i < imgDomList.length; i++) {
            if (imgDomList[i].tagName === "image") {
                continue;
            }
            var newItem = document.createElement("address");
            var textnode = document.createTextNode("img");
            newItem.appendChild(textnode);
            newItem.setAttribute("style", "visibility: hidden; position: absolute");
            (_a = imgDomList[i]) === null || _a === void 0 ? void 0 : _a.insertAdjacentElement("afterend", newItem);
        }
        return chapterDoc.documentElement.innerHTML;
    }
};
const createIframe = (element, styleStr = "") => {
    var iframe = document.createElement("iframe");
    iframe.style.width = "100%";
    iframe.style.border = "0";
    iframe.style.margin = "0";
    iframe.style.padding = "0";
    iframe.style.minHeight = "calc(100% - 2px)";
    iframe.style.fontSize = "100%";
    iframe.style.font = "inherit";
    iframe.scrolling = "no";
    iframe.tabIndex = 0;
    iframe.id = "kookit-iframe";
    iframe.style.verticalAlign = "baseline";
    element.innerHTML = "";
    element.appendChild(iframe);
};
const progressInfo = (readerMode, doc) => {
    //TODO 是否有必要保留延时
    // if (parseInt(doc.body.scrollWidth / doc.body.clientWidth + "") === 1) {
    //   await new Promise((r) => setTimeout(r, 1000));
    // }
    return {
        totalPage: readerMode === "scroll"
            ? 1
            : readerMode === "single"
                ? Math.round(parseFloat(doc.body.scrollWidth / doc.body.clientWidth + ""))
                : Math.round(parseFloat(doc.body.scrollWidth / doc.body.clientWidth + "")) * 2,
        currentPage: Math.round(parseFloat(convertStyleNum(doc.body.scrollLeft) / doc.body.clientWidth + "")) + 1,
    };
};
const handleTextStyle = (doc) => {
    let textNodes = doc.querySelectorAll("a, article, cite, div, li, p, span, pre, table, bold, font");
    for (let index = 0; index < textNodes.length; index++) {
        const element = textNodes[index];
        if (element.className.indexOf("kookit-text") === -1) {
            element.className = element.className + " kookit-text";
        }
    }
};
const getImageMeta = (url) => __awaiter(void 0, void 0, void 0, function* () {
    const img = new Image();
    img.src = url;
    try {
        yield img.decode();
    }
    catch (error) {
        console.error(error);
    }
    return img;
});
const handleImageSize = (element, readerMode, format, doc) => __awaiter(void 0, void 0, void 0, function* () {
    let section = Math.floor(element.clientWidth / 12);
    let gap = section % 2 === 0 ? section : section - 1;
    let imgs = doc.querySelectorAll("img, image");
    for (let item of imgs) {
        let parentItem = item.parentElement;
        let maxHeight = 0;
        let maxWidth = 0;
        let width = item.naturalWidth;
        let height = item.naturalHeight;
        if (item.tagName === "image") {
            let img = yield getImageMeta(item.getAttribute("xlink:href"));
            width = img.naturalWidth;
            height = img.naturalHeight;
        }
        if (format.startsWith("CB") && readerMode === "scroll") {
            maxWidth = parentItem.offsetWidth;
        }
        else if (format.startsWith("CB") && readerMode === "single") {
            maxHeight = element.clientHeight;
            maxWidth = element.clientWidth;
        }
        else if (parentItem && width && height) {
            let isImageScaleLargerThanElement = height / width > parentItem.clientHeight / parentItem.clientWidth;
            if (isImageScaleLargerThanElement) {
                maxHeight = parentItem.clientHeight;
                maxWidth = parseInt((maxHeight * width) / height + "");
            }
            else {
                maxWidth = parentItem.clientWidth;
                maxHeight = parseInt((maxWidth * height) / width + "");
            }
            if (maxHeight > doc.body.clientHeight) {
                maxWidth = parseInt(maxWidth * (doc.body.clientHeight / maxHeight) + "");
                maxHeight = doc.body.clientHeight;
            }
        }
        else if (parentItem &&
            parentItem.clientWidth &&
            parentItem.clientWidth > 0) {
            maxWidth = parentItem.clientWidth;
            maxHeight = parentItem.clientHeight;
        }
        else {
            maxWidth = element.clientWidth;
            maxHeight = element.clientHeight;
        }
        if (maxWidth) {
            maxWidth = Math.min(readerMode === "scroll" || readerMode === "single"
                ? element.clientWidth
                : (element.clientWidth - gap) / 2, maxWidth);
        }
        else {
            maxWidth =
                readerMode === "scroll" || readerMode === "single"
                    ? element.clientWidth
                    : (element.clientWidth - gap) / 2;
        }
        if (width && height) {
            if (width > height) {
                maxHeight = maxWidth * (height / width);
            }
            else {
                if (maxHeight / maxWidth > height / width) {
                    maxHeight = maxWidth * (height / width);
                }
                else {
                    maxWidth = maxHeight * (width / height);
                }
            }
        }
        if (maxWidth || maxHeight) {
            item.setAttribute("style", (item.getAttribute("style") ? item.getAttribute("style") : "") +
                ";" +
                `max-width: ${maxWidth > 0 ? maxWidth + "px" : ""};max-height:${maxHeight > 0 ? maxHeight + "px" : ""}; margin: 0 auto; ${format.startsWith("CB")
                    ? `margin-left: calc(100% - ${item.clientWidth}px);`
                    : ""}`);
        }
        if (format.startsWith("CB") && readerMode === "scroll") {
            item.setAttribute("style", (item.getAttribute("style") ? item.getAttribute("style") : "") +
                ";margin-left: 0px; width: 100%;");
        }
        if (format.startsWith("CB") && readerMode !== "scroll") {
            item.setAttribute("style", (item.getAttribute("style") ? item.getAttribute("style") : "") +
                `;margin-left: calc(50% - ${item.getBoundingClientRect().width / 2}px);`);
        }
    }
});
const handleLayout = (element, readerMode, doc) => {
    let style = doc.createElement("style");
    style.id = "default-style";
    style.textContent =
        "p,empty-line{display: inherit;margin-block-start: inherit;margin-block-end: inherit;margin-inline-start: inherit;margin-inline-end: inherit;}body{margin: 0px}";
    doc.head.appendChild(style);
    if (readerMode === "scroll")
        return;
    let scale = readerMode === "double" ? 2 : 1;
    let section = Math.floor(element.clientWidth / 12);
    let gap = section % 2 === 0 ? section : section - 1;
    doc.body.setAttribute("style", `width: auto;height: 100%;overflow-y: hidden;overflow-X: hidden;padding-left: 0px;padding-right: 0px;margin: 0px;box-sizing: border-box;touch-action: pan-y; overscroll-behavior: none;max-width: inherit;column-fill: auto;column-gap: ${gap}px; column-width: ${(element.clientWidth - gap) / scale}px;`);
};
function getSelectedElement(doc) {
    const selection = doc.getSelection();
    if (!selection)
        return null;
    if (selection.rangeCount > 0) {
        const range = selection.getRangeAt(0);
        const selectedElement = range.startContainer.parentElement;
        return selectedElement;
    }
    return null;
}

const isString = (value) => {
    return typeof value === "string" || value instanceof String;
};
class GeneralParser {
    constructor(book) {
        this.book = book;
        this.chapterList = [];
        this.flattenChapters = [];
        this.chapterDocList = [];
    }
    unescapeHtml(htmlStr) {
        if (!htmlStr)
            return "";
        const doc = new DOMParser().parseFromString(htmlStr, "text/html");
        return doc.documentElement.textContent || "";
    }
    getChapter(toc) {
        return __awaiter(this, void 0, void 0, function* () {
            if (toc) {
                this.chapterList = yield Promise.all(toc.map((item) => __awaiter(this, void 0, void 0, function* () {
                    let index = -1;
                    try {
                        index =
                            item.href && (yield this.book.resolveHref(item.href))
                                ? (yield this.book.resolveHref(item.href)).index
                                : -1;
                    }
                    catch (error) {
                        console.error(error);
                    }
                    return {
                        label: this.unescapeHtml(item.label)
                            ? this.unescapeHtml(item.label)
                            : index + "",
                        href: item.href ? item.href : "title" + index,
                        index: index,
                        subitems: item.subitems ? yield this.getChapter(item.subitems) : [],
                    };
                })));
            }
            else {
                this.chapterList = yield Promise.all(this.book.sections.map((item, index) => __awaiter(this, void 0, void 0, function* () {
                    return {
                        label: this.unescapeHtml(item.label)
                            ? this.unescapeHtml(item.label)
                            : index + "",
                        href: item.href ? item.href : "title" + index,
                        index: index,
                        subitems: item.subitems ? yield this.getChapter(item.subitems) : [],
                    };
                })));
            }
            this.flattenChapters = this.flatChapter(this.chapterList);
            return this.chapterList;
        });
    }
    getChapterDoc() {
        return __awaiter(this, void 0, void 0, function* () {
            const chapterIndexList = this.flattenChapters.map((item) => item.index);
            return this.book.sections.map((item, index) => {
                if (chapterIndexList.indexOf(index) > -1) {
                    return {
                        label: this.unescapeHtml(this.flattenChapters[chapterIndexList.indexOf(index)].label),
                        href: this.flattenChapters[chapterIndexList.indexOf(index)].href,
                        text: item,
                    };
                }
                else {
                    return {
                        label: "",
                        href: "",
                        text: item,
                    };
                }
            });
        });
    }
    flatChapter(chapters) {
        let newChapter = [];
        for (let i = 0; i < chapters.length; i++) {
            if (chapters[i].subitems && chapters[i].subitems.length > 0) {
                newChapter.push(chapters[i]);
                newChapter = newChapter.concat(this.flatChapter(chapters[i].subitems));
            }
            else {
                newChapter.push(chapters[i]);
            }
        }
        return newChapter;
    }
    getMetadata() {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            const metadata = this.book.metadata;
            let author = metadata.author &&
                metadata.author[0] &&
                metadata.author[0].name &&
                isString(metadata.author[0].name)
                ? metadata.author[0].name
                : metadata.author &&
                    metadata.author[0] &&
                    isString(metadata.author[0])
                    ? metadata.author[0]
                    : metadata.author && isString(metadata.author)
                        ? metadata.author
                        : "";
            try {
                const blob = yield this.book.getCover();
                var reader = new FileReader();
                reader.readAsDataURL(blob);
                reader.onloadend = () => {
                    resolve({
                        name: metadata.title,
                        author: author,
                        description: metadata.description,
                        publisher: metadata.publisher,
                        cover: reader.result,
                    });
                };
            }
            catch (error) {
                console.error(error);
                try {
                    resolve({
                        name: metadata.title,
                        author: author,
                        description: metadata.description,
                        publisher: metadata.publisher,
                        cover: "",
                    });
                }
                catch (error) {
                    console.error(error);
                    reject(error);
                }
            }
        }));
    }
}

const findIndices = (arr, f) => arr
  .map((x, i, a) => f(x, i, a) ? i : null).filter(x => x != null);
const splitAt = (arr, is) => [-1, ...is, arr.length].reduce(({ xs, a }, b) =>
  ({ xs: xs?.concat([arr.slice(a + 1, b)]) ?? [], a: b }), {}).xs;
const concatArrays = (a, b) =>
  a.slice(0, -1).concat([a[a.length - 1].concat(b[0])]).concat(b.slice(1));

const isNumber = /\d/;
const isCFI = /^epubcfi\((.*)\)$/;
const escapeCFI = str => str.replace(/[\^[\](),;=]/g, '^$&');

const wrap = x => isCFI.test(x) ? x : `epubcfi(${x})`;
const unwrap = x => x.match(isCFI)?.[1] ?? x;

const tokenizer = str => {
  const tokens = [];
  let state, escape, value = '';
  const push = x => (tokens.push(x), state = null, value = '');
  const cat = x => (value += x, escape = false);
  for (const char of Array.from(str.trim()).concat('')) {
    if (char === '^' && !escape) {
      escape = true;
      continue
    }
    if (state === '!') push(['!']);
    else if (state === ',') push([',']);
    else if (state === '/' || state === ':') {
      if (isNumber.test(char)) {
        cat(char);
        continue
      } else push([state, parseInt(value)]);
    } else if (state === '~') {
      if (isNumber.test(char) || char === '.') {
        cat(char);
        continue
      } else push(['~', parseFloat(value)]);
    } else if (state === '@') {
      if (char === ':') {
        push(['@', parseFloat(value)]);
        state = '@';
        continue
      }
      if (isNumber.test(char) || char === '.') {
        cat(char);
        continue
      } else push(['@', parseFloat(value)]);
    } else if (state === '[') {
      if (char === ';' && !escape) {
        push(['[', value]);
        state = ';';
      } else if (char === ',' && !escape) {
        push(['[', value]);
        state = '[';
      } else if (char === ']' && !escape) push(['[', value]);
      else cat(char);
      continue
    } else if (state?.startsWith(';')) {
      if (char === '=' && !escape) {
        state = `;${value}`;
        value = '';
      } else if (char === ';' && !escape) {
        push([state, value]);
        state = ';';
      } else if (char === ']' && !escape) push([state, value]);
      else cat(char);
      continue
    }
    if (char === '/' || char === ':' || char === '~' || char === '@'
      || char === '[' || char === '!' || char === ',') state = char;
  }
  return tokens
};

const findTokens = (tokens, x) => findIndices(tokens, ([t]) => t === x);

const parser = tokens => {
  const parts = [];
  let state;
  for (const [type, val] of tokens) {
    if (type === '/') parts.push({ index: val });
    else {
      const last = parts[parts.length - 1];
      if (type === ':') last.offset = val;
      else if (type === '~') last.temporal = val;
      else if (type === '@') last.spatial = (last.spatial ?? []).concat(val);
      else if (type === ';s') last.side = val;
      else if (type === '[') {
        if (state === '/' && val) last.id = val;
        else {
          last.text = (last.text ?? []).concat(val);
          continue
        }
      }
    }
    state = type;
  }
  return parts
};

// split at step indirections, then parse each part
const parserIndir = tokens =>
  splitAt(tokens, findTokens(tokens, '!')).map(parser);

const parse = cfi => {
  const tokens = tokenizer(unwrap(cfi));
  const commas = findTokens(tokens, ',');
  if (!commas.length) return parserIndir(tokens)
  const [parent, start, end] = splitAt(tokens, commas).map(parserIndir);
  return { parent, start, end }
};

const partToString = ({ index, id, offset, temporal, spatial, text, side }) => {
  const param = side ? `;s=${side}` : '';
  return `/${index}`
    + (id ? `[${escapeCFI(id)}${param}]` : '')
    // "CFI expressions [..] SHOULD include an explicit character offset"
    + (offset != null && index % 2 ? `:${offset}` : '')
    + (temporal ? `~${temporal}` : '')
    + (spatial ? `@${spatial.join(':')}` : '')
    + (text || (!id && side) ? '['
      + (text?.map(escapeCFI)?.join(',') ?? '')
      + param + ']' : '')
};

const toInnerString = parsed => parsed.parent
  ? [parsed.parent, parsed.start, parsed.end].map(toInnerString).join(',')
  : parsed.map(parts => parts.map(partToString).join('')).join('!');

const toString = parsed => wrap(toInnerString(parsed));

const collapse = (x, toEnd) => typeof x === 'string'
  ? toString(collapse(parse(x), toEnd))
  : x.parent ? concatArrays(x.parent, x[toEnd ? 'end' : 'start']) : x;

const isTextNode = ({ nodeType }) => nodeType === 3 || nodeType === 4;
const isElementNode = ({ nodeType }) => nodeType === 1;

// child nodes are organized such that the result is always
//     [element, text, element, text, ..., element],
// regardless of the actual structure in the document;
// so multiple text nodes need to be combined, and nonexistent ones counted;
// see "Step Reference to Child Element or Character Data (/)" in EPUB CFI spec
const indexChildNodes = node => {
  const nodes = Array.from(node.childNodes)
    // "content other than element and character data is ignored"
    .filter(node => isTextNode(node) || isElementNode(node))
    .reduce((arr, node) => {
      let last = arr[arr.length - 1];
      if (!last) arr.push(node);
      // "there is one chunk between each pair of child elements"
      else if (isTextNode(node)) {
        if (Array.isArray(last)) last.push(node);
        else if (isTextNode(last)) arr[arr.length - 1] = [last, node];
        else arr.push(node);
      } else {
        if (isElementNode(last)) arr.push(null, node);
        else arr.push(node);
      }
      return arr
    }, []);
  // "the first chunk is located before the first child element"
  if (isElementNode(nodes[0])) nodes.unshift('first');
  // "the last chunk is located after the last child element"
  if (isElementNode(nodes[nodes.length - 1])) nodes.push('last');
  // "'virtual' elements"
  nodes.unshift('before'); // "0 is a valid index"
  nodes.push('after'); // "n+2 is a valid index"
  return nodes
};

const getNodeByIndex = (node, index) => node ? indexChildNodes(node)[index] : null;

const partsToNode = (node, parts) => {
  const { id } = parts[parts.length - 1];
  if (id) {
    const el = node.ownerDocument.getElementById(id);
    if (el) return { node: el, offset: 0 }
  }
  for (const { index } of parts) {
    const newNode = getNodeByIndex(node, index);
    // handle non-existent nodes
    if (newNode === 'first') return { node: node.firstChild ?? node }
    if (newNode === 'last') return { node: node.lastChild ?? node }
    if (newNode === 'before') return { node, before: true }
    if (newNode === 'after') return { node, after: true }
    node = newNode;
  }
  const { offset } = parts[parts.length - 1];
  if (!Array.isArray(node)) return { node, offset }
  // get underlying text node and offset from the chunk
  let sum = 0;
  for (const n of node) {
    const { length } = n.nodeValue;
    if (sum + length >= offset) return { node: n, offset: offset - sum }
    sum += length;
  }
};

const nodeToParts = (node, offset) => {
  const { parentNode, id } = node;
  const indexed = indexChildNodes(parentNode);
  const index = indexed.findIndex(x =>
    Array.isArray(x) ? x.some(x => x === node) : x === node);
  // adjust offset as if merging the text nodes in the chunk
  const chunk = indexed[index];
  if (Array.isArray(chunk)) {
    let sum = 0;
    for (const x of chunk) {
      if (x === node) {
        sum += offset;
        break
      } else sum += x.nodeValue.length;
    }
    offset = sum;
  }
  const part = { id, index, offset };
  return parentNode !== node.ownerDocument.documentElement
    ? nodeToParts(parentNode).concat(part) : [part]
};

const toRange = (doc, parts) => {
  const startParts = collapse(parts);
  const endParts = collapse(parts, true);

  const root = doc.documentElement;
  const start = partsToNode(root, startParts[0]);
  const end = partsToNode(root, endParts[0]);

  const range = doc.createRange();

  if (start.before) range.setStartBefore(start.node);
  else if (start.after) range.setStartAfter(start.node);
  else range.setStart(start.node, start.offset);

  if (end.before) range.setEndBefore(end.node);
  else if (end.after) range.setEndAfter(end.node);
  else range.setEnd(end.node, end.offset);
  return range
};

// faster way of getting CFIs for sorted elements in a single parent
const fromElements = elements => {
  const results = [];
  const { parentNode } = elements[0];
  const parts = nodeToParts(parentNode);
  for (const [index, node] of indexChildNodes(parentNode).entries()) {
    const el = elements[results.length];
    if (node === el)
      results.push(toString([parts.concat({ id: el.id, index })]));
  }
  return results
};

const toElement = (doc, parts) =>
  partsToNode(doc.documentElement, collapse(parts)).node;

const NS$1 = {
  CONTAINER: "urn:oasis:names:tc:opendocument:xmlns:container",
  XHTML: "http://www.w3.org/1999/xhtml",
  OPF: "http://www.idpf.org/2007/opf",
  EPUB: "http://www.idpf.org/2007/ops",
  DC: "http://purl.org/dc/elements/1.1/",
  DCTERMS: "http://purl.org/dc/terms/",
  ENC: "http://www.w3.org/2001/04/xmlenc#",
  NCX: "http://www.daisy.org/z3986/2005/ncx/",
  XLINK: "http://www.w3.org/1999/xlink",
  SMIL: "http://www.w3.org/ns/SMIL",
};

const MIME$2 = {
  XML: "application/xml",
  NCX: "application/x-dtbncx+xml",
  XHTML: "application/xhtml+xml",
  HTML: "text/html",
  CSS: "text/css",
  SVG: "image/svg+xml",
  JS: /\/(x-)?(javascript|ecmascript)/,
};

// convert to camel case
const camel = (x) =>
  x.toLowerCase().replace(/[-:](.)/g, (_, g) => g.toUpperCase());

// remove leading, trailing, and excess internal whitespace
const whitespacePreLine = (str) =>
  str ? str.trim().replace(/\s{2,}/g, " ") : "";

const filterAttribute = (attr, value, isList) =>
  isList
    ? (el) => el.getAttribute(attr)?.split(/\s/)?.includes(value)
    : typeof value === "function"
      ? (el) => value(el.getAttribute(attr))
      : (el) => el.getAttribute(attr) === value;

const getAttributes =
  (...xs) =>
    (el) =>
      el
        ? Object.fromEntries(xs.map((x) => [camel(x), el.getAttribute(x)]))
        : null;

const getElementText$1 = (el) => whitespacePreLine(el?.textContent);

const childGetter = (doc, ns) => {
  // ignore the namespace if it doesn't appear in document at all
  const useNS = doc.lookupNamespaceURI(null) === ns || doc.lookupPrefix(ns);
  const f = useNS
    ? (el, name) => (el) => el.namespaceURI === ns && el.localName === name
    : (el, name) => (el) => el.localName === name;
  return {
    $: (el, name) => [...el.children].find(f(el, name)),
    $$: (el, name) => [...el.children].filter(f(el, name)),
    $$$: useNS
      ? (el, name) => [...el.getElementsByTagNameNS(ns, name)]
      : (el, name) => [...el.getElementsByTagName(ns, name)],
  };
};

const resolveURL = (url, relativeTo) => {
  try {
    if (relativeTo.includes(":")) return new URL(url, relativeTo);
    // the base needs to be a valid URL, so set a base URL and then remove it
    const root = "whatever://whatever/";
    return decodeURI(new URL(url, root + relativeTo).href.replace(root, ""));
  } catch (e) {
    console.warn(e);
    return url;
  }
};

const isExternal = (uri) => /^(?!blob)\w+:/i.test(uri);

// like `path.relative()` in Node.js
const pathRelative = (from, to) => {
  if (!from) return to;
  const as = from.replace(/\/$/, "").split("/");
  const bs = to.replace(/\/$/, "").split("/");
  const i = (as.length > bs.length ? as : bs).findIndex(
    (_, i) => as[i] !== bs[i]
  );
  return i < 0
    ? ""
    : Array(as.length - i)
      .fill("..")
      .concat(bs.slice(i))
      .join("/");
};

const pathDirname = (str) => str.slice(0, str.lastIndexOf("/") + 1);

// replace asynchronously and sequentially
// same techinque as https://stackoverflow.com/a/48032528
const replaceSeries$1 = async (str, regex, f) => {
  const matches = [];
  str.replace(regex, (...args) => (matches.push(args), null));
  const results = [];
  for (const args of matches) results.push(await f(...args));
  return str.replace(regex, () => results.shift());
};

const regexEscape = (str) => str.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&");

const LANGS = { attrs: ["dir", "xml:lang"] };
const ALTS = {
  name: "alternate-script",
  many: true,
  ...LANGS,
  props: ["file-as"],
};
const CONTRIB = {
  many: true,
  ...LANGS,
  props: [{ name: "role", many: true, attrs: ["scheme"] }, "file-as", ALTS],
};
const METADATA = [
  {
    name: "title",
    many: true,
    ...LANGS,
    props: ["title-type", "display-seq", "file-as", ALTS],
  },
  {
    name: "identifier",
    many: true,
    props: [{ name: "identifier-type", attrs: ["scheme"] }],
  },
  { name: "language", many: true },
  { name: "creator", ...CONTRIB },
  { name: "contributor", ...CONTRIB },
  { name: "publisher", ...LANGS, props: ["file-as", ALTS] },
  { name: "description", ...LANGS, props: [ALTS] },
  { name: "rights", ...LANGS, props: [ALTS] },
  { name: "date" },
  { name: "dcterms:modified", type: "meta" },
  { name: "subject", many: true, ...LANGS, props: ["term", "authority", ALTS] },
  {
    name: "belongs-to-collection",
    type: "meta",
    many: true,
    ...LANGS,
    props: [
      "collection-type",
      "group-position",
      "dcterms:identifier",
      "file-as",
      ALTS,
      { name: "belongs-to-collection", recursive: true },
    ],
  },
];

// NOTE: this only gets properties defined with the `refines` attribute,
// which is used in EPUB 3.0, deprecated in 3.1, then restored in 3.2;
// no support for `opf:` attributes of 2.0 and 3.1
const getMetadata = (opf) => {
  const { $, $$ } = childGetter(opf, NS$1.OPF);
  const $metadata = $(opf.documentElement, "metadata");
  const els = Array.from($metadata.children);
  const getValue = (obj, el) => {
    if (!el) return null;
    const { props = [], attrs = [] } = obj;
    const value = getElementText$1(el);
    if (!props.length && !attrs.length) return value;
    const id = el.getAttribute("id");
    const refines = id ? els.filter(filterAttribute("refines", "#" + id)) : [];
    return Object.fromEntries(
      [["value", value]]
        .concat(
          props.map((prop) => {
            const { many, recursive } = prop;
            const name = typeof prop === "string" ? prop : prop.name;
            const filter = filterAttribute("property", name);
            const subobj = recursive ? obj : prop;
            return [
              camel(name),
              many
                ? refines.filter(filter).map((el) => getValue(subobj, el))
                : getValue(subobj, refines.find(filter)),
            ];
          })
        )
        .concat(attrs.map((attr) => [camel(attr), el.getAttribute(attr)]))
    );
  };
  const arr = els.filter(filterAttribute("refines", null));
  const metadata = Object.fromEntries(
    METADATA.map((obj) => {
      const { type, name, many } = obj;
      const filter =
        type === "meta"
          ? (el) =>
            el.namespaceURI === NS$1.OPF && el.getAttribute("property") === name
          : (el) => el.namespaceURI === NS$1.DC && el.localName === name;
      return [
        camel(name),
        many
          ? arr.filter(filter).map((el) => getValue(obj, el))
          : getValue(obj, arr.find(filter)),
      ];
    })
  );

  const getProperties = (prefix) =>
    Object.fromEntries(
      $$($metadata, "meta")
        .filter(filterAttribute("property", (x) => x?.startsWith(prefix)))
        .map((el) => [
          el.getAttribute("property").replace(prefix, ""),
          getElementText$1(el),
        ])
    );
  const rendition = getProperties("rendition:");
  const media = getProperties("media:");
  return { metadata, rendition, media };
};

const parseNav = (doc, resolve = (f) => f) => {
  const { $, $$, $$$ } = childGetter(doc, NS$1.XHTML);
  const resolveHref = (href) => (href ? decodeURI(resolve(href)) : null);
  const parseLI = (getType) => ($li) => {
    const $a = $($li, "a") ?? $($li, "span");
    const $ol = $($li, "ol");
    const href = resolveHref($a?.getAttribute("href"));
    const label = getElementText$1($a) || $a?.getAttribute("title");
    // TODO: get and concat alt/title texts in content
    const result = { label, href, subitems: parseOL($ol) };
    if (getType) result.type = $a?.getAttributeNS(NS$1.EPUB, "type")?.split(/\s/);
    return result;
  };
  const parseOL = ($ol, getType) =>
    $ol ? $$($ol, "li").map(parseLI(getType)) : null;
  const parseNav = ($nav, getType) => parseOL($($nav, "ol"), getType);

  const $$nav = $$$(doc, "nav");
  let toc = null,
    pageList = null,
    landmarks = null,
    others = [];
  for (const $nav of $$nav) {
    const type = $nav.getAttributeNS(NS$1.EPUB, "type")?.split(/\s/) ?? [];
    if (type.includes("toc")) toc ??= parseNav($nav);
    else if (type.includes("page-list")) pageList ??= parseNav($nav);
    else if (type.includes("landmarks")) landmarks ??= parseNav($nav, true);
    else
      others.push({
        label: getElementText$1($nav.firstElementChild),
        type,
        list: parseNav($nav),
      });
  }
  return { toc, pageList, landmarks, others };
};

const parseNCX = (doc, resolve = (f) => f) => {
  const { $, $$ } = childGetter(doc, NS$1.NCX);
  const resolveHref = (href) => (href ? decodeURI(resolve(href)) : null);
  const parseItem = (el) => {
    const $label = $(el, "navLabel");
    const $content = $(el, "content");
    const label = getElementText$1($label);
    const href = resolveHref($content.getAttribute("src"));
    if (el.localName === "navPoint") {
      const els = $$(el, "navPoint");
      return { label, href, subitems: els.length ? els.map(parseItem) : null };
    }
    return { label, href };
  };
  const parseList = (el, itemName) => $$(el, itemName).map(parseItem);
  const getSingle = (container, itemName) => {
    const $container = $(doc.documentElement, container);
    return $container ? parseList($container, itemName) : null;
  };
  return {
    toc: getSingle("navMap", "navPoint"),
    pageList: getSingle("pageList", "pageTarget"),
    others: $$(doc.documentElement, "navList").map((el) => ({
      label: getElementText$1($(el, "navLabel")),
      list: parseList(el, "navTarget"),
    })),
  };
};

const parseClock = (str) => {
  if (!str) return;
  const parts = str.split(":").map((x) => parseFloat(x));
  if (parts.length === 3) {
    const [h, m, s] = parts;
    return h * 60 * 60 + m * 60 + s;
  }
  if (parts.length === 2) {
    const [m, s] = parts;
    return m * 60 + s;
  }
  const [x, unit] = str.split(/(?=[^\d.])/);
  const n = parseFloat(x);
  const f =
    unit === "h" ? 60 * 60 : unit === "min" ? 60 : unit === "ms" ? 0.001 : 1;
  return n * f;
};

const parseSMIL = (doc, resolve = (f) => f) => {
  const { $, $$$ } = childGetter(doc, NS$1.SMIL);
  const resolveHref = (href) => (href ? decodeURI(resolve(href)) : null);
  return $$$(doc, "par").map(($par) => {
    const id = $($par, "text")?.getAttribute("src")?.split("#")?.[1];
    const $audio = $($par, "audio");
    return $audio
      ? {
        id,
        audio: {
          src: resolveHref($audio.getAttribute("src")),
          clipBegin: parseClock($audio.getAttribute("clipBegin")),
          clipEnd: parseClock($audio.getAttribute("clipEnd")),
        },
      }
      : { id };
  });
};

const isUUID =
  /([0-9a-f]{8})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{12})/;

const getUUID = (opf) => {
  for (const el of opf.getElementsByTagNameNS(NS$1.DC, "identifier")) {
    const [id] = getElementText$1(el).split(":").slice(-1);
    if (isUUID.test(id)) return id;
  }
  return "";
};

const getIdentifier = (opf) =>
  getElementText$1(
    opf.getElementById(opf.documentElement.getAttribute("unique-identifier")) ??
    opf.getElementsByTagNameNS(NS$1.DC, "identifier")[0]
  );

// https://www.w3.org/publishing/epub32/epub-ocf.html#sec-resource-obfuscation
const deobfuscate = async (key, length, blob) => {
  const array = new Uint8Array(await blob.slice(0, length).arrayBuffer());
  length = Math.min(length, array.length);
  for (var i = 0; i < length; i++) array[i] = array[i] ^ key[i % key.length];
  return new Blob([array, blob.slice(length)], { type: blob.type });
};

const WebCryptoSHA1 = async (str) => {
  const data = new TextEncoder().encode(str);
  const buffer = await globalThis.crypto.subtle.digest("SHA-1", data);
  return new Uint8Array(buffer);
};

const deobfuscators = (sha1 = WebCryptoSHA1) => ({
  "http://www.idpf.org/2008/embedding": {
    key: (opf) =>
      sha1(
        getIdentifier(opf)
          // eslint-disable-next-line no-control-regex
          .replaceAll(/[\u0020\u0009\u000d\u000a]/g, "")
      ),
    decode: (key, blob) => deobfuscate(key, 1040, blob),
  },
  "http://ns.adobe.com/pdf/enc#RC": {
    key: (opf) => {
      const uuid = getUUID(opf).replaceAll("-", "");
      return Uint8Array.from({ length: 16 }, (_, i) =>
        parseInt(uuid.slice(i * 2, i * 2 + 2), 16)
      );
    },
    decode: (key, blob) => deobfuscate(key, 1024, blob),
  },
});

class Encryption {
  #uris = new Map();
  #decoders = new Map();
  #algorithms;
  constructor(algorithms) {
    this.#algorithms = algorithms;
  }
  async init(encryption, opf) {
    if (!encryption) return;
    const data = Array.from(
      encryption.getElementsByTagNameNS(NS$1.ENC, "EncryptedData"),
      (el) => ({
        algorithm: el
          .getElementsByTagNameNS(NS$1.ENC, "EncryptionMethod")[0]
          ?.getAttribute("Algorithm"),
        uri: el
          .getElementsByTagNameNS(NS$1.ENC, "CipherReference")[0]
          ?.getAttribute("URI"),
      })
    );
    for (const { algorithm, uri } of data) {
      if (!this.#decoders.has(algorithm)) {
        const algo = this.#algorithms[algorithm];
        if (!algo) {
          console.warn("Unknown encryption algorithm");
          continue;
        }
        const key = await algo.key(opf);
        this.#decoders.set(algorithm, (blob) => algo.decode(key, blob));
      }
      this.#uris.set(uri, algorithm);
    }
  }
  getDecoder(uri) {
    return this.#decoders.get(this.#uris.get(uri)) ?? ((x) => x);
  }
}

class Resources {
  constructor({ opf, resolveHref }) {
    this.opf = opf;
    const { $, $$, $$$ } = childGetter(opf, NS$1.OPF);

    const $manifest = $(opf.documentElement, "manifest");
    const $spine = $(opf.documentElement, "spine");
    const $$itemref = $$($spine, "itemref");

    this.manifest = $$($manifest, "item")
      .map(
        getAttributes("href", "id", "media-type", "properties", "media-overlay")
      )
      .map((item) => {
        item.href = resolveHref(item.href);
        item.properties = item.properties?.split(/\s/);
        return item;
      });
    this.spine = $$itemref
      .map(getAttributes("idref", "id", "linear", "properties"))
      .map((item) => ((item.properties = item.properties?.split(/\s/)), item));
    this.pageProgressionDirection = $spine.getAttribute(
      "page-progression-direction"
    );

    this.navPath = this.getItemByProperty("nav")?.href;
    this.ncxPath = (
      this.getItemByID($spine.getAttribute("toc")) ??
      this.manifest.find((item) => item.mediaType === MIME$2.NCX)
    )?.href;

    const $guide = $(opf.documentElement, "guide");
    if ($guide)
      this.guide = $$($guide, "reference")
        .map(getAttributes("type", "title", "href"))
        .map(({ type, title, href }) => ({
          label: title,
          type: type.split(/\s/),
          href: resolveHref(href),
        }));
    this.cover =
      this.getItemByProperty("cover-image") ??
      this.getItemByID("cover-image") ??
      // EPUB 2 compat
      this.getItemByID(
        $$$(opf, "meta")
          .find(filterAttribute("name", "cover"))
          ?.getAttribute("content")
      ) ??
      this.getItemByID("cover") ??
      this.getItemByHref(
        this.guide?.find((ref) => ref.type.includes("cover") && !ref.href.includes("html") && !ref.href.includes("xml"))?.href
      );

    this.cfis = fromElements($$itemref);
  }
  getItemByID(id) {
    return this.manifest.find((item) => item.id === id);
  }
  getItemByHref(href) {
    return this.manifest.find((item) => item.href === href);
  }
  getItemByProperty(prop) {
    return this.manifest.find((item) => item.properties?.includes(prop));
  }
  resolveCFI(cfi) {
    const parts = parse(cfi);
    const top = (parts.parent ?? parts).shift();
    let $itemref = toElement(this.opf, top);
    // make sure it's an idref; if not, try again without the ID assertion
    // mainly because Epub.js used to generate wrong ID assertions
    // https://github.com/futurepress/epub.js/issues/1236
    if ($itemref && $itemref.nodeName !== "idref") {
      top.at(-1).id = null;
      $itemref = toElement(this.opf, top);
    }
    const idref = $itemref?.getAttribute("idref");
    const index = this.spine.findIndex((item) => item.idref === idref);
    const anchor = (doc) => toRange(doc, parts);
    return { index, anchor };
  }
}

class Loader {
  #cache = new Map();
  #children = new Map();
  #refCount = new Map();
  allowScript = false;
  constructor({ loadText, loadBlob, resources }) {
    this.loadText = loadText;
    this.loadBlob = loadBlob;
    this.manifest = resources.manifest;
    this.assets = resources.manifest;
    // needed only when replacing in (X)HTML w/o parsing (see below)
    //.filter(({ mediaType }) => ![MIME.XHTML, MIME.HTML].includes(mediaType))
  }
  createURL(href, data, type, parent) {
    if (!data) return "";
    const url = URL.createObjectURL(new Blob([data], { type }));
    this.#cache.set(href, url);
    this.#refCount.set(href, 1);
    if (parent) {
      const childList = this.#children.get(parent);
      if (childList) childList.push(href);
      else this.#children.set(parent, [href]);
    }
    return url;
  }
  ref(href, parent) {
    const childList = this.#children.get(parent);
    if (!childList?.includes(href)) {
      this.#refCount.set(href, this.#refCount.get(href) + 1);
      //console.log(`referencing ${href}, now ${this.#refCount.get(href)}`)
      if (childList) childList.push(href);
      else this.#children.set(parent, [href]);
    }
    return this.#cache.get(href);
  }
  unref(href) {
    if (!this.#refCount.has(href)) return;
    const count = this.#refCount.get(href) - 1;
    //console.log(`unreferencing ${href}, now ${count}`)
    if (count < 1) {
      //console.log(`unloading ${href}`)
      URL.revokeObjectURL(this.#cache.get(href));
      this.#cache.delete(href);
      this.#refCount.delete(href);
      // unref children
      const childList = this.#children.get(href);
      if (childList) while (childList.length) this.unref(childList.pop());
      this.#children.delete(href);
    } else this.#refCount.set(href, count);
  }
  // load manifest item, recursively loading all resources as needed
  async loadItem(item, parents = []) {
    if (!item) return null;
    const { href, mediaType } = item;

    const isScript = MIME$2.JS.test(item.mediaType);
    if (isScript && !this.allowScript) return null;

    const parent = parents.at(-1);
    if (this.#cache.has(href)) return this.ref(href, parent);

    const shouldReplace =
      (isScript ||
        [MIME$2.XHTML, MIME$2.HTML, MIME$2.CSS, MIME$2.SVG].includes(mediaType)) &&
      // prevent circular references
      parents.every((p) => p !== href);
    if (shouldReplace) return this.loadReplaced(item, parents);
    return this.createURL(href, await this.loadBlob(href), mediaType, parent);
  }
  async loadHref(href, base, parents = []) {
    if (isExternal(href)) return href;
    const path = resolveURL(href, base);
    let item = this.manifest.find((item) => item.href === path);
    if (!item) {
      item = { href: path, mediaType: "" };
    }
    return this.loadItem(item, parents.concat(base));
  }
  async loadReplaced(item, parents = []) {
    const { href, mediaType } = item;
    const parent = parents.at(-1);
    const str = await this.loadText(href);
    if (!str) return null;

    // note that one can also just use `replaceString` for everything:
    // ```
    // const replaced = await this.replaceString(str, href, parents)
    // return this.createURL(href, replaced, mediaType, parent)
    // ```
    // which is basically what Epub.js does, which is simpler, but will
    // break things like iframes (because you don't want to replace links)
    // or text that just happen to be paths

    // parse and replace in HTML
    if ([MIME$2.XHTML, MIME$2.HTML, MIME$2.SVG].includes(mediaType)) {
      let doc = new DOMParser().parseFromString(str, mediaType);
      // change to HTML if it's not valid XHTML
      if (mediaType === MIME$2.XHTML && doc.querySelector("parsererror")) {
        console.warn(doc.querySelector("parsererror").innerText);
        item.mediaType = MIME$2.HTML;
        doc = new DOMParser().parseFromString(str, item.mediaType);
      }
      // replace hrefs in XML processing instructions
      // this is mainly for SVGs that use xml-stylesheet
      if ([MIME$2.XHTML, MIME$2.SVG].includes(item.mediaType)) {
        let child = doc.firstChild;
        while (child instanceof ProcessingInstruction) {
          if (child.data) {
            const replacedData = await replaceSeries$1(
              child.data,
              /(?:^|\s*)(href\s*=\s*['"])([^'"]*)(['"])/i,
              (_, p1, p2, p3) =>
                this.loadHref(p2, href, parents).then((p2) => `${p1}${p2}${p3}`)
            );
            child.replaceWith(
              doc.createProcessingInstruction(child.target, replacedData)
            );
          }
          child = child.nextSibling;
        }
      }
      // replace hrefs (excluding anchors)
      // TODO: srcset?
      const replace = async (el, attr) =>
        el.setAttribute(
          attr,
          await this.loadHref(el.getAttribute(attr), href, parents)
        );
      for (const el of doc.querySelectorAll("link[href]"))
        await replace(el, "href");
      for (const el of doc.querySelectorAll("[src]")) await replace(el, "src");
      for (const el of doc.querySelectorAll("[poster]"))
        await replace(el, "poster");
      for (const el of doc.querySelectorAll("object[data]"))
        await replace(el, "data");
      for (const el of doc.querySelectorAll("[*|href]:not([href]"))
        el.setAttributeNS(
          NS$1.XLINK,
          "href",
          await this.loadHref(
            el.getAttributeNS(NS$1.XLINK, "href"),
            href,
            parents
          )
        );
      // replace inline styles
      for (const el of doc.querySelectorAll("style"))
        if (el.textContent)
          el.textContent = await this.replaceCSS(el.textContent, href, parents);
      for (const el of doc.querySelectorAll("[style]"))
        el.setAttribute(
          "style",
          await this.replaceCSS(el.getAttribute("style"), href, parents)
        );
      // TODO: replace inline scripts? probably not worth the trouble
      const result = new XMLSerializer().serializeToString(doc);
      return this.createURL(href, result, item.mediaType, parent);
    }

    const result =
      mediaType === MIME$2.CSS
        ? await this.replaceCSS(str, href, parents)
        : await this.replaceString(str, href, parents);
    return this.createURL(href, result, mediaType, parent);
  }
  async replaceCSS(str, href, parents = []) {
    const replacedUrls = await replaceSeries$1(
      str,
      /url\(\s*["']?([^'"\n]*?)\s*["']?\s*\)/gi,
      (_, url) =>
        this.loadHref(url, href, parents).then((url) => `url("${url}")`)
    );
    // apart from `url()`, strings can be used for `@import` (but why?!)
    const replacedImports = await replaceSeries$1(
      replacedUrls,
      /@import\s*["']([^"'\n]*?)["']/gi,
      (_, url) =>
        this.loadHref(url, href, parents).then((url) => `@import "${url}"`)
    );
    const w = window?.innerWidth ?? 800;
    const h = window?.innerHeight ?? 600;
    return (
      replacedImports
        // unprefix as most of the props are (only) supported unprefixed
        .replace(/-epub-/gi, "")
        // replace vw and vh as they cause problems with layout
        .replace(/(\d*\.?\d+)vw/gi, (_, d) => (parseFloat(d) * w) / 100 + "px")
        .replace(/(\d*\.?\d+)vh/gi, (_, d) => (parseFloat(d) * h) / 100 + "px")
        // `page-break-*` unsupported in columns; replace with `column-break-*`
        .replace(
          /page-break-(after|before|inside)/gi,
          (_, x) => `-webkit-column-break-${x}`
        )
    );
  }
  // find & replace all possible relative paths for all assets without parsing
  replaceString(str, href, parents = []) {
    const assetMap = new Map();
    const urls = this.assets
      .map((asset) => {
        // do not replace references to the file itself
        if (asset.href === href) return;
        // href was decoded and resolved when parsing the manifest
        const relative = pathRelative(pathDirname(href), asset.href);
        const relativeEnc = encodeURI(relative);
        const rootRelative = "/" + asset.href;
        const rootRelativeEnc = encodeURI(rootRelative);
        const set = new Set([
          relative,
          relativeEnc,
          rootRelative,
          rootRelativeEnc,
        ]);
        for (const url of set) assetMap.set(url, asset);
        return Array.from(set);
      })
      .flat()
      .filter((x) => x);
    if (!urls.length) return str;
    const regex = new RegExp(urls.map(regexEscape).join("|"), "g");
    return replaceSeries$1(str, regex, async (match) =>
      this.loadItem(
        assetMap.get(match.replace(/^\//, "")),
        parents.concat(href)
      )
    );
  }
  unloadItem(item) {
    this.unref(item?.href);
  }
}

const getHTMLFragment = (doc, id) =>
  doc.getElementById(id) ?? doc.querySelector(`[name="${CSS.escape(id)}"]`);

const getPageSpread$1 = (properties) => {
  for (const p of properties) {
    if (p === "page-spread-left" || p === "rendition:page-spread-left")
      return "left";
    if (p === "page-spread-right" || p === "rendition:page-spread-right")
      return "right";
    if (p === "rendition:page-spread-center") return "center";
  }
};

class EPUB {
  parser = new DOMParser();
  #encryption;
  constructor({ loadText, loadBlob, getSize, sha1 }) {
    this.loadText = loadText;
    this.loadBlob = loadBlob;
    this.getSize = getSize;
    this.#encryption = new Encryption(deobfuscators(sha1));
  }
  #parseXML(str) {
    if (str && str.includes("opf:scheme")) {
      str = str.replaceAll("opf:scheme", "scheme");
    }
    return str ? this.parser.parseFromString(str, MIME$2.XML) : null;
  }
  async #loadXML(uri) {
    return this.#parseXML(await this.loadText(uri));
  }
  async init() {
    const $container = await this.#loadXML("META-INF/container.xml");
    if (!$container) throw new Error("Failed to load container file");

    const opfs = Array.from(
      $container.getElementsByTagNameNS(NS$1.CONTAINER, "rootfile"),
      getAttributes("full-path", "media-type")
    ).filter((file) => file.mediaType === "application/oebps-package+xml");

    if (!opfs.length)
      throw new Error("No package document defined in container");
    const opfPath = opfs[0].fullPath;
    const opf = await this.#loadXML(opfPath);
    if (!opf) throw new Error("Failed to load package document");

    const $encryption = await this.#loadXML("META-INF/encryption.xml");
    await this.#encryption.init($encryption, opf);

    this.resources = new Resources({
      opf,
      resolveHref: (url) => resolveURL(url, opfPath),
    });
    const loader = new Loader({
      loadText: this.loadText,
      loadBlob: (uri) =>
        Promise.resolve(this.loadBlob(uri)).then(
          this.#encryption.getDecoder(uri)
        ),
      resources: this.resources,
    });
    this.sections = this.resources.spine
      .map((spineItem, index) => {
        const { idref, linear, properties = [] } = spineItem;
        const item = this.resources.getItemByID(idref);
        if (!item) {
          console.warn(`Could not find item with ID "${idref}" in manifest`);
          return null;
        }
        return {
          id: this.resources.getItemByID(idref)?.href,
          load: () => loader.loadItem(item),
          unload: () => loader.unloadItem(item),
          createDocument: () => this.loadDocument(item),
          size: this.getSize(item.href),
          cfi: this.resources.cfis[index],
          linear,
          pageSpread: getPageSpread$1(properties),
          resolveHref: (href) => resolveURL(href, item.href),
          loadMediaOverlay: () => this.loadMediaOverlay(item),
        };
      })
      .filter((s) => s);

    const { navPath, ncxPath } = this.resources;
    if (navPath)
      try {
        const resolve = (url) => resolveURL(url, navPath);
        const nav = parseNav(await this.#loadXML(navPath), resolve);
        this.toc = nav.toc;
        this.pageList = nav.pageList;
        this.landmarks = nav.landmarks;
      } catch (e) {
        console.warn(e);
      }
    if ((!this.toc || this.toc.length === 0) && ncxPath)
      try {
        const resolve = (url) => resolveURL(url, ncxPath);
        const ncx = parseNCX(await this.#loadXML(ncxPath), resolve);
        this.toc = ncx.toc;
        this.pageList = ncx.pageList;
      } catch (e) {
        console.warn(e);
      }
    this.landmarks ??= this.resources.guide;

    const { metadata, rendition, media } = getMetadata(opf);
    this.rendition = rendition;
    this.media = media;
    media.duration = parseClock(media.duration);
    this.dir = this.resources.pageProgressionDirection;

    this.rawMetadata = metadata; // useful for debugging, i guess
    const title = metadata?.title?.[0];
    this.metadata = {
      title: title?.value,
      sortAs: title?.fileAs,
      language: metadata?.language,
      identifier: getIdentifier(opf),
      description: metadata?.description?.value,
      publisher: metadata?.publisher?.value,
      published: metadata?.date,
      modified: metadata?.dctermsModified,
      subject: metadata?.subject
        ?.filter(({ value, code }) => value || code)
        ?.map(({ value, code, scheme }) => ({ name: value, code, scheme })),
      rights: metadata?.rights?.value,
    };
    const relators = {
      art: "artist",
      aut: "author",
      bkp: "producer",
      clr: "colorist",
      edt: "editor",
      ill: "illustrator",
      trl: "translator",
      pbl: "publisher",
    };
    const mapContributor = (defaultKey) => (obj) => {
      const keys = [
        ...new Set(
          obj.role?.map(
            ({ value, scheme }) =>
              (!scheme || scheme === "marc:relators"
                ? relators[value]
                : null) ?? defaultKey
          )
        ),
      ];
      const value = { name: obj.value, sortAs: obj.fileAs };
      return [keys?.length ? keys : [defaultKey], value];
    };
    metadata?.creator
      ?.map(mapContributor("author"))
      ?.concat(metadata?.contributor?.map?.(mapContributor("contributor")))
      ?.forEach(([keys, value]) =>
        keys.forEach((key) => {
          if (this.metadata[key]) this.metadata[key].push(value);
          else this.metadata[key] = [value];
        })
      );

    return this;
  }
  async loadDocument(item) {
    const str = await this.loadText(item.href);
    return this.parser.parseFromString(str, item.mediaType);
  }
  async loadMediaOverlay(item) {
    const id = item.mediaOverlay;
    if (!id) return null;
    const media = this.resources.getItemByID(id);
    const doc = await this.#loadXML(media.href);
    const parsed = parseSMIL(doc, (url) => resolveURL(url, media.href));
    return parsed;
  }
  resolveCFI(cfi) {
    return this.resources.resolveCFI(cfi);
  }
  resolveHref(href) {
    const [path, hash] = href.split("#");
    const item = this.resources.getItemByHref(decodeURI(path));
    if (!item) return null;
    const index = this.resources.spine.findIndex(
      ({ idref }) => idref === item.id
    );
    const anchor = hash ? (doc) => getHTMLFragment(doc, hash) : () => 0;
    return { index, anchor };
  }
  splitTOCHref(href) {
    return href?.split("#") ?? [];
  }
  getTOCFragment(doc, id) {
    return (
      doc.getElementById(id) ?? doc.querySelector(`[name="${CSS.escape(id)}"]`)
    );
  }
  isExternal(uri) {
    return isExternal(uri);
  }
  async getCover() {
    const cover = this.resources?.cover;
    return cover?.href
      ? new Blob([await this.loadBlob(cover.href)], { type: cover.mediaType })
      : null;
  }
  async getCalibreBookmarks() {
    const txt = await this.loadText("META-INF/calibre_bookmarks.txt");
    const magic = "encoding=json+base64:";
    if (txt?.startsWith(magic)) {
      const json = atob(txt.slice(magic.length));
      return JSON.parse(json);
    }
  }
}

const makeHtmlBook = (bookStr, isTxt = false, parserRegex = "") => {
    const bookDoc = new DOMParser().parseFromString(isTxt ? txtToHtml(bookStr, parserRegex) : bookStr, "text/html");
    let chapterDomList = getTitleElement(bookDoc);
    if (chapterDomList.length === 0) {
        chapterDomList = getTitlefromText(bookDoc);
    }
    for (let i = 0; i < chapterDomList.length; i++) {
        // this.chapterDomList[i].id = this.chapterList[i].id;
        var newItem = document.createElement("address");
        var textnode = document.createTextNode(" ");
        newItem.appendChild(textnode);
        chapterDomList[i].parentNode &&
            chapterDomList[i].parentNode.insertBefore(newItem, chapterDomList[i]);
    }
    const chapterList = getChapterDoc(bookDoc.body.innerHTML);
    const load = (index) => __awaiter(void 0, void 0, void 0, function* () {
        const page = URL.createObjectURL(new Blob([chapterList[index].text], { type: "text/html" }));
        return page;
    });
    const unload = (index) => { };
    const book = {};
    book.getCover = () => "";
    book.sections = chapterList.map((item) => ({
        id: item.index,
        load: () => load(item.index),
        unload: () => unload(item.index),
    }));
    book.toc = chapterList
        .map((item) => ({
        label: item.label,
        href: "title" + item.index,
    }))
        .filter((item) => item.label !== "");
    book.rendition = { layout: "pre-paginated" };
    book.resolveHref = (href) => {
        return { index: parseInt(href.substring(5, href.length)) };
    };
    book.splitTOCHref = (href) => [href, null];
    book.getTOCFragment = (doc) => doc.documentElement;
    return book;
};
let keywords = [
    "章",
    "节",
    "回",
    "節",
    "卷",
    "部",
    "輯",
    "辑",
    "話",
    "集",
    "话",
    "篇",
    " ",
    "　",
];
let containChars = [];
// let containChars = ["[", "。", "；", ";"];
let startWithChars = [
    "CHAPTER",
    "Chapter",
    "序章",
    "前言",
    "声明",
    "写在前面的话",
    "后记",
    "楔子",
    "后序",
    "章节目录",
    "尾声",
];
let startWithNumAndChars = [" ", "　", "、", "·", ".", "：", ":"];
const getTitleElement = (Element) => {
    return Array.from(Element.querySelectorAll("h1,h2,h3,h4,h5,h6,title"));
};
const cleanText = (str) => {
    return str
        .trim()
        .replace(/(\r\n|\n|\r|\t)/gm, "")
        .substring(0, 100)
        .split("")
        .filter((item) => item !== "=" && item !== "-" && item !== "_" && item !== "+")
        .join("");
};
const isTitle = (line, parserRegex = "") => {
    if (parserRegex) {
        return new RegExp(parserRegex).test(line);
    }
    return (line &&
        line.length < 40 &&
        !isContain(line) &&
        (isStartWithChars(line) ||
            (line.startsWith("第") && startWithDI(line)) ||
            (line.startsWith("卷") && startWithJUAN(line)) ||
            (line.indexOf("第") > -1 &&
                line.lastIndexOf("第") < 4 &&
                startWithDI(line.substr(line.indexOf("第")))) ||
            isStartWithNumAndChars(line)));
};
const isContain = (line) => {
    return containChars.filter((item) => line.indexOf(item) > -1).length > 0;
};
const isStartWithChars = (line) => {
    return (startWithChars.filter((item) => line.startsWith(item) ||
        line.startsWith(Chinese.s2t(item)) ||
        line.startsWith(Chinese.t2s(item))).length > 0);
};
const isStartWithNumAndChars = (line) => {
    return (startWithNumAndChars.filter((item) => line.indexOf(item) > -1 &&
        (/^[\u4e00\u4e8c\u4e09\u56db\u4e94\u516d\u4e03\u516b\u4e5d\u5341\u767e\u5343\u4e07\u842c\u96f6]+$/.test(line.substring(0, line.indexOf(item))) ||
            /^\d+$/.test(line.substring(0, line.indexOf(item))))).length > 0);
};
const startWithDI = (line) => {
    let flag = false;
    for (let i = 0; i < keywords.length; i++) {
        if (/^[\u4e00\u4e8c\u4e09\u56db\u4e94\u516d\u4e03\u516b\u4e5d\u5341\u767e\u5343\u4e07\u842c\u96f6]+$/.test(line.substring(1, line.indexOf(keywords[i])).trim()) ||
            /^\d+$/.test(line.substring(1, line.indexOf(keywords[i])).trim())) {
            flag = true;
        }
        if (flag)
            break;
    }
    return flag;
};
const startWithJUAN = (line) => {
    if (/^[\u4e00\u4e8c\u4e09\u56db\u4e94\u516d\u4e03\u516b\u4e5d\u5341\u767e\u5343\u4e07\u842c\u96f6]+$/.test(line.substring(1, line.indexOf(" "))) ||
        /^\d+$/.test(line.substring(1, line.indexOf(" "))))
        return true;
    if (/^[\u4e00\u4e8c\u4e09\u56db\u4e94\u516d\u4e03\u516b\u4e5d\u5341\u767e\u5343\u4e07\u842c\u96f6]+$/.test(line.substring(1, line.indexOf("　"))) ||
        /^\d+$/.test(line.substring(1, line.indexOf("　"))))
        return true;
    if (/^[\u4e00\u4e8c\u4e09\u56db\u4e94\u516d\u4e03\u516b\u4e5d\u5341\u767e\u5343\u4e07\u842c\u96f6]+$/.test(line.substring(1)) ||
        /^\d+$/.test(line.substring(1)))
        return true;
    return false;
};
const getChapterDoc = (bookStr) => {
    let chapterDocList = [];
    let chapterStrList = bookStr
        .split("<address> </address>")
        .filter((item) => item.trim() !== "");
    let titleList = chapterStrList.map((item) => {
        return getHFromStr(item) || getTitleFromStr(item);
    });
    chapterDocList = chapterStrList.map((item, index) => {
        return {
            index: index,
            label: titleList[index],
            text: item,
            href: "title" + index,
        };
    });
    return chapterDocList;
};
const txtToHtml = (text, parserRegex) => {
    let html = "";
    let lines = text.split("\n");
    if (lines.length === 1) {
        lines = text.split("\r");
    }
    for (let item of lines) {
        if (cleanText(item) && isTitle(cleanText(item), parserRegex)) {
            html += `<h1>${cleanText(item)}</h1>`;
        }
        else {
            html += `<p>${item}</p>`;
        }
    }
    if (html) {
        return html;
    }
    else {
        return `<h1>Title</h1><p>${text}</p>`;
    }
};
const getHFromStr = (str) => {
    var _a;
    // Create temporary DOM element
    const tempDoc = new DOMParser().parseFromString(str, "text/html");
    // Find first heading tag
    const headingTag = tempDoc.querySelector("h1, h2, h3, h4, h5, h6");
    // Return content if found, otherwise empty string
    return headingTag ? ((_a = headingTag.textContent) === null || _a === void 0 ? void 0 : _a.trim()) || "" : "";
};
const getTitleFromStr = (str) => {
    var _a;
    // Create temporary DOM element
    const tempDoc = new DOMParser().parseFromString(str, "text/html");
    // Find first heading tag
    const headingTag = tempDoc.querySelector("title");
    // Return content if found, otherwise empty string
    return headingTag ? ((_a = headingTag.textContent) === null || _a === void 0 ? void 0 : _a.trim()) || "" : "";
};
const getTitlefromText = (bookDoc) => {
    let elements = bookDoc.getElementsByTagName("*");
    let titleElements = Array.from(elements).filter((item) => {
        return (item.childNodes.length === 1 &&
            item.childNodes[0].nodeType === Node.TEXT_NODE &&
            isTitle(cleanText(item.textContent)));
    });
    let h1TitleElements = [];
    for (let index = 0; index < titleElements.length; index++) {
        const oldElement = titleElements[index];
        const newElement = document.createElement("h1");
        newElement.innerHTML = oldElement.innerText;
        oldElement.parentNode.replaceChild(newElement, oldElement);
        h1TitleElements.push(newElement);
    }
    return h1TitleElements;
};

let lock = false;
const getBlockElement = (Element) => {
    return Array.from(Element.querySelectorAll("h1,h2,h3,h4,h5,h6,p,div,ul,dl,ol,pre,blockquote,address"));
};
const handleScrollPage = (element, animation, delta, doc, flipToNextPage, flipToPrevPage, isMobile) => __awaiter(void 0, void 0, void 0, function* () {
    let section = Math.floor(element.clientWidth / 12);
    let gap = section % 2 === 0 ? section : section - 1;
    const width = element.clientWidth;
    if (animation === "mimical" && isMobile !== "yes") {
        let bookDiv = document.getElementById("book");
        if (bookDiv) {
            bookDiv.style.display = "block";
            if (delta > 0) {
                flipToPrevPage();
            }
            else if (delta < 0) {
                flipToNextPage();
            }
            setTimeout(() => {
                if (!bookDiv)
                    return {};
                bookDiv.style.display = "none";
            }, 1000);
        }
    }
    if (delta > 0) {
        // previous page
        doc.body.scrollBy({
            top: 0,
            left: -width - gap,
            behavior: animation === "sliding" && isMobile !== "yes" ? "smooth" : "auto",
        });
        // trigger("page-changed");
    }
    else if (delta < 0) {
        // next page
        doc.body.scrollBy({
            top: 0,
            left: width + gap,
            behavior: animation === "sliding" && isMobile !== "yes" ? "smooth" : "auto",
        });
    }
});
const findValidChapter = (chapterDocIndex, chapterHref, chapterDocList, flag) => {
    let currentChapterIndex = _.findLastIndex(chapterDocList, (chapter) => {
        return (chapter.href === chapterHref ||
            (chapter.href &&
                chapter.href.includes("#") &&
                chapter.href.includes(chapterHref)));
    });
    if (chapterHref &&
        _.findLastIndex(chapterDocList, (chapter) => {
            return (chapter.href === chapterHref ||
                (chapter.href &&
                    chapter.href.includes("#") &&
                    chapter.href.includes(chapterHref)));
        }) > -1) ;
    else {
        currentChapterIndex = chapterDocIndex;
    }
    if (flag === "prev") {
        return Object.assign(Object.assign({}, chapterDocList[currentChapterIndex - 1]), { index: currentChapterIndex - 1 });
    }
    else {
        return Object.assign(Object.assign({}, chapterDocList[currentChapterIndex + 1]), { index: currentChapterIndex + 1 });
    }
};
const handlePrevChapter = (element, flattenChapters, chapterDocList, readerMode, format, tempLocation, doc, iframe) => __awaiter(void 0, void 0, void 0, function* () {
    let chapterDocIndex = parseInt(tempLocation.chapterDocIndex || "0");
    let chapterHref = tempLocation.chapterHref || "";
    if (chapterDocIndex === 0) {
        return;
    }
    let prevChapter = findValidChapter(chapterDocIndex, chapterHref, chapterDocList, "prev");
    if (!prevChapter)
        return;
    tempLocation.text = "prevChapter";
    tempLocation.page = "";
    yield handleRenderChapter(prevChapter.index, prevChapter.label, prevChapter.href, chapterDocList, element, readerMode, format, tempLocation, doc, iframe);
});
const handleRenderChapter = (chapterDocIndex, chapterTitle, chapterHref, chapterDocList, element, readerMode, format, tempLocation, doc, iframe) => __awaiter(void 0, void 0, void 0, function* () {
    doc.body.innerHTML = "";
    iframe.height = 0 + "px";
    doc.body.scrollTo(0, 0);
    if ((chapterTitle && !chapterDocIndex) ||
        (chapterDocList[chapterDocIndex] &&
            chapterDocList[chapterDocIndex].label &&
            chapterTitle &&
            chapterTitle !== chapterDocList[chapterDocIndex].label &&
            chapterHref.indexOf("#") === -1)) {
        let tempChapterDocIndex = _.findLastIndex(chapterDocList, {
            label: chapterTitle,
        });
        if (tempChapterDocIndex !== -1) {
            chapterDocIndex = tempChapterDocIndex;
        }
    }
    if (chapterDocIndex === -1 && chapterHref.indexOf("#") > -1) {
        let href = chapterHref.split("#")[0];
        let tempChapterDocIndex = _.findLastIndex(chapterDocList, (chapter) => {
            return (chapter.href === href ||
                (chapter.href &&
                    chapter.href.includes("#") &&
                    chapter.href.includes(href)));
        });
        if (tempChapterDocIndex !== -1) {
            chapterDocIndex = tempChapterDocIndex;
        }
    }
    if (chapterDocIndex === -1 || chapterDocIndex > chapterDocList.length - 1) {
        chapterDocIndex = 0;
    }
    doc.body.innerHTML = yield handleOneChapterDoc(chapterDocList[chapterDocIndex].text, false);
    yield handleCssLink(doc);
    tempLocation.chapterTitle = chapterTitle;
    tempLocation.chapterHref = chapterHref;
    tempLocation.chapterDocIndex = chapterDocIndex + "";
    tempLocation.percentage = chapterDocIndex / chapterDocList.length + "";
    tempLocation.text = "";
    yield handleIframeHeight(element, readerMode, format, iframe, doc);
    yield handleScrollPosition(element, readerMode, "", "", "", "", doc);
});
const handleCssLink = (doc) => __awaiter(void 0, void 0, void 0, function* () {
    let linkList = Array.from(doc.getElementsByTagName("link"));
    if (linkList.length === 0) {
        return;
    }
    for (let index = 0; index < linkList.length; index++) {
        const link = linkList[index];
        link.onload = () => {
            console.info("finished");
        };
    }
    let styleSheetPromises = [];
    for (let index = 0; index < linkList.length; index++) {
        const link = linkList[index];
        if (!link.href.endsWith("null")) {
            styleSheetPromises.push(new Promise((resolve, reject) => {
                link.addEventListener("load", resolve);
            }));
        }
    }
    try {
        yield Promise.race([
            Promise.all(styleSheetPromises),
            new Promise((resolve, reject) => {
                setTimeout(() => {
                    console.info("css load timeout");
                    // reject(new Error("Timeout"));
                    resolve("css load timeout");
                }, 1000);
            }),
        ]);
    }
    catch (err) {
        console.error(err);
    }
});
const handleScrollPosition = (element, readerMode, text, count, href, page, doc) => __awaiter(void 0, void 0, void 0, function* () {
    let left = 0;
    let targetNode = doc.body;
    if (page && readerMode !== "scroll") {
        let section = Math.floor(element.clientWidth / 12);
        let gap = section % 2 === 0 ? section : section - 1;
        const width = convertComputedNum(getComputedStyle(element).width);
        let pageWidth = width + gap;
        left = pageWidth * (parseInt(page) - 1);
    }
    else if (text) {
        let nodeList = getBlockElement(doc.body);
        let targetNodeList = nodeList.filter((s, index) => {
            return (cleanText(s.textContent) &&
                (cleanText(s.textContent) === cleanText(text) ||
                    cleanText(s.textContent) ===
                        Chinese.t2s(cleanText(text)) ||
                    cleanText(s.textContent) ===
                        Chinese.s2t(cleanText(text))) &&
                (Math.abs(index - parseInt(count)) < 2 ||
                    count === "search" ||
                    count === "ignore" ||
                    count === "next"));
        });
        if (targetNodeList.length === 0) {
            console.info("failed");
            return;
        }
        targetNode = getCloestBlock(targetNodeList[0], element, readerMode);
        left = targetNode
            ? convertStyleNum(targetNode.offsetLeft) -
                convertStyleNum(targetNode.marginLeft ||
                    parseFloat(getComputedStyle(targetNode).marginLeft))
            : text === "prevChapter"
                ? doc.body.scrollWidth
                : 0;
    }
    else if (href && href.indexOf("#") > -1) {
        let id = CSS.escape(href.split("#").reverse()[0]);
        if (!doc.body.querySelector("#" + id)) {
            return;
        }
        targetNode = getCloestBlock(doc.body.querySelector("#" + id) || doc.body, element, readerMode);
        left = targetNode
            ? convertStyleNum(targetNode.offsetLeft) -
                convertStyleNum(targetNode.marginLeft ||
                    parseFloat(getComputedStyle(targetNode).marginLeft))
            : 0;
    }
    if (readerMode !== "scroll") {
        doc.body.scrollTo(left, 0);
    }
    else {
        targetNode.scrollIntoView();
    }
});
const getCloestBlock = (targetNode, element, readerMode) => {
    let section = Math.floor(element.clientWidth / 12);
    let gap = section % 2 === 0 ? section : section - 1;
    let offsetLeft = convertStyleNum(targetNode.offsetLeft) -
        convertStyleNum(targetNode.marginLeft ||
            parseFloat(getComputedStyle(targetNode).marginLeft));
    if (readerMode === "scroll") {
        return targetNode;
    }
    else if (readerMode !== "scroll" &&
        checkDivisibleInRange(parseInt(offsetLeft + ""), (element.clientWidth + gap) / 2)) {
        return targetNode;
    }
    else if (targetNode.parentElement) {
        return getCloestBlock(targetNode.parentElement, element, readerMode);
    }
    else {
        return targetNode;
    }
};
const checkDivisibleInRange = (x, y) => {
    for (let i = x - 10; i <= x + 10; i++) {
        if (i % y === 0) {
            return true;
        }
    }
    return false;
};
const handleRecord = (element, readerMode, flattenChapters, chapterDocList, tempLocation, doc, targetNode) => __awaiter(void 0, void 0, void 0, function* () {
    var _a;
    if (lock)
        return;
    let nodeList = getBlockElement(doc.body);
    let visibleNode = nodeList.filter((s) => isScrolledIntoView(element, s, readerMode) &&
        (s.textContent || "").trim());
    let firstVisibleNode = visibleNode[0];
    if (targetNode) {
        firstVisibleNode = targetNode;
    }
    let count = 0;
    for (let i = 0; i < nodeList.length; i++) {
        if (isScrolledIntoView(element, nodeList[i], readerMode) &&
            firstVisibleNode &&
            nodeList[i].innerHTML === firstVisibleNode.innerHTML) {
            count = i;
            break;
        }
    }
    handleHashChapter(visibleNode, flattenChapters, tempLocation);
    if (firstVisibleNode &&
        !isCurrentNodeFarFromParrent(firstVisibleNode, element, readerMode)) {
        tempLocation.text = firstVisibleNode.textContent || "";
        tempLocation.count = count + "";
        tempLocation.page = "";
        tempLocation.percentage =
            parseInt(tempLocation.chapterDocIndex) / chapterDocList.length +
                (1 / chapterDocList.length) * (count / nodeList.length) +
                "";
    }
    else {
        tempLocation.page = ((_a = (yield progressInfo(readerMode, doc))) === null || _a === void 0 ? void 0 : _a.currentPage) + "";
    }
    lock = true;
    setTimeout(() => {
        lock = false;
    }, 100);
});
const isCurrentNodeFarFromParrent = (targetNode, element, readerMode) => {
    let section = Math.floor(element.clientWidth / 12);
    let gap = section % 2 === 0 ? section : section - 1;
    if (Math.abs(targetNode.offsetLeft -
        getCloestBlock(targetNode, element, readerMode).offsetLeft) >
        (element.clientWidth + gap) / 2) {
        return true;
    }
    else {
        return false;
    }
};
const handleHashChapter = (visibleNode, flattenChapters, tempLocation) => {
    let chapterHref = tempLocation.chapterHref || "";
    let lastIndexOfHash = chapterHref.lastIndexOf("#");
    let beforeHash = "";
    if (lastIndexOfHash === -1) {
        beforeHash = chapterHref;
    }
    else {
        beforeHash = chapterHref.substring(0, lastIndexOfHash);
    }
    for (let index = 0; index < visibleNode.length; index++) {
        const element = visibleNode[index];
        if (element.id) {
            let newHref = beforeHash + "#" + element.id;
            let newIndex = _.findLastIndex(flattenChapters, {
                href: newHref,
            });
            if (newIndex > -1) {
                tempLocation.chapterHref = newHref;
                tempLocation.chapterTitle = flattenChapters[newIndex].label;
            }
        }
    }
};
const handleNextChapter = (element, flattenChapters, chapterDocList, readerMode, format, tempLocation, doc, iframe) => __awaiter(void 0, void 0, void 0, function* () {
    let chapterDocIndex = parseInt(tempLocation.chapterDocIndex || "0");
    let chapterHref = tempLocation.chapterHref || "";
    if (chapterDocIndex >= chapterDocList.length - 1) {
        tempLocation.percentage = "1";
        return;
    }
    let nextChapter = findValidChapter(chapterDocIndex, chapterHref, chapterDocList, "next");
    if (!nextChapter)
        return;
    tempLocation.page = "";
    yield handleRenderChapter(nextChapter.index, nextChapter.label, nextChapter.href, chapterDocList, element, readerMode, format, tempLocation, doc, iframe);
});
const getAudioText = (element, readerMode, doc) => {
    let nodeList = getBlockElement(doc.body).filter((item) => !isParentBlock(item));
    let audioNode = nodeList.filter((s) => (s.textContent || "").trim());
    let audioText = audioNode
        .filter((item) => item.textContent !== "img")
        .map((item) => item.textContent);
    let firstSliceIndex = 0;
    let visibleText = getVisibleText(element, readerMode, doc);
    if (visibleText && visibleText.length > 0) {
        let firstVisibleText = visibleText[0];
        firstSliceIndex = audioText.indexOf(firstVisibleText);
    }
    return audioText.slice(firstSliceIndex);
};
const getVisibleText = (element, readerMode, doc) => {
    let nodeList = getBlockElement(doc.body).filter((item) => !isParentBlock(item));
    let visibleNode = nodeList.filter((s) => isScrolledIntoView(element, s, readerMode) &&
        (s.textContent || "").trim());
    return visibleNode
        .filter((item) => item.textContent !== "img")
        .map((item) => item.textContent);
};
const handleHighlightNode = (text, style, doc) => {
    let nodeList = getBlockElement(doc.body);
    let nodes = nodeList.filter((s) => {
        if (s.getAttribute("style") === style) {
            s.setAttribute("style", "");
        }
        return ((s.textContent || "").trim() &&
            s.textContent === text);
    });
    if (nodes.length > 0) {
        nodes[0].setAttribute("style", style);
    }
};
const getSearchResult = (keyword, chapterDocList) => __awaiter(void 0, void 0, void 0, function* () {
    var _c;
    let searchResult = [];
    for (let i = 0; i < chapterDocList.length; i++) {
        let chapterDoc = new DOMParser().parseFromString(yield handleOneChapterDoc(chapterDocList[i].text, true), "text/html");
        let nodeList = getBlockElement(chapterDoc.body).filter((item) => !isParentBlock(item));
        for (let j = 0; j < nodeList.length; j++) {
            let keyWordIndex = (nodeList[j].textContent || "").indexOf(keyword);
            if (keyWordIndex > -1) {
                searchResult.push({
                    excerpt: ((_c = nodeList[j].textContent) === null || _c === void 0 ? void 0 : _c.substring(keyWordIndex - 100, keyWordIndex + 100)) || "",
                    cfi: JSON.stringify({
                        text: nodeList[j].textContent,
                        chapterTitle: chapterDocList[i].label,
                        chapterDocIndex: i,
                        chapterHref: chapterDocList[i].href,
                        count: "search",
                        percentage: i / chapterDocList.length,
                    }),
                });
            }
        }
    }
    return _.uniq(searchResult, "excerpt");
});
const isParentBlock = (myDiv) => {
    var children = myDiv.children;
    let flag = false;
    var blockRegex = /^(address|section|blockquote|body|center|dir|div|dl|fieldset|form|h[1-6]|hr|isindex|menu|noframes|noscript|ol|p|pre|table|ul|dd|dt|frameset|li|tbody|td|tfoot|th|thead|tr|html)$/i;
    let blockElementList = Array.from(children).filter((item) => blockRegex.test(item.nodeName));
    // some elements might contain image and image subtitle
    if (blockElementList.length < 3) {
        return false;
    }
    for (var i = 0; i < children.length; i++) {
        if (blockRegex.test(children[i].nodeName)) {
            flag = true;
            break;
        }
    }
    return flag;
};
const isScrolledIntoView = (element, el, readerMode) => {
    var isVisible = false;
    var rect = el.getBoundingClientRect();
    if (readerMode !== "scroll" && el.textContent && el.textContent.trim()) {
        let elemLeft = rect.left;
        isVisible = elemLeft > -10 && elemLeft <= element.clientWidth;
    }
    else if (readerMode === "scroll" &&
        el.textContent &&
        el.textContent.trim()) {
        let elemTop = rect.top;
        isVisible =
            elemTop >= element.scrollTop &&
                elemTop <= element.scrollTop + element.clientHeight;
    }
    else if (readerMode !== "scroll") {
        let elemLeft = rect.left;
        isVisible = elemLeft >= 0 && elemLeft <= element.clientWidth;
    }
    return isVisible;
};
const addAndroidTouchEvent = (doc, iframe, element, readerMode, animation, render) => {
    var _a;
    let iWin = iframe.contentWindow || ((_a = iframe.contentDocument) === null || _a === void 0 ? void 0 : _a.defaultView);
    let touchStartTime = 0;
    let touchStartX = 0;
    let touchStartY = 0;
    let lastTouchEnd = 0;
    const swipeThreshold = 30; // Minimum distance in pixels to be considered a swipe
    const timeThreshold = 500; // Maximum time in milliseconds to be considered a tap
    let section = Math.floor(element.clientWidth / 12);
    let gap = section % 2 === 0 ? section : section - 1;
    let onTouchEnd = function (event) {
        console.info("touchend");
        let now = new Date().getTime();
        if (now - lastTouchEnd <= 300) {
            event.preventDefault();
            return;
        }
        lastTouchEnd = now;
        const touch = event.changedTouches[0];
        const touchEndTime = Date.now();
        const touchEndX = touch.screenX;
        const touchEndY = touch.screenY;
        const timeDiff = touchEndTime - touchStartTime;
        const distX = touchEndX - touchStartX;
        const distY = touchEndY - touchStartY;
        if (isDragging && animation === "mimical") {
            isDragging = false;
            render.mouseUpHandler(event);
            if (touch.screenX < window.screen.width / 2) {
                render.next();
            }
            else {
                render.prev();
            }
            setTimeout(() => {
                let bookDiv = document.getElementById("book");
                if (bookDiv) {
                    bookDiv.style.display = "none";
                }
            }, 400);
            return;
        }
        // Replace the scrollTo implementation with this optimized version
        if (isDragging && animation === "sliding") {
            // Clean up any existing animation
            if (window.scrollAnimationId) {
                cancelAnimationFrame(window.scrollAnimationId);
            }
            doc.body.style.transform = "";
            let pageWidth = element.clientWidth + gap;
            let scrollLeft = doc.body.scrollLeft;
            // Improved snapping logic
            let snapX;
            const currentPage = Math.round(scrollLeft / pageWidth);
            const dragPercentage = Math.abs(distX) / window.screen.width;
            const dragThreshold = 0.1; // Only 10% drag needed to change page
            if (distX > 0 && dragPercentage > dragThreshold) {
                // Dragged right (go to previous page)
                snapX = (currentPage - 1) * pageWidth;
            }
            else if (distX < 0 && dragPercentage > dragThreshold) {
                // Dragged left (go to next page)
                snapX = (currentPage + 1) * pageWidth;
            }
            else {
                // Stay on current page
                snapX = currentPage * pageWidth;
            }
            // Ensure we don't go out of bounds
            snapX = Math.max(0, Math.min(snapX, doc.body.scrollWidth - pageWidth));
            if (doc.body.scrollWidth - snapX < pageWidth + gap) {
                snapX = doc.body.scrollWidth;
            }
            // Use custom smooth scrolling with requestAnimationFrame instead of browser's scrollTo
            const startTime = performance.now();
            const startLeft = doc.body.scrollLeft;
            const distance = snapX - startLeft;
            const duration = 300; // milliseconds
            // Apply hardware acceleration before animation starts
            doc.body.style.willChange = "scroll-position";
            // Custom easing function for natural movement
            const easeOutCubic = (t) => 1 - Math.pow(1 - t, 3);
            function animateScroll(currentTime) {
                const elapsedTime = currentTime - startTime;
                if (elapsedTime >= duration) {
                    // Animation complete - set final position
                    doc.body.scrollLeft = snapX;
                    // Clean up acceleration hints
                    doc.body.style.willChange = "auto";
                    render.record();
                    isDragging = false;
                    return;
                }
                // Calculate new position using easing
                const progress = easeOutCubic(elapsedTime / duration);
                const newLeft = startLeft + distance * progress;
                // Update scroll position
                doc.body.scrollLeft = newLeft;
                // Continue animation
                window.scrollAnimationId = requestAnimationFrame(animateScroll);
            }
            // Start animation
            window.scrollAnimationId = requestAnimationFrame(animateScroll);
            return;
        }
        var selectedText = iWin.getSelection().toString();
        if (selectedText) {
            window.ReactNativeWebView.postMessage(JSON.stringify({
                event: "select-text-after-touch",
                selectedText: selectedText,
            }));
            return;
        }
        if (timeDiff < timeThreshold &&
            Math.abs(distX) < swipeThreshold &&
            Math.abs(distY) < swipeThreshold) {
            var width = window.screen.width;
            var height = window.screen.height;
            var cellWidth = width / 3;
            var cellHeight = height / 3;
            var col = Math.floor(touchEndX / cellWidth);
            var row = Math.floor(touchEndY / cellHeight);
            var result = "";
            if ((row === 0 && (col === 0 || col === 1)) || // Top-left and Top-middle
                (row === 1 && col === 0) || // Middle-left
                (row === 2 && col === 0) || // Bottom-left
                (row === 0 && col === 1) // Middle-top
            ) {
                result = "left";
            }
            else if (row === 1 && col === 1) {
                result = "center";
            }
            else if ((row === 0 && col === 2) || // Top-right
                (row === 1 && col === 2) || // Middle-right
                (row === 2 && col === 2) || // Bottom-right
                (row === 2 && col === 1) // Middle-bottom
            ) {
                result = "right";
            }
            // if (
            //   col === 0 // Left column (left third of screen)
            // ) {
            //   result = "left";
            // } else if (col === 1) {
            //   // Middle column (middle third of screen)
            //   result = "center";
            // } else if (col === 2) {
            //   // Right column (right third of screen)
            //   result = "right";
            // }
            window.ReactNativeWebView.postMessage(JSON.stringify({ event: result }));
        }
        else if (Math.abs(distX) >= swipeThreshold ||
            Math.abs(distY) >= swipeThreshold) {
            console.info("Swipe detected");
            window.ReactNativeWebView.postMessage(JSON.stringify({ event: "swipe" }));
            if (readerMode === "scroll" &&
                Math.abs(element.scrollHeight - element.scrollTop - element.clientHeight) < 10) {
                window.ReactNativeWebView.postMessage(JSON.stringify({ event: "scroll-bottom" }));
            }
            if (readerMode === "scroll" && element.scrollTop === 0) {
                window.ReactNativeWebView.postMessage(JSON.stringify({ event: "scroll-top" }));
            }
        }
    };
    let onTouchStart = function (event) {
        const target = event.target;
        if (!target)
            return;
        if (target.tagName === "IMG") {
            const imgSrc = target.src || target.getAttribute("xlink:href");
            window.ReactNativeWebView.postMessage(JSON.stringify({ event: "view-image", imgSrc: imgSrc }));
        }
        if (event.touches.length > 1) {
            event.preventDefault();
        }
        const touch = event.touches[0];
        touchStartTime = Date.now();
        touchStartX = touch.screenX; // Changed from screenX to clientX
        touchStartY = touch.screenY; // Changed from screenY to clientY
    };
    let isDragging = false;
    let lastTouchX = 0;
    let onTouchMove = function (event) {
        // Skip handling if not dragging yet and still determining direction
        if (!isDragging && Math.abs(event.touches[0].screenX - touchStartX) <= 10) {
            return;
        }
        // Prevent default to stop browser scroll behavior
        event.preventDefault();
        const touch = event.touches[0];
        const touchCurrentX = touch.screenX;
        const touchCurrentY = touch.screenY;
        // Calculate distance moved
        const distX = touchCurrentX - touchStartX;
        const distY = touchCurrentY - touchStartY;
        // Only start dragging if horizontal movement is greater than vertical
        if (!isDragging &&
            Math.abs(distX) > Math.abs(distY) &&
            Math.abs(distX) > 10) {
            isDragging = true;
            lastTouchX = touchCurrentX;
            // Apply hardware acceleration to the body
            doc.body.style.transform = "translateZ(0)";
            if (animation === "mimical") {
                window.ReactNativeWebView.postMessage(JSON.stringify({ event: "swipe-start" }));
                let bookDiv = document.getElementById("book");
                if (bookDiv) {
                    bookDiv.style.display = "block";
                    render.mouseDownHandler(event);
                }
            }
            return;
        }
        if (isDragging && animation === "mimical") {
            render.mouseMoveHandler(event);
        }
        // If we're in dragging mode, apply direct transform for better performance
        if (isDragging && animation === "sliding") {
            // Calculate the delta since last move event
            const deltaX = touchCurrentX - lastTouchX;
            if (Math.abs(doc.body.scrollWidth - doc.body.scrollLeft - element.clientWidth) < 10 &&
                deltaX < 0) {
                if (selectionTimeout) {
                    clearTimeout(selectionTimeout);
                }
                selectionTimeout = setTimeout(() => {
                    render.next();
                }, 300); // Debounce selection events
                return;
            }
            if (doc.body.scrollLeft === 0 && deltaX > 0) {
                if (selectionTimeout) {
                    clearTimeout(selectionTimeout);
                }
                selectionTimeout = setTimeout(() => {
                    render.prev();
                }, 300); // Debounce selection events
                return;
            }
            // Use transform instead of scrollBy for smoother rendering
            const currentScrollLeft = doc.body.scrollLeft;
            doc.body.scrollLeft = currentScrollLeft - deltaX;
            // Update last position
            lastTouchX = touchCurrentX;
            // Request animation frame for smoother updates (optional)
            requestAnimationFrame(() => {
                // Additional visual feedback can be added here
            });
        }
    };
    doc.body.ontouchend = onTouchEnd;
    doc.body.ontouchstart = onTouchStart;
    doc.body.ontouchmove = onTouchMove;
    iWin.ontouchend = onTouchEnd;
    iWin.ontouchstart = onTouchStart;
    iWin.ontouchmove = onTouchMove;
    let selectionTimeout = null;
    doc.body.oncontextmenu = function (event) {
        event.preventDefault();
        event.stopPropagation();
        return false;
    };
    let scrollLeft = 0;
    doc.addEventListener("selectstart", (event) => {
        if (readerMode === "scroll")
            return;
        scrollLeft = doc.body.scrollLeft;
        //prevent doc.body from scrolling
    }, false);
    doc.addEventListener("selectionchange", (event) => {
        if (scrollLeft > 0) {
            doc.body.scrollLeft = scrollLeft;
        }
        if (selectionTimeout) {
            clearTimeout(selectionTimeout);
        }
        selectionTimeout = setTimeout(() => __awaiter(void 0, void 0, void 0, function* () {
            const selectedText = iWin.getSelection().toString().trim();
            if (selectedText) {
                var range = iWin.getSelection().getRangeAt(0);
                var rect = range.getBoundingClientRect();
                var position = {
                    top: rect.top - element.scrollTop,
                    left: rect.left,
                    width: rect.width,
                    height: rect.height,
                    screenWidth: window.innerWidth,
                    screenHeight: window.innerHeight,
                };
                rangy.init();
                let charRange = yield render.getHightlightCoords();
                window.ReactNativeWebView.postMessage(JSON.stringify({
                    event: "select-text",
                    selectedText: selectedText,
                    position: position,
                    range: charRange,
                }));
            }
        }), 500); // Debounce selection events
    }, false);
};
const addAppleTouchEvent = (doc, iframe, element, readerMode, animation, render) => {
    var _a;
    let iWin = iframe.contentWindow || ((_a = iframe.contentDocument) === null || _a === void 0 ? void 0 : _a.defaultView);
    let touchStartTime = 0;
    let touchStartX = 0;
    let touchStartY = 0;
    let lastTouchEnd = 0;
    const swipeThreshold = 30; // Minimum distance in pixels to be considered a swipe
    const timeThreshold = 500; // Maximum time in milliseconds to be considered a tap
    let section = Math.floor(element.clientWidth / 12);
    let gap = section % 2 === 0 ? section : section - 1;
    let onTouchEnd = function (event) {
        return __awaiter(this, void 0, void 0, function* () {
            let now = new Date().getTime();
            if (now - lastTouchEnd <= 300) {
                event.preventDefault();
                return;
            }
            lastTouchEnd = now;
            const touch = event.changedTouches[0];
            const touchEndTime = Date.now();
            const touchEndX = touch.clientX;
            const touchEndY = touch.clientY;
            const timeDiff = touchEndTime - touchStartTime;
            const distX = touchEndX - touchStartX;
            const distY = touchEndY - touchStartY;
            if (isDragging && animation === "mimical") {
                isDragging = false;
                render.mouseUpHandler(event);
                if (touch.screenX < window.screen.width / 2) {
                    render.next();
                }
                else {
                    render.prev();
                }
                setTimeout(() => {
                    let bookDiv = document.getElementById("book");
                    if (bookDiv) {
                        bookDiv.style.display = "none";
                    }
                }, 400);
                return;
            }
            // Replace the scrollTo implementation with this optimized version
            if (isDragging && animation === "sliding") {
                // Clean up any existing animation
                if (window.scrollAnimationId) {
                    cancelAnimationFrame(window.scrollAnimationId);
                }
                doc.body.style.transform = "";
                let pageWidth = element.clientWidth + gap;
                let scrollLeft = doc.body.scrollLeft;
                // Improved snapping logic
                let snapX;
                const currentPage = Math.round(scrollLeft / pageWidth);
                const dragPercentage = Math.abs(distX) / window.screen.width;
                const dragThreshold = 0.1; // Only 10% drag needed to change page
                if (distX > 0 && dragPercentage > dragThreshold) {
                    // Dragged right (go to previous page)
                    snapX = (currentPage - 1) * pageWidth;
                }
                else if (distX < 0 && dragPercentage > dragThreshold) {
                    // Dragged left (go to next page)
                    snapX = (currentPage + 1) * pageWidth;
                }
                else {
                    // Stay on current page
                    snapX = currentPage * pageWidth;
                }
                // Ensure we don't go out of bounds
                snapX = Math.max(0, Math.min(snapX, doc.body.scrollWidth - pageWidth));
                if (doc.body.scrollWidth - snapX < pageWidth + gap) {
                    snapX = doc.body.scrollWidth;
                }
                // Use custom smooth scrolling with requestAnimationFrame instead of browser's scrollTo
                const startTime = performance.now();
                const startLeft = doc.body.scrollLeft;
                const distance = snapX - startLeft;
                const duration = 300; // milliseconds
                // Apply hardware acceleration before animation starts
                doc.body.style.willChange = "scroll-position";
                // Custom easing function for natural movement
                const easeOutCubic = (t) => 1 - Math.pow(1 - t, 3);
                function animateScroll(currentTime) {
                    const elapsedTime = currentTime - startTime;
                    if (elapsedTime >= duration) {
                        // Animation complete - set final position
                        doc.body.scrollLeft = snapX;
                        // Clean up acceleration hints
                        doc.body.style.willChange = "auto";
                        render.record();
                        isDragging = false;
                        return;
                    }
                    // Calculate new position using easing
                    const progress = easeOutCubic(elapsedTime / duration);
                    const newLeft = startLeft + distance * progress;
                    // Update scroll position
                    doc.body.scrollLeft = newLeft;
                    // Continue animation
                    window.scrollAnimationId = requestAnimationFrame(animateScroll);
                }
                // Start animation
                window.scrollAnimationId = requestAnimationFrame(animateScroll);
                return;
            }
            const selectedText = iWin.getSelection().toString().trim();
            if (selectedText) {
                var range = iWin.getSelection().getRangeAt(0);
                var rect = range.getBoundingClientRect();
                var position = {
                    top: rect.top - element.scrollTop,
                    left: rect.left,
                    width: rect.width,
                    height: rect.height,
                    screenWidth: window.innerWidth,
                    screenHeight: window.innerHeight,
                };
                rangy.init();
                let charRange = yield render.getHightlightCoords();
                window.ReactNativeWebView.postMessage(JSON.stringify({
                    event: "select-text",
                    selectedText: selectedText,
                    position: position,
                    range: charRange,
                }));
                return;
            }
            if (timeDiff < timeThreshold &&
                Math.abs(distX) < swipeThreshold &&
                Math.abs(distY) < swipeThreshold) {
                const width = document.documentElement.clientWidth;
                document.documentElement.clientHeight;
                const normalizedX = Math.min(Math.max(touchEndX, 0), width);
                let result = "";
                // For pagination mode: keep original 3x3 grid
                const cellWidth = width / 3;
                const col = Math.min(Math.floor(normalizedX / cellWidth), 2);
                if (col === 0 // Left column (left third of screen)
                ) {
                    result = "left";
                }
                else if (col === 1) {
                    // Middle column (middle third of screen)
                    result = "center";
                }
                else if (col === 2) {
                    // Right column (right third of screen)
                    result = "right";
                }
                window.ReactNativeWebView.postMessage(JSON.stringify({ event: result }));
            }
            else if (Math.abs(distX) >= swipeThreshold ||
                Math.abs(distY) >= swipeThreshold) {
                window.ReactNativeWebView.postMessage(JSON.stringify({ event: "swipe" }));
                if (readerMode === "scroll" &&
                    Math.abs(element.scrollHeight - element.scrollTop - element.clientHeight) < 10) {
                    window.ReactNativeWebView.postMessage(JSON.stringify({ event: "scroll-bottom" }));
                }
                if (readerMode === "scroll" && element.scrollTop === 0) {
                    window.ReactNativeWebView.postMessage(JSON.stringify({ event: "scroll-top" }));
                }
            }
        });
    };
    let onTouchStart = function (event) {
        const target = event.target;
        if (!target)
            return;
        if (target.tagName === "IMG") {
            const imgSrc = target.src || target.getAttribute("xlink:href");
            window.ReactNativeWebView.postMessage(JSON.stringify({ event: "view-image", imgSrc: imgSrc }));
        }
        if (event.touches.length > 1) {
            event.preventDefault();
        }
        const touch = event.touches[0];
        touchStartTime = Date.now();
        touchStartX = touch.clientX; // Changed from screenX to clientX
        touchStartY = touch.clientY; // Changed from screenY to clientY
    };
    let isDragging = false;
    let lastTouchX = 0;
    let onTouchMove = function (event) {
        const selectedText = iWin.getSelection().toString().trim();
        // Skip handling if not dragging yet and still determining direction
        if ((!isDragging && Math.abs(event.touches[0].screenX - touchStartX) <= 10) ||
            selectedText) {
            return;
        }
        // Prevent default to stop browser scroll behavior
        event.preventDefault();
        const touch = event.touches[0];
        const touchCurrentX = touch.screenX;
        const touchCurrentY = touch.screenY;
        // Calculate distance moved
        const distX = touchCurrentX - touchStartX;
        const distY = touchCurrentY - touchStartY;
        // Only start dragging if horizontal movement is greater than vertical
        if (!isDragging &&
            Math.abs(distX) > Math.abs(distY) &&
            Math.abs(distX) > 10) {
            isDragging = true;
            lastTouchX = touchCurrentX;
            // Apply hardware acceleration to the body
            doc.body.style.transform = "translateZ(0)";
            if (animation === "mimical") {
                window.ReactNativeWebView.postMessage(JSON.stringify({ event: "swipe-start" }));
                let bookDiv = document.getElementById("book");
                if (bookDiv) {
                    bookDiv.style.display = "block";
                    render.mouseDownHandler(event);
                }
            }
            return;
        }
        if (isDragging && animation === "mimical") {
            render.mouseMoveHandler(event);
        }
        // If we're in dragging mode, apply direct transform for better performance
        if (isDragging && animation === "sliding") {
            // Calculate the delta since last move event
            const deltaX = touchCurrentX - lastTouchX;
            if (Math.abs(doc.body.scrollWidth - doc.body.scrollLeft - element.clientWidth) < 10 &&
                deltaX < 0) {
                if (selectionTimeout) {
                    clearTimeout(selectionTimeout);
                }
                selectionTimeout = setTimeout(() => {
                    render.next();
                }, 300); // Debounce selection events
                return;
            }
            if (doc.body.scrollLeft === 0 && deltaX > 0) {
                if (selectionTimeout) {
                    clearTimeout(selectionTimeout);
                }
                selectionTimeout = setTimeout(() => {
                    render.prev();
                }, 300); // Debounce selection events
                return;
            }
            // Use transform instead of scrollBy for smoother rendering
            const currentScrollLeft = doc.body.scrollLeft;
            doc.body.scrollLeft = currentScrollLeft - deltaX;
            // Update last position
            lastTouchX = touchCurrentX;
            // Request animation frame for smoother updates (optional)
            requestAnimationFrame(() => {
                // Additional visual feedback can be added here
            });
        }
    };
    doc.body.ontouchend = onTouchEnd;
    doc.body.ontouchstart = onTouchStart;
    doc.body.ontouchmove = onTouchMove;
    iWin.ontouchend = onTouchEnd;
    iWin.ontouchstart = onTouchStart;
    iWin.ontouchmove = onTouchMove;
    let selectionTimeout = null;
    doc.addEventListener("touchmove", (event) => { }, false);
    doc.body.oncontextmenu = function (event) {
        event.preventDefault();
        event.stopPropagation();
        return false;
    };
};

class EventEmitter {
    constructor() {
        this.callbacks = {};
        this.callbacks.base = {};
    }
    /**
     * On
     */
    on(_names, callback) {
        const that = this;
        // Errors
        if (typeof _names === "undefined" || _names === "") {
            console.warn("wrong names");
            return false;
        }
        if (typeof callback === "undefined") {
            console.warn("wrong callback");
            return false;
        }
        // Resolve names
        const names = this.resolveNames(_names);
        // Each name
        names.forEach(function (_name) {
            // Resolve name
            const name = that.resolveName(_name);
            // Create namespace if not exist
            if (!(that.callbacks[name.namespace] instanceof Object))
                that.callbacks[name.namespace] = {};
            // Create callback if not exist
            if (!(that.callbacks[name.namespace][name.value] instanceof Array))
                that.callbacks[name.namespace][name.value] = [];
            // Add callback
            that.callbacks[name.namespace][name.value].push(callback);
        });
        return this;
    }
    /**
     * Off
     */
    off(_names) {
        const that = this;
        // Errors
        if (typeof _names === "undefined" || _names === "") {
            console.warn("wrong name");
            return false;
        }
        // Resolve names
        const names = this.resolveNames(_names);
        // Each name
        names.forEach(function (_name) {
            // Resolve name
            const name = that.resolveName(_name);
            // Remove namespace
            if (name.namespace !== "base" && name.value === "") {
                delete that.callbacks[name.namespace];
            }
            // Remove specific callback in namespace
            else {
                // Default
                if (name.namespace === "base") {
                    // Try to remove from each namespace
                    for (const namespace in that.callbacks) {
                        if (that.callbacks[namespace] instanceof Object &&
                            that.callbacks[namespace][name.value] instanceof Array) {
                            delete that.callbacks[namespace][name.value];
                            // Remove namespace if empty
                            if (Object.keys(that.callbacks[namespace]).length === 0)
                                delete that.callbacks[namespace];
                        }
                    }
                }
                // Specified namespace
                else if (that.callbacks[name.namespace] instanceof Object &&
                    that.callbacks[name.namespace][name.value] instanceof Array) {
                    delete that.callbacks[name.namespace][name.value];
                    // Remove namespace if empty
                    if (Object.keys(that.callbacks[name.namespace]).length === 0)
                        delete that.callbacks[name.namespace];
                }
            }
        });
        return this;
    }
    /**
     * Trigger
     */
    trigger(_name, _args = []) {
        // Errors
        if (typeof _name === "undefined" || _name === "") {
            console.warn("wrong name");
            return false;
        }
        const that = this;
        let finalResult = null;
        // Default args
        const args = !(_args instanceof Array) ? [] : _args;
        // Resolve names (should on have one event)
        let name = this.resolveNames(_name);
        // Resolve name
        name = this.resolveName(name[0]);
        setTimeout(() => {
            if (name.namespace === "base") {
                // Try to find callback in each namespace
                for (const namespace in that.callbacks) {
                    if (that.callbacks[namespace] instanceof Object &&
                        that.callbacks[namespace][name.value] instanceof Array &&
                        that.callbacks[namespace][name.value]) {
                        that.callbacks[namespace][name.value].forEach(function (callback) {
                            callback.apply(that, args);
                        });
                    }
                    else if (this.callbacks[name.namespace] instanceof Object &&
                        that.callbacks[name.namespace][name.value]) {
                        if (name.value === "") {
                            console.warn("wrong name");
                            return this;
                        }
                        that.callbacks[name.namespace][name.value].forEach(function (callback) {
                            callback.apply(that, args);
                        });
                    }
                    return finalResult;
                }
            }
        }, 100);
        // Default namespace
        // Specified namespace
    }
    /**
     * Resolve names
     */
    resolveNames(_names) {
        let names = _names;
        names = names.replace(/[^a-zA-Z0-9 ,/.]/g, "");
        names = names.replace(/[,/]+/g, " ");
        names = names.split(" ");
        return names;
    }
    /**
     * Resolve name
     */
    resolveName(name) {
        const newName = {};
        const parts = name.split(".");
        newName.original = name;
        newName.value = parts[0];
        newName.namespace = "base"; // Base namespace
        // Specified namespace
        if (parts.length > 1 && parts[1] !== "") {
            newName.namespace = parts[1];
        }
        return newName;
    }
}

/**
 * @see https://github.com/fread-ink/epub-cfi-resolver
 * @latest a0d7e4e39d5b4adc9150e006e0b6d7af9513ae27
 */
const ELEMENT_NODE = Node.ELEMENT_NODE;
const TEXT_NODE = Node.TEXT_NODE;
const CDATA_SECTION_NODE = Node.CDATA_SECTION_NODE;
function cfiEscape(str) {
    return str.replace(/[\[\]\^,();]/g, `^$&`);
}
// Get indices of all matches of regExp in str
// if `add` is non-null, add it to the matched indices
function matchAll(str, regExp, add) {
    add = add || 0;
    const matches = [];
    let offset = 0;
    let m;
    do {
        m = str.match(regExp);
        if (!m)
            break;
        matches.push(m.index + add);
        // @ts-ignore
        offset += m.index + m.length;
        // @ts-ignore
        str = str.slice(m.index + m.length);
    } while (offset < str.length);
    return matches;
}
// Get the number in a that has the smallest diff to n
function closest(a, n) {
    let minDiff;
    let closest;
    let i, diff;
    for (i = 0; i < a.length; i++) {
        diff = Math.abs(a[i] - n);
        // @ts-ignore
        if (!i || diff < minDiff) {
            diff = minDiff;
            closest = a[i];
        }
    }
    return closest;
}
// Given a set of nodes that are all children
// and a reference to one of those nodes
// calculate the count/index of the node
// according to the CFI spec.
// Also re-calculate offset if supplied and relevant
function calcSiblingCount(nodes, n, offset) {
    let count = 0;
    let lastWasElement;
    let prevOffset = 0;
    let firstNode = true;
    let i, node;
    for (i = 0; i < nodes.length; i++) {
        node = nodes[i];
        // @ts-ignore
        if (node.nodeType === ELEMENT_NODE) {
            if (lastWasElement || firstNode) {
                count += 2;
                firstNode = false;
            }
            else {
                count++;
            }
            // @ts-ignore
            if (n === node) {
                // @ts-ignore
                if (node.tagName.toLowerCase() === `img`) {
                    return { count, offset };
                }
                else {
                    return { count };
                }
            }
            prevOffset = 0;
            lastWasElement = true;
        }
        else if ((node === null || node === void 0 ? void 0 : node.nodeType) === TEXT_NODE ||
            (node === null || node === void 0 ? void 0 : node.nodeType) === CDATA_SECTION_NODE) {
            if (lastWasElement || firstNode) {
                count++;
                firstNode = false;
            }
            // @ts-ignore
            if (n === node) {
                return { count, offset: offset + prevOffset };
            }
            // @ts-ignore
            prevOffset += node.textContent.length;
            lastWasElement = false;
        }
        else {
            continue;
        }
    }
    throw new Error(`The specified node was not found in the array of siblings`);
}
function compareTemporal(a, b) {
    const isA = typeof a === `number`;
    const isB = typeof b === `number`;
    if (!isA && !isB)
        return 0;
    if (!isA && isB)
        return -1;
    if (isA && !isB)
        return 1;
    return (a || 0.0) - (b || 0.0);
}
function compareSpatial(a, b) {
    if (!a && !b)
        return 0;
    if (!a && b)
        return -1;
    if (a && !b)
        return 1;
    const diff = (a.y || 0) - (b.y || 0);
    if (diff)
        return diff;
    return (a.x || 0) - (b.x || 0);
}
class CFI {
    constructor(str, opts) {
        this.isRange = false;
        this.opts = Object.assign({
            // If CFI is a Simple Range, pretend it isn't
            // by parsing only the start of the range
            flattenRange: false,
            // Strip temporal, spatial, offset and textLocationAssertion
            // from places where they don't make sense
            stricter: true,
        }, opts || {});
        this.cfi = str;
        this.parts = [];
        const isCFI = /^epubcfi\((.*)\)$/;
        str = str.trim();
        const m = str.match(isCFI);
        if (!m)
            throw new Error(`Not a valid CFI`);
        if (m.length < 2)
            return; // Empty CFI
        str = m[1] || ``;
        let parsed, offset, newDoc;
        let subParts = [];
        let sawComma = 0;
        while (str.length) {
            ({ parsed, offset, newDoc } = this.parse(str));
            if (!parsed || offset === null)
                throw new Error(`Parsing failed`);
            if (sawComma && newDoc)
                throw new Error(`CFI is a range that spans multiple documents. This is not allowed`);
            subParts.push(parsed);
            // Handle end of string
            if (newDoc || str.length - offset <= 0) {
                // Handle end if this was a range
                if (sawComma === 2) {
                    // @ts-ignore
                    this.to = subParts;
                }
                else {
                    // not a range
                    this.parts.push(subParts);
                }
                subParts = [];
            }
            str = str.slice(offset);
            // Handle Simple Ranges
            if (str[0] === `,`) {
                if (sawComma === 0) {
                    if (subParts.length) {
                        this.parts.push(subParts);
                    }
                    subParts = [];
                }
                else if (sawComma === 1) {
                    if (subParts.length) {
                        // @ts-ignore
                        this.from = subParts;
                    }
                    subParts = [];
                }
                str = str.slice(1);
                sawComma++;
            }
        }
        // @ts-ignore
        if (this.from && this.from.length) {
            // @ts-ignore
            if (this.opts.flattenRange || !this.to || !this.to.length) {
                // @ts-ignore
                this.parts = this.parts.concat(this.from);
                // @ts-ignore
                delete this.from;
                // @ts-ignore
                delete this.to;
            }
            else {
                this.isRange = true;
            }
        }
        // @ts-ignore
        if (this.opts.stricter) {
            // @ts-ignore
            this.removeIllegalOpts();
        }
    }
    removeIllegalOpts(parts) {
        if (!parts) {
            // @ts-ignore
            if (this.from) {
                // @ts-ignore
                this.removeIllegalOpts(this.from);
                // @ts-ignore
                if (!this.to)
                    return;
                // @ts-ignore
                parts = this.to;
            }
            else {
                parts = this.parts;
            }
        }
        let i, j, part, subpart;
        for (i = 0; i < parts.length; i++) {
            part = parts[i];
            for (j = 0; j < part.length - 1; j++) {
                subpart = part[j];
                delete subpart.temporal;
                delete subpart.spatial;
                delete subpart.offset;
                delete subpart.textLocationAssertion;
            }
        }
    }
    static generatePart(node, offset, extra) {
        let cfi = ``;
        let o;
        while (node.parentNode) {
            // @ts-ignore
            o = calcSiblingCount(node.parentNode.childNodes, node, offset);
            if (!cfi && o.offset)
                cfi = `:` + o.offset;
            // @ts-ignore
            cfi =
                `/` +
                    o.count +
                    (node.id ? `[` + cfiEscape(node.id) + `]` : ``) +
                    cfi;
            // debugger
            node = node.parentNode;
        }
        return cfi;
    }
    static generate(node, offset, extra) {
        let cfi;
        if (Array.isArray(node)) {
            const strs = [];
            for (const o of node) {
                strs.push(this.generatePart(o.node, o.offset, extra));
            }
            cfi = strs.join(`!`);
        }
        else {
            cfi = this.generatePart(node, offset, extra);
        }
        if (extra)
            cfi += extra;
        return `epubcfi(` + cfi + `)`;
    }
    static toParsed(cfi) {
        if (cfi.isRange) {
            return cfi.getFrom();
        }
        else {
            return cfi.get();
        }
    }
    // Takes two CFI paths and compares them
    static comparePath(a, b) {
        const max = Math.max(a.length, b.length);
        let i, cA, cB, diff;
        for (i = 0; i < max; i++) {
            cA = a[i];
            cB = b[i];
            if (!cA)
                return -1;
            if (!cB)
                return 1;
            diff = this.compareParts(cA, cB);
            if (diff)
                return diff;
        }
        return 0;
    }
    // Sort an array of CFI objects
    static sort(a) {
        // @ts-ignore
        a.sort((a, b) => {
            return this.compare(a, b);
        });
    }
    // Takes two CFI objects and compares them.
    static compare(a, b) {
        let oA = a.get();
        let oB = b.get();
        if (a.isRange || b.isRange) {
            if (a.isRange && b.isRange) {
                const diff = this.comparePath(oA.from, oB.from);
                if (diff)
                    return diff;
                return this.comparePath(oA.to, oB.to);
            }
            if (a.isRange)
                oA = oA.from;
            if (b.isRange)
                oB = oB.from;
            return this.comparePath(oA, oB);
        }
        else {
            // neither a nor b is a range
            return this.comparePath(oA, oB);
        }
    }
    // Takes two parsed path parts (assuming path is split on '!') and compares them.
    static compareParts(a, b) {
        const max = Math.max(a.length, b.length);
        let i, cA, cB, diff;
        for (i = 0; i < max; i++) {
            cA = a[i];
            cB = b[i];
            if (!cA)
                return -1;
            if (!cB)
                return 1;
            diff = cA.nodeIndex - cB.nodeIndex;
            if (diff)
                return diff;
            // The paths must be equal if the "before the first node" syntax is used
            // and this must be the last subpart (assuming a valid CFI)
            if (cA.nodeIndex === 0) {
                return 0;
            }
            // Don't bother comparing offsets, temporals or spatials
            // unless we're on the last element, since they're not
            // supposed to be on elements other than the last
            if (i < max - 1)
                continue;
            // Only compare spatials or temporals for element nodes
            if (cA.nodeIndex % 2 === 0) {
                diff = compareTemporal(cA.temporal, cB.temporal);
                if (diff)
                    return diff;
                diff = compareSpatial(cA.spatial, cB.spatial);
                if (diff)
                    return diff;
            }
            diff = (cA.offset || 0) - (cB.offset || 0);
            if (diff)
                return diff;
        }
        return 0;
    }
    decodeEntities(dom, str) {
        try {
            const el = dom.createElement(`textarea`);
            el.innerHTML = str;
            return el.value || ``;
        }
        catch (err) {
            // TODO fall back to simpler decode?
            // e.g. regex match for stuff like &#160; and &nbsp;
            return str;
        }
    }
    // decode HTML/XML entities and compute length
    trueLength(dom, str) {
        return this.decodeEntities(dom, str).length;
    }
    getFrom() {
        if (!this.isRange)
            throw new Error(`Trying to get beginning of non-range CFI`);
        // @ts-ignore
        if (!this.from) {
            return this.deepClone(this.parts);
        }
        const parts = this.deepClone(this.parts);
        // @ts-ignore
        parts[parts.length - 1] = parts[parts.length - 1].concat(this.from);
        return parts;
    }
    getTo() {
        if (!this.isRange)
            throw new Error(`Trying to get end of non-range CFI`);
        const parts = this.deepClone(this.parts);
        // @ts-ignore
        parts[parts.length - 1] = parts[parts.length - 1].concat(this.to);
        return parts;
    }
    get() {
        if (this.isRange) {
            return {
                from: this.getFrom(),
                to: this.getTo(),
                isRange: true,
            };
        }
        return this.deepClone(this.parts);
    }
    parseSideBias(o, loc) {
        if (!loc)
            return;
        const m = loc.trim().match(/^(.*);s=([ba])$/);
        if (!m || m.length < 3) {
            if (typeof o.textLocationAssertion === `object`) {
                o.textLocationAssertion.post = loc;
            }
            else {
                o.textLocationAssertion = loc;
            }
            return;
        }
        if (m[1]) {
            if (typeof o.textLocationAssertion === `object`) {
                o.textLocationAssertion.post = m[1];
            }
            else {
                o.textLocationAssertion = m[1];
            }
        }
        if (m[2] === `a`) {
            o.sideBias = `after`;
        }
        else {
            o.sideBias = `before`;
        }
    }
    parseSpatialRange(range) {
        if (!range)
            return undefined;
        const m = range.trim().match(/^([\d\.]+):([\d\.]+)$/);
        if (!m || m.length < 3)
            return undefined;
        const o = {
            x: parseInt(m[1]),
            y: parseInt(m[2]),
        };
        if (typeof o.x !== `number` || typeof o.y !== `number`) {
            return undefined;
        }
        return o;
    }
    parse(cfi) {
        const o = {};
        const isNumber = /[\d]/;
        let f;
        let state;
        let prevState;
        let cur, escape;
        let seenColon = false;
        let seenSlash = false;
        let i;
        for (i = 0; i <= cfi.length; i++) {
            if (i < cfi.length) {
                cur = cfi[i];
            }
            else {
                cur = ``;
            }
            if (cur === `^` && !escape) {
                escape = true;
                continue;
            }
            if (state === `/`) {
                if (cur.match(isNumber)) {
                    if (!f) {
                        f = cur;
                    }
                    else {
                        f += cur;
                    }
                    escape = false;
                    continue;
                }
                else {
                    if (f) {
                        // @ts-ignore
                        o.nodeIndex = parseInt(f);
                        f = null;
                    }
                    prevState = state;
                    state = null;
                }
            }
            if (state === `:`) {
                if (cur.match(isNumber)) {
                    if (!f) {
                        f = cur;
                    }
                    else {
                        f += cur;
                    }
                    escape = false;
                    continue;
                }
                else {
                    if (f) {
                        // @ts-ignore
                        o.offset = parseInt(f);
                        f = null;
                    }
                    prevState = state;
                    state = null;
                }
            }
            if (state === `@`) {
                let done = false;
                if (cur.match(isNumber) || cur === `.` || cur === `:`) {
                    if (cur === `:`) {
                        if (!seenColon) {
                            seenColon = true;
                        }
                        else {
                            done = true;
                        }
                    }
                }
                else {
                    done = true;
                }
                if (!done) {
                    if (!f) {
                        f = cur;
                    }
                    else {
                        f += cur;
                    }
                    escape = false;
                    continue;
                }
                else {
                    prevState = state;
                    state = null;
                    // @ts-ignore
                    if (f && seenColon)
                        o.spatial = this.parseSpatialRange(f);
                    f = null;
                }
            }
            if (state === `~`) {
                if (cur.match(isNumber) || cur === `.`) {
                    if (!f) {
                        f = cur;
                    }
                    else {
                        f += cur;
                    }
                    escape = false;
                    continue;
                }
                else {
                    if (f) {
                        // @ts-ignore
                        o.temporal = parseFloat(f);
                    }
                    prevState = state;
                    state = null;
                    f = null;
                }
            }
            if (!state) {
                if (cur === `!`) {
                    i++;
                    state = cur;
                    break;
                }
                if (cur === `,`) {
                    break;
                }
                if (cur === `/`) {
                    if (seenSlash) {
                        break;
                    }
                    else {
                        seenSlash = true;
                        prevState = state;
                        state = cur;
                        escape = false;
                        continue;
                    }
                }
                if (cur === `:` || cur === `~` || cur === `@`) {
                    // @ts-ignore
                    if (this.opts.stricter) {
                        // We've already had a temporal or spatial indicator
                        // and offset does not make sense and the same time
                        // @ts-ignore
                        if (cur === `:` &&
                            (typeof o.temporal !== `undefined` ||
                                typeof o.spatial !== `undefined`)) {
                            break;
                        }
                        // We've already had an offset
                        // and temporal or spatial do not make sense at the same time
                        // @ts-ignore
                        if ((cur === `~` || cur === `@`) &&
                            typeof o.offset !== `undefined`) {
                            break;
                        }
                    }
                    prevState = state;
                    state = cur;
                    escape = false;
                    seenColon = false; // only relevant for '@'
                    continue;
                }
                if (cur === `[` && !escape && prevState === `:`) {
                    prevState = state;
                    state = `[`;
                    escape = false;
                    continue;
                }
                if (cur === `[` && !escape && prevState === `/`) {
                    prevState = state;
                    state = `nodeID`;
                    escape = false;
                    continue;
                }
            }
            if (state === `[`) {
                if (cur === `]` && !escape) {
                    prevState = state;
                    state = null;
                    this.parseSideBias(o, f);
                    f = null;
                }
                else if (cur === `,` && !escape) {
                    // @ts-ignore
                    o.textLocationAssertion = {};
                    if (f) {
                        // @ts-ignore
                        o.textLocationAssertion.pre = f;
                    }
                    f = null;
                }
                else {
                    if (!f) {
                        f = cur;
                    }
                    else {
                        f += cur;
                    }
                }
                escape = false;
                continue;
            }
            if (state === `nodeID`) {
                if (cur === `]` && !escape) {
                    prevState = state;
                    state = null;
                    // @ts-ignore
                    o.nodeID = f;
                    f = null;
                }
                else {
                    if (!f) {
                        f = cur;
                    }
                    else {
                        f += cur;
                    }
                }
                escape = false;
                continue;
            }
            escape = false;
        }
        // @ts-ignore
        if (!o.nodeIndex && o.nodeIndex !== 0)
            throw new Error(`Missing child node index in CFI`);
        return { parsed: o, offset: i, newDoc: state === `!` };
    }
    // The CFI counts child nodes differently from the DOM
    // Retrieve the child of parentNode at the specified index
    // according to the CFI standard way of counting
    getChildNodeByCFIIndex(dom, parentNode, index, offset) {
        // console.log(`getChildNodeByCFIIndex`, { parentNode, index, offset })
        const children = parentNode.childNodes;
        if (!children.length)
            return { node: parentNode, offset: 0 };
        // index is pointing to the virtual node before the first node
        // as defined in the CFI spec
        if (index <= 0) {
            return { node: children[0], relativeToNode: `before`, offset: 0 };
        }
        let cfiCount = 0;
        let lastChild;
        let i, child;
        // console.log(children, children.length)
        for (i = 0; i < children.length; i++) {
            child = children[i];
            // @ts-ignore
            switch (child.nodeType) {
                case ELEMENT_NODE:
                    // If the previous node was also an element node
                    // then we have to pretend there was a text node in between
                    // the current and previous nodes (according to the CFI spec)
                    // so we increment cfiCount by two
                    if (cfiCount % 2 === 0) {
                        cfiCount += 2;
                        if (cfiCount >= index) {
                            // @ts-ignore
                            if (child.tagName.toLowerCase() === `img` && offset) {
                                return { node: child, offset };
                            }
                            return { node: child, offset: 0 };
                        }
                    }
                    else {
                        // Previous node was a text node
                        cfiCount += 1;
                        if (cfiCount === index) {
                            // @ts-ignore
                            if (child.tagName.toLowerCase() === `img` && offset) {
                                return { node: child, offset };
                            }
                            return { node: child, offset: 0 };
                            // This happens when offset into the previous text node was greater
                            // than the number of characters in that text node
                            // So we return a position at the end of the previous text node
                        }
                        else if (cfiCount > index) {
                            if (!lastChild) {
                                return { node: parentNode, offset: 0 };
                            }
                            // @ts-ignore
                            return {
                                node: lastChild,
                                offset: this.trueLength(dom, lastChild.textContent),
                            };
                        }
                    }
                    lastChild = child;
                    break;
                case TEXT_NODE:
                case CDATA_SECTION_NODE:
                    // console.log('TEXT')
                    // If this is the first node or the previous node was an element node
                    if (cfiCount === 0 || cfiCount % 2 === 0) {
                        cfiCount += 1;
                    }
                    if (cfiCount === index) {
                        // If offset is greater than the length of the current text node
                        // then we assume that the next node will also be a text node
                        // and that we'll be combining them with the current node
                        // @ts-ignore
                        const trueLength = this.trueLength(dom, child.textContent);
                        if (offset >= trueLength) {
                            offset -= trueLength;
                        }
                        else {
                            return { node: child, offset: offset };
                        }
                    }
                    lastChild = child;
                    break;
                default:
                    continue;
            }
        }
        // console.log(lastChild, index, cfiCount)
        // index is pointing to the virtual node after the last child
        // as defined in the CFI spec
        if (index > cfiCount) {
            const o = { relativeToNode: `after`, offset: 0 };
            if (!lastChild) {
                // @ts-ignore
                o.node = parentNode;
            }
            else {
                // @ts-ignore
                o.node = lastChild;
            }
            // @ts-ignore
            if (this.isTextNode(o.node)) {
                // @ts-ignore
                o.offset = this.trueLength(dom, o.node.textContent.length);
            }
            return o;
        }
    }
    isTextNode(node) {
        if (!node)
            return false;
        if (node.nodeType === TEXT_NODE || node.nodeType === CDATA_SECTION_NODE) {
            return true;
        }
        return false;
    }
    // Use a Text Location Assertion to correct and offset
    correctOffset(dom, node, offset, assertion) {
        let curNode = node;
        let matchStr;
        if (typeof assertion === `string`) {
            matchStr = this.decodeEntities(dom, assertion);
        }
        else {
            assertion.pre = this.decodeEntities(dom, assertion.pre);
            assertion.post = this.decodeEntities(dom, assertion.post);
            matchStr = assertion.pre + `.` + assertion.post;
        }
        if (!this.isTextNode(node)) {
            return { node, offset: 0 };
        }
        // @ts-ignore
        while (this.isTextNode(curNode.previousSibling)) {
            // @ts-ignore
            curNode = curNode.previousSibling;
        }
        const startNode = curNode;
        let str;
        const nodeLengths = [];
        let txt = ``;
        let i = 0;
        while (this.isTextNode(curNode)) {
            // @ts-ignore
            str = this.decodeEntities(dom, curNode.textContent);
            nodeLengths[i] = str.length;
            txt += str;
            if (!curNode.nextSibling)
                break;
            // @ts-ignore
            curNode = curNode.nextSibling;
            i++;
        }
        // Find all matches to the Text Location Assertion
        const matchOffset = assertion.pre ? assertion.pre.length : 0;
        const m = matchAll(txt, new RegExp(matchStr), matchOffset);
        if (!m.length)
            return { node, offset };
        // Get the match that has the closest offset to the existing offset
        let newOffset = closest(m, offset);
        if (curNode === node && newOffset === offset) {
            return { node, offset };
        }
        i = 0;
        curNode = startNode;
        // @ts-ignore
        while (newOffset >= nodeLengths[i]) {
            // @ts-ignore
            newOffset -= nodeLengths[i];
            if (newOffset < 0)
                return { node, offset };
            const nodeOffsets = []; // added because original code has nodeOffsets undefined. @see https://github.com/fread-ink/epub-cfi-resolver/blob/master/index.js#L826
            if (!curNode.nextSibling || i + 1 >= nodeOffsets.length)
                return { node, offset };
            i++;
            // @ts-ignore
            curNode = curNode.nextSibling;
        }
        return { node: curNode, offset: newOffset };
    }
    resolveNode(index, subparts, dom, opts) {
        opts = Object.assign({}, opts || {});
        if (!dom)
            throw new Error(`Missing DOM argument`);
        // Traverse backwards until a subpart with a valid ID is found
        // or the first subpart is reached
        let startNode;
        if (index === 0) {
            startNode = dom.querySelector(`package`);
        }
        if (!startNode) {
            for (const n of dom.childNodes) {
                if (n.nodeType === ELEMENT_NODE) {
                    // if (n.nodeType === Node.DOCUMENT_NODE) {
                    startNode = n;
                    break;
                }
            }
        }
        // custom
        startNode = dom;
        // debugger
        if (!startNode)
            throw new Error(`Document incompatible with CFIs`);
        let node = startNode;
        let startFrom = 0;
        let i;
        let subpart;
        for (i = subparts.length - 1; i >= 0; i--) {
            subpart = subparts[i];
            // @ts-ignore
            if (!opts.ignoreIDs &&
                subpart.nodeID &&
                (node = dom.getElementById(subpart.nodeID))) {
                startFrom = i + 1;
                break;
            }
        }
        // console.log(startNode, startFrom)
        if (!node) {
            node = startNode;
        }
        let o = { node, offset: 0 };
        for (i = startFrom; i < subparts.length; i++) {
            subpart = subparts[i];
            if (subpart) {
                // console.log(o, dom, o.node, subpart.nodeIndex, subpart.offset)
                // @ts-ignore
                o = this.getChildNodeByCFIIndex(dom, o.node, subpart.nodeIndex, subpart.offset);
                // @ts-ignore
                if (subpart.textLocationAssertion) {
                    // console.log(subparts, subpart, o)
                    // @ts-ignore
                    o = this.correctOffset(dom, o.node, subpart.offset, subpart.textLocationAssertion);
                }
            }
        }
        return o;
    }
    // Each part of a CFI (as separated by '!')
    // references a separate HTML/XHTML/XML document.
    // This function takes an index specifying the part
    // of the CFI and the appropriate Document or XMLDocument
    // that is referenced by the specified part of the CFI
    // and returns the URI for the document referenced by
    // the next part of the CFI
    // If the opt `ignoreIDs` is true then IDs
    // will not be used while resolving
    resolveURI(index, dom, opts) {
        opts = opts || {};
        if (index < 0 || index > this.parts.length - 2) {
            throw new Error(`index is out of bounds`);
        }
        const subparts = this.parts[index];
        if (!subparts)
            throw new Error(`Missing CFI part for index: ` + index);
        // @ts-ignore
        const o = this.resolveNode(index, subparts, dom, opts);
        // debugger
        let node = o.node;
        // @ts-ignore
        const tagName = node.tagName.toLowerCase();
        if (tagName === `itemref` &&
            // @ts-ignore
            node.parentNode.tagName.toLowerCase() === `spine`) {
            // @ts-ignore
            const idref = node.getAttribute(`idref`);
            if (!idref)
                throw new Error(`Referenced node had not 'idref' attribute`);
            // @ts-ignore
            node = dom.getElementById(idref);
            if (!node)
                throw new Error(`Specified node is missing from manifest`);
            // @ts-ignore
            const href = node.getAttribute(`href`);
            if (!href)
                throw new Error(`Manifest item is missing href attribute`);
            return href;
        }
        if (tagName === `iframe` || tagName === `embed`) {
            // @ts-ignore
            const src = node.getAttribute(`src`);
            if (!src)
                throw new Error(tagName + ` element is missing 'src' attribute`);
            return src;
        }
        if (tagName === `object`) {
            // @ts-ignore
            const data = node.getAttribute(`data`);
            if (!data)
                throw new Error(tagName + ` element is missing 'data' attribute`);
            return data;
        }
        if (tagName === `image` || tagName === `use`) {
            // @ts-ignore
            const href = node.getAttribute(`xlink:href`);
            if (!href)
                throw new Error(tagName + ` element is missing 'xlink:href' attribute`);
            return href;
        }
        throw new Error(`No URI found`);
    }
    deepClone(o) {
        return JSON.parse(JSON.stringify(o));
    }
    resolveLocation(dom, parts) {
        const index = parts.length - 1;
        const subparts = parts[index];
        if (!subparts)
            throw new Error(`Missing CFI part for index: ` + index);
        // @ts-ignore
        const o = this.resolveNode(index, subparts, dom);
        // @ts-ignore
        const lastPart = this.deepClone(subparts[subparts.length - 1]);
        delete lastPart.nodeIndex;
        // @ts-ignore
        if (!lastPart.offset)
            delete o.offset;
        return Object.assign(Object.assign({}, lastPart), o);
    }
    // Takes the Document or XMLDocument for the final
    // document referenced by the CFI
    // and returns the node and offset into that node
    resolveLast(dom, opts) {
        opts = Object.assign({
            range: false,
        }, opts || {});
        if (!this.isRange) {
            return this.resolveLocation(dom, this.parts);
        }
        // @ts-ignore
        if (opts.range) {
            const range = dom.createRange();
            const from = this.getFrom();
            if (from.relativeToNode === `before`) {
                // @ts-ignore
                range.setStartBefore(from.node, from.offset);
            }
            else if (from.relativeToNode === `after`) {
                // @ts-ignore
                range.setStartAfter(from.node, from.offset);
            }
            else {
                range.setStart(from.node, from.offset);
            }
            const to = this.getTo();
            if (to.relativeToNode === `before`) {
                // @ts-ignore
                range.setEndBefore(to.node, to.offset);
            }
            else if (to.relativeToNode === `after`) {
                // @ts-ignore
                range.setEndAfter(to.node, to.offset);
            }
            else {
                range.setEnd(to.node, to.offset);
            }
            return range;
        }
        return {
            from: this.resolveLocation(dom, this.getFrom()),
            to: this.resolveLocation(dom, this.getTo()),
            isRange: true,
        };
    }
    resolve(doc, opts) {
        // @ts-ignore
        return this.resolveLast(doc, opts);
    }
}

const classes = [
    "color-0",
    "color-1",
    "color-2",
    "color-3",
    "line-0",
    "line-1",
    "line-2",
    "line-3",
];
const colors = ["#FEF3CD", "#FBFACC", "#CEFACD", "#CDE9FA"];
const lines = ["#FF0000", "#000080", "#0000FF", "#2EFF2E"];
const pdfColors = ["#fac106", "#ebe702", "#0be603", "#0493e6"];
const showNoteHighlight = (range, colorIndex, noteKey, handleNoteClick, doc, iframe) => {
    var _a, _b;
    rangy.init();
    let colorCode = classes[colorIndex];
    let iWin = iframe.contentWindow || ((_a = iframe.contentDocument) === null || _a === void 0 ? void 0 : _a.defaultView);
    let temp = range;
    temp = [temp];
    // sleep(500);
    rangy.getSelection(iframe).restoreCharacterRanges(doc, temp);
    let sel = doc.getSelection();
    if (!sel)
        return;
    let newRange = sel.getRangeAt(0);
    var safeRanges = getSafeRanges(newRange);
    for (var i = 0; i < safeRanges.length; i++) {
        highlightRange(safeRanges[i], colorCode, noteKey, handleNoteClick, doc);
    }
    if (!iWin || !iWin.getSelection())
        return;
    (_b = iWin.getSelection()) === null || _b === void 0 ? void 0 : _b.empty();
};
const showPDFHighlight = (selected, colorIndex, noteKey, handleNoteClick, page, scale, doc) => {
    let colorCode = classes[colorIndex];
    let pageElement = doc.querySelector(".noteLayer");
    let docLayer = doc.querySelector("#koodoPDFLayer");
    var viewport = page.getViewport({ scale: scale });
    selected.coords.forEach((rect) => {
        var bounds = viewport.convertToViewportRectangle(rect);
        var newNode = document.createElement("div");
        if (!docLayer) {
            return;
        }
        newNode === null || newNode === void 0 ? void 0 : newNode.setAttribute("style", "position: absolute;" +
            (colorCode.indexOf("color") > -1
                ? "background-color: "
                : "border-bottom: ") +
            (colorCode.indexOf("color") > -1
                ? pdfColors[colorCode.split("-")[1]]
                : `2px solid ${lines[colorCode.split("-")[1]]}`) +
            "; left:" +
            (Math.min(bounds[0], bounds[2]) +
                parseFloat(getComputedStyle(docLayer).marginLeft)) +
            "px; top:" +
            Math.min(bounds[1], bounds[3]) +
            "px;" +
            "width:" +
            Math.abs(bounds[0] - bounds[2]) +
            "px; height:" +
            Math.abs(bounds[1] - bounds[3]) +
            "px; z-index: 1;opacity: " +
            (colorCode.indexOf("color") > -1 ? 0.3 : 1) +
            ";");
        newNode === null || newNode === void 0 ? void 0 : newNode.setAttribute("data-key", noteKey);
        newNode === null || newNode === void 0 ? void 0 : newNode.setAttribute("class", "kookit-note");
        newNode === null || newNode === void 0 ? void 0 : newNode.addEventListener("click", (event) => {
            if (event && event.target) {
                if (event.target.dataset &&
                    event.target.dataset.key) {
                    handleNoteClick(event);
                }
            }
        });
        newNode.ontouchend = (event) => {
            if (event && event.target) {
                if (event.target.dataset &&
                    event.target.dataset.key) {
                    handleNoteClick(event);
                }
            }
            event.preventDefault();
            event.stopPropagation();
        };
        pageElement.appendChild(newNode);
    });
};
const clearHighlight = (doc) => {
    const elements = doc.querySelectorAll(".kookit-note");
    for (let index = 0; index < elements.length; index++) {
        const element = elements[index];
        element.parentNode.removeChild(element);
    }
};
const highlightRange = (range, colorCode, noteKey, handleNoteClick, doc) => {
    const rects = filterRects(range.getClientRects());
    for (let index = 0; index < rects.length; index++) {
        const rect = rects[index];
        var newNode = document.createElement("span");
        newNode === null || newNode === void 0 ? void 0 : newNode.setAttribute("style", "position: absolute;" +
            (colorCode.indexOf("color") > -1
                ? "background-color: "
                : "border-bottom: ") +
            (colorCode.indexOf("color") > -1
                ? colors[colorCode.split("-")[1]] + ";opacity: 1"
                : `2px solid ${lines[colorCode.split("-")[1]]}`) +
            ";left:" +
            (Math.min(rect.left, rect.x) + doc.body.scrollLeft) +
            "px; top:" +
            (Math.min(rect.top, rect.y) + doc.body.scrollTop) +
            "px;" +
            "width:" +
            rect.width +
            "px; height:" +
            rect.height +
            "px; z-index:-1;");
        newNode.setAttribute("class", " kookit-note");
        newNode.setAttribute("data-key", noteKey);
        // newNode.setAttribute("onclick", `window.handleNoteClick()`);
        doc.body.appendChild(newNode);
        var clickNode = document.createElement("span");
        clickNode === null || clickNode === void 0 ? void 0 : clickNode.setAttribute("style", "position: absolute;" +
            "left:" +
            (Math.min(rect.left, rect.x) + doc.body.scrollLeft) +
            "px; top:" +
            (Math.min(rect.top, rect.y) + doc.body.scrollTop) +
            "px;" +
            "width:" +
            rect.width +
            "px; height:" +
            rect.height +
            "px; z-index:1;");
        clickNode.setAttribute("class", " kookit-note");
        clickNode.setAttribute("data-key", noteKey);
        clickNode.addEventListener("click", (event) => {
            if (event && event.target) {
                if (event.target.dataset &&
                    event.target.dataset.key) {
                    handleNoteClick(event);
                }
            }
        });
        clickNode.ontouchend = (event) => {
            if (event && event.target) {
                if (event.target.dataset &&
                    event.target.dataset.key) {
                    handleNoteClick(event);
                }
            }
            event.preventDefault();
            event.stopPropagation();
        };
        doc.body.appendChild(clickNode);
    }
};
const filterRects = (rects) => {
    let result = [];
    for (let index = 0; index < rects.length; index++) {
        const rect = rects[index];
        result.push(rect);
    }
    return result;
};
const getSafeRanges = (dangerous) => {
    var a = dangerous.commonAncestorContainer;
    // Starts -- Work inward from the start, selecting the largest safe range
    var s = new Array(0), rs = new Array(0);
    if (dangerous.startContainer !== a) {
        for (let i = dangerous.startContainer; i !== a; i = i.parentNode) {
            s.push(i);
        }
    }
    if (s.length > 0) {
        for (let i = 0; i < s.length; i++) {
            var xs = document.createRange();
            if (i) {
                xs.setStartAfter(s[i - 1]);
                xs.setEndAfter(s[i].lastChild);
            }
            else {
                xs.setStart(s[i], dangerous.startOffset);
                xs.setEndAfter(s[i].nodeType === Node.TEXT_NODE ? s[i] : s[i].lastChild);
            }
            rs.push(xs);
        }
    }
    // Ends -- basically the same code reversed
    var e = new Array(0), re = new Array(0);
    if (dangerous.endContainer !== a) {
        for (var i = dangerous.endContainer; i !== a; i = i.parentNode) {
            e.push(i);
        }
    }
    if (e.length > 0) {
        for (let i = 0; i < e.length; i++) {
            var xe = document.createRange();
            if (i) {
                xe.setStartBefore(e[i].firstChild);
                xe.setEndBefore(e[i - 1]);
            }
            else {
                xe.setStartBefore(e[i].nodeType === Node.TEXT_NODE ? e[i] : e[i].firstChild);
                xe.setEnd(e[i], dangerous.endOffset);
            }
            re.unshift(xe);
        }
    }
    // Middle -- the uncaptured middle
    if (s.length > 0 && e.length > 0) {
        var xm = document.createRange();
        xm.setStartAfter(s[s.length - 1]);
        xm.setEndBefore(e[e.length - 1]);
    }
    else {
        return [dangerous];
    }
    // Concat
    rs.push(xm);
    let response = rs.concat(re);
    // Send to Console
    return response;
};

function createBookElement(sectionCount) {
    let tempDiv = document.getElementById("book");
    if (tempDiv) {
        tempDiv.remove();
    }
    // Create the book div
    const bookDiv = document.createElement("div");
    bookDiv.id = "book";
    // Create the canvas element
    const canvas = document.createElement("canvas");
    canvas.id = "pageflip-canvas";
    // Create the pages div
    const pagesDiv = document.createElement("div");
    pagesDiv.id = "pages";
    // Create the section elements based on sectionCount
    for (let i = 0; i < sectionCount; i++) {
        const section = document.createElement("section");
        pagesDiv.appendChild(section);
    }
    // Append the canvas and pages div to the book div
    bookDiv.appendChild(canvas);
    bookDiv.appendChild(pagesDiv);
    // Append the book div to the body
    document.body.appendChild(bookDiv);
    let css = `
      #book {
        position: fixed;
        width: 200vw;
        height: 100vh;
        left: -100vw;
        top: 0vh;
        float: left;
        margin: 0;
        display: none;
      }

      #pages section {
        display: block;
        width: 100vw;
        height: 100vh;
        position: absolute;
        left: 100vw;
        top: 0px;
        overflow: hidden;
        margin: 0;
      }

      #pageflip-canvas {
        position: absolute;
        z-index: 100;
        margin: 0;
      }
    `;
    let style = document.createElement("style");
    style.innerHTML = css;
    document.head.appendChild(style);
}
const addPageAnimation = (totalPage, isDarkMode, backgroundColor) => {
    // Example usage: create a book element with 3 sections
    createBookElement(totalPage);
    var WINDOW_WIDTH = window.innerWidth;
    var WINDOW_HEIGHT = window.innerHeight;
    // The canvas size equals to the book dimensions + this padding
    var CANVAS_PADDING = 0;
    // Dimensions of the whole book
    var BOOK_WIDTH = 2 * WINDOW_WIDTH - CANVAS_PADDING;
    var BOOK_HEIGHT = WINDOW_HEIGHT - CANVAS_PADDING;
    // Dimensions of one page in the book
    var PAGE_WIDTH = WINDOW_WIDTH;
    var PAGE_HEIGHT = WINDOW_HEIGHT;
    // Vertical spacing between the top edge of the book and the papers
    var PAGE_Y = (BOOK_HEIGHT - PAGE_HEIGHT) / 2;
    var page = 0;
    var canvas = document.getElementById("pageflip-canvas");
    if (!canvas)
        return;
    var context = canvas.getContext("2d");
    var mouse = { x: 0, y: 0 };
    var flips = [];
    var book = document.getElementById("book");
    if (!book)
        return;
    // List of all the page elements in the DOM
    var pages = book.getElementsByTagName("section");
    // Organize the depth of our pages and create the flip definitions
    for (var i = 0, len = pages.length; i < len; i++) {
        pages[i].style.zIndex = len - i + "";
        flips.push({
            // Current progress of the flip (left -1 to right +1)
            progress: 1,
            // The target value towards which progress is always moving
            target: 1,
            // The page DOM element related to this flip
            page: pages[i],
            // True while the page is being dragged
            dragging: false,
        });
    }
    // Resize the canvas to match the book size
    canvas.width = BOOK_WIDTH + CANVAS_PADDING * 2;
    canvas.height = BOOK_HEIGHT + CANVAS_PADDING * 2;
    // Offset the canvas so that it's padding is evenly spread around the book
    canvas.style.top = -CANVAS_PADDING + "px";
    canvas.style.left = -CANVAS_PADDING + "px";
    // Render the page flip 60 times a second
    setInterval(render, 1800 / 60);
    document.addEventListener("mousemove", mouseMoveHandler, false);
    document.addEventListener("mousedown", mouseDownHandler, false);
    document.addEventListener("mouseup", mouseUpHandler, false);
    book.addEventListener("touchmove", mouseMoveHandler, false);
    book.addEventListener("touchstart", mouseDownHandler, false);
    book.addEventListener("touchend", mouseUpHandler, false);
    function mouseMoveHandler(event) {
        if (!book)
            return;
        // Offset mouse position so that the top of the spine is 0,0
        // mouse.x = event.clientX - book.offsetLeft - BOOK_WIDTH / 2;
        // mouse.y = event.clientY - book.offsetTop;
        const touch = event.touches[0];
        const touchCurrentX = touch.screenX;
        const touchCurrentY = touch.screenY;
        mouse.x = touchCurrentX - book.offsetLeft - BOOK_WIDTH / 2;
        mouse.y = touchCurrentY - book.offsetTop;
    }
    function mouseDownHandler(event) {
        const touch = event.touches[0];
        // flips[page].dragging = true;
        if (touch.screenX < window.screen.width / 2 && page - 1 >= 0) {
            flips[page - 1].dragging = true;
        }
        else if (touch.screenX > window.screen.width / 2 &&
            page + 1 < flips.length) {
            flips[page].dragging = true;
        }
        // Prevents the text selection cursor from appearing when dragging
        event.preventDefault();
    }
    function mouseUpHandler(event) {
        for (var i = 0; i < flips.length; i++) {
            // If this flip was being dragged we animate to its destination
            if (flips[i].dragging) {
                // Figure out which page we should go to next depending on the flip direction
                if (mouse.x < PAGE_WIDTH / 2) {
                    flips[i].target = -1;
                    page = Math.min(page + 1, flips.length);
                }
                else {
                    flips[i].target = 1;
                    page = Math.max(page - 1, 0);
                }
            }
            flips[i].dragging = false;
        }
    }
    function render() {
        context.clearRect(0, 0, canvas.width, canvas.height);
        for (var i = 0; i < flips.length; i++) {
            var flip = flips[i];
            if (flip.dragging) {
                flip.target = Math.max(Math.min(mouse.x / PAGE_WIDTH, 1), -1);
            }
            flip.progress += (flip.target - flip.progress) * 0.2;
            // If the flip is being dragged or is somewhere in the middle of the book, render it
            if (flip.dragging || Math.abs(flip.progress) < 0.997) {
                drawFlip(flip);
            }
        }
    }
    function drawFlip(flip) {
        // Strength of the fold is strongest in the middle of the book
        var strength = 1 - Math.abs(flip.progress);
        // Width of the folded paper
        var foldWidth = PAGE_WIDTH * 0.5 * (1 - flip.progress);
        // X position of the folded paper
        var foldX = PAGE_WIDTH * flip.progress + foldWidth;
        // How far the page should outdent vertically due to perspective
        var verticalOutdent = 20 * strength;
        // The maximum width of the left and right side shadows
        var paperShadowWidth = PAGE_WIDTH * 0.5 * Math.max(Math.min(1 - flip.progress, 0.5), 0);
        var rightShadowWidth = PAGE_WIDTH * 0.5 * Math.max(Math.min(strength, 0.5), 0);
        var leftShadowWidth = PAGE_WIDTH * 0.5 * Math.max(Math.min(strength, 0.5), 0);
        // Change page element width to match the x position of the fold
        flip.page.style.width = Math.max(foldX, 0) + "px";
        context.save();
        context.translate(CANVAS_PADDING + BOOK_WIDTH / 2, PAGE_Y + CANVAS_PADDING);
        // Draw a sharp shadow on the left side of the page
        context.strokeStyle =
            (isDarkMode === "no" ? "rgba(0,0,0," : "rgba(255,255,255,") +
                0.05 * strength +
                ")";
        context.lineWidth = 30 * strength;
        context.beginPath();
        context.moveTo(foldX - foldWidth, -verticalOutdent * 0.5);
        context.lineTo(foldX - foldWidth, PAGE_HEIGHT + verticalOutdent * 0.5);
        context.stroke();
        // Right side drop shadow
        var rightShadowGradient = context.createLinearGradient(foldX, 0, foldX + rightShadowWidth, 0);
        rightShadowGradient.addColorStop(0, (isDarkMode === "no" ? "rgba(0,0,0," : "rgba(255,255,255,") +
            strength * 0.2 +
            ")");
        rightShadowGradient.addColorStop(0.8, (isDarkMode === "no" ? "rgba(0,0,0," : "rgba(255,255,255,") + "0.0)");
        context.fillStyle = rightShadowGradient;
        context.beginPath();
        context.moveTo(foldX, 0);
        context.lineTo(foldX + rightShadowWidth, 0);
        context.lineTo(foldX + rightShadowWidth, PAGE_HEIGHT);
        context.lineTo(foldX, PAGE_HEIGHT);
        context.fill();
        // Left side drop shadow
        var leftShadowGradient = context.createLinearGradient(foldX - foldWidth - leftShadowWidth, 0, foldX - foldWidth, 0);
        leftShadowGradient.addColorStop(0, (isDarkMode === "no" ? "rgba(0,0,0," : "rgba(255,255,255,") + "0.0)");
        leftShadowGradient.addColorStop(1, (isDarkMode === "no" ? "rgba(0,0,0," : "rgba(255,255,255,") +
            +strength * 0.15 +
            ")");
        context.fillStyle = leftShadowGradient;
        context.beginPath();
        context.moveTo(foldX - foldWidth - leftShadowWidth, 0);
        context.lineTo(foldX - foldWidth, 0);
        context.lineTo(foldX - foldWidth, PAGE_HEIGHT);
        context.lineTo(foldX - foldWidth - leftShadowWidth, PAGE_HEIGHT);
        context.fill();
        // Gradient applied to the folded paper (highlights & shadows)
        var foldGradient = context.createLinearGradient(foldX - paperShadowWidth, 0, foldX, 0);
        if (backgroundColor) {
            foldGradient.addColorStop(0.35, backgroundColor);
            foldGradient.addColorStop(0.73, backgroundColor);
            foldGradient.addColorStop(0.9, backgroundColor);
            foldGradient.addColorStop(1.0, backgroundColor);
        }
        else if (isDarkMode === "no") {
            foldGradient.addColorStop(0.35, "#fafafa");
            foldGradient.addColorStop(0.73, "#eeeeee");
            foldGradient.addColorStop(0.9, "#fafafa");
            foldGradient.addColorStop(1.0, "#e2e2e2");
        }
        else {
            foldGradient.addColorStop(0.35, "#333");
            foldGradient.addColorStop(0.73, "#444");
            foldGradient.addColorStop(0.9, "#333");
            foldGradient.addColorStop(1.0, "#444");
        }
        context.fillStyle = foldGradient;
        context.strokeStyle =
            (isDarkMode === "no" ? "rgba(0,0,0," : "rgba(255,255,255,") + "0.06)";
        context.lineWidth = 0.5;
        // Draw the folded piece of paper
        context.beginPath();
        context.moveTo(foldX, 0);
        context.lineTo(foldX, PAGE_HEIGHT);
        context.quadraticCurveTo(foldX, PAGE_HEIGHT + verticalOutdent * 2, foldX - foldWidth, PAGE_HEIGHT + verticalOutdent);
        context.lineTo(foldX - foldWidth, -verticalOutdent);
        context.quadraticCurveTo(foldX, -verticalOutdent * 2, foldX, 0);
        context.fill();
        context.stroke();
        context.restore();
    }
    return {
        flipToNextPage: () => {
            console.info("flipToNextPage");
            if (page + 1 < flips.length) {
                flips[page].target = -1;
                page = Math.min(page + 1, flips.length);
            }
        },
        flipToPrevPage: () => {
            console.info("flipToPrevPage");
            if (page - 1 >= 0) {
                flips[page - 1].target = 1;
                page = Math.max(page - 1, 0);
            }
        },
        mouseDownHandler,
        mouseUpHandler,
        mouseMoveHandler,
    };
    // window.flipToNextPage = () => {
    //   if (page + 1 < flips.length) {
    //     flips[page].target = -1;
    //     page = Math.min(page + 1, flips.length);
    //   }
    // };
    // window.flipToPreviousPage = () => {
    //   if (page - 1 >= 0) {
    //     flips[page - 1].target = 1;
    //     page = Math.max(page - 1, 0);
    //   }
    // };
};

class GeneralRender extends EventEmitter {
    constructor(config) {
        super();
        this.tsTransform = () => {
            let doc = this.getDocument();
            if (!doc)
                return;
            if (this.convertChinese === "Simplified To Traditional") {
                doc
                    .querySelectorAll("h1,h2,h3,h4,h5,h6,p,div,ul,dl,ol,pre,blockquote,address")
                    .forEach((item) => {
                    item.innerHTML = item.innerHTML
                        .split("")
                        .map((item) => Chinese.s2t(item))
                        .join("");
                });
            }
            else if (this.convertChinese === "Traditional To Simplified") {
                doc
                    .querySelectorAll("h1,h2,h3,h4,h5,h6,p,div,ul,dl,ol,pre,blockquote,address")
                    .forEach((item) => {
                    item.innerHTML = item.innerHTML
                        .split("")
                        .map((item) => Chinese.t2s(item))
                        .join("");
                });
            }
        };
        this.addPageAnimation = (backgroundColor) => {
            if (this.animation === "mimical") {
                let progressInfo = this.getProgress();
                if (!progressInfo)
                    return;
                const pageAnimation = addPageAnimation(progressInfo.totalPage, this.isDarkMode, backgroundColor);
                if (pageAnimation) {
                    this.flipToNextPage = pageAnimation.flipToNextPage;
                    this.flipToPrevPage = pageAnimation.flipToPrevPage;
                    this.mouseDownHandler = pageAnimation.mouseDownHandler;
                    this.mouseUpHandler = pageAnimation.mouseUpHandler;
                    this.mouseMoveHandler = pageAnimation.mouseMoveHandler;
                }
            }
        };
        this.readerMode = config.readerMode;
        this.animation = config.animation;
        this.format = config.format;
        this.convertChinese = config.convertChinese;
        this.isDarkMode = config.isDarkMode;
        this.isMobile = config.isMobile;
        this.chapterList = [];
        this.chapterDocList = [];
        this.flattenChapters = [];
        this.book = "";
        this.element = "";
        this.tempLocation = {};
        this.flipToNextPage = () => { };
        this.flipToPrevPage = () => { };
        this.mouseDownHandler = () => { };
        this.mouseUpHandler = () => { };
        this.mouseMoveHandler = (event) => { };
    }
    getPageSize() {
        let scale = this.readerMode === "double" ? 2 : 1;
        let section = Math.floor(this.element.clientWidth / 12);
        let gap = section % 2 === 0 ? section : section - 1;
        return {
            width: this.element.clientWidth,
            height: this.element.clientHeight,
            left: this.element.offsetLeft,
            top: this.element.offsetTop,
            scrollTop: this.element.scrollTop,
            sectionWidth: (this.element.clientWidth - gap) / scale,
            gap: gap,
        };
    }
    resolveChapter(href) {
        let path = href;
        let chapterIndex = -1;
        for (let index = 0; index < this.flattenChapters.length; index++) {
            if (this.flattenChapters[index].href.includes(path)) {
                chapterIndex = index;
                break;
            }
        }
        if (chapterIndex > -1) {
            return this.flattenChapters[chapterIndex];
        }
        else {
            let pathWithoutHash = href.split("#")[0];
            for (let index = 0; index < this.flattenChapters.length; index++) {
                if (this.flattenChapters[index].href.includes(pathWithoutHash.substring(1))) {
                    chapterIndex = index;
                    break;
                }
            }
            if (chapterIndex > -1) {
                return this.flattenChapters[chapterIndex];
            }
            else {
                for (let index = 0; index < this.chapterDocList.length; index++) {
                    if (this.chapterDocList[index].text &&
                        this.chapterDocList[index].text.id &&
                        (this.chapterDocList[index].text.id + "").includes(path)) {
                        chapterIndex = index;
                        break;
                    }
                }
                if (chapterIndex > -1) {
                    return { label: "", href: "", index: chapterIndex };
                }
                else {
                    return null;
                }
            }
        }
    }
    flatChapter(chapters) {
        let newChapter = [];
        for (let i = 0; i < chapters.length; i++) {
            if (chapters[i].subitems && chapters[i].subitems.length > 0) {
                newChapter.push(chapters[i]);
                newChapter = newChapter.concat(this.flatChapter(chapters[i].subitems));
            }
            else {
                newChapter.push(chapters[i]);
            }
        }
        this.flattenChapters = newChapter;
        return newChapter;
    }
    getChapter() {
        return this.chapterList;
    }
    getChapterDoc() {
        return this.chapterDocList;
    }
    goToPercentage(percentage) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.flattenChapters.length > 0) {
                let chapterIndex = percentage === 1
                    ? this.flattenChapters.length - 1
                    : Math.floor(this.flattenChapters.length * percentage);
                yield this.goToChapter(this.flattenChapters[chapterIndex].index.toString(), this.flattenChapters[chapterIndex].href, this.flattenChapters[chapterIndex].label);
            }
        });
    }
    goToChapterIndex(targetChapterIndex) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.flattenChapters.length > 0) {
                yield this.goToChapter(this.flattenChapters[targetChapterIndex].index, this.flattenChapters[targetChapterIndex].href, this.flattenChapters[targetChapterIndex].label);
            }
        });
    }
    goToChapter(chapterDocIndex, chapterHref, chapterTitle) {
        return __awaiter(this, void 0, void 0, function* () {
            let doc = this.getDocument();
            let iframe = this.getIframe();
            if (!doc || !iframe)
                return;
            yield handleRenderChapter(parseInt(chapterDocIndex), chapterTitle, chapterHref, this.chapterDocList, this.element, this.readerMode, this.format, this.tempLocation, doc, iframe);
            if (chapterHref && chapterHref.indexOf("#") > -1) {
                yield handleScrollPosition(this.element, this.readerMode, "", "", chapterHref, "", doc);
            }
            yield this.record();
            this.trigger("rendered");
        });
    }
    goToPosition(bookLocationStr) {
        return __awaiter(this, void 0, void 0, function* () {
            let doc = this.getDocument();
            let iframe = this.getIframe();
            if (!doc || !iframe)
                return;
            let bookLocation = JSON.parse(bookLocationStr);
            this.tempLocation = {
                text: bookLocation.text,
                chapterTitle: bookLocation.chapterTitle,
                chapterDocIndex: bookLocation.chapterDocIndex,
                chapterHref: bookLocation.chapterHref,
                count: bookLocation.count,
                page: bookLocation.page,
            };
            let { text, chapterTitle, chapterDocIndex, chapterHref, count, page, cfi } = bookLocation;
            yield handleRenderChapter(parseInt(chapterDocIndex), chapterTitle, chapterHref, this.chapterDocList, this.element, this.readerMode, this.format, this.tempLocation, doc, iframe);
            if (cfi) {
                const cfiInfo = new CFI(cfi, {});
                let doc = this.getDocument();
                if (!doc) {
                    return;
                }
                const { node, offset } = cfiInfo.resolve(doc, {});
                if (node) {
                    let element = null;
                    let currentNode = node;
                    while (currentNode) {
                        const temp = currentNode;
                        if (temp.tagName &&
                            "h1,h2,h3,h4,h5,h6,p,div,ul,dl,ol,pre,blockquote,address".indexOf(temp.tagName.toLowerCase()) > -1) {
                            element = temp;
                            break;
                        }
                        currentNode = currentNode.parentNode;
                    }
                    if (element) {
                        count = "ignore";
                        text = element.textContent;
                    }
                }
            }
            yield handleScrollPosition(this.element, this.readerMode, text, count, "", page, doc);
            yield this.record();
            this.trigger("rendered");
            // this.addPageAnimation();
        });
    }
    getDocument() {
        let pageArea = document.getElementById("page-area");
        if (!pageArea)
            return null;
        let iframe = pageArea.getElementsByTagName("iframe")[0];
        if (!iframe)
            return null;
        let doc = iframe.contentDocument;
        if (!doc) {
            return null;
        }
        // if (this.format === "PDF") {
        //   let subIframe: any = doc.getElementById(
        //     "pdf-iframe-" + this.tempLocation.chapterDocIndex
        //   );
        //   if (subIframe) {
        //     doc = subIframe.contentDocument;
        //   }
        // }
        return doc;
    }
    getIframe() {
        let pageArea = document.getElementById("page-area");
        if (!pageArea)
            return null;
        let iframe = pageArea.getElementsByTagName("iframe")[0];
        if (!iframe)
            return null;
        // if (this.format === "PDF") {
        //   let doc = iframe.contentDocument;
        //   if (!doc) {
        //     return null;
        //   }
        //   iframe = doc.getElementById(
        //     "pdf-iframe-" + this.tempLocation.chapterDocIndex
        //   ) as any;
        // }
        return iframe;
    }
    goToNode(node) {
        return __awaiter(this, void 0, void 0, function* () {
            let doc = this.getDocument();
            if (!doc) {
                return;
            }
            let targetNode = getCloestBlock(node, this.element, this.readerMode);
            let left = targetNode
                ? convertStyleNum(targetNode.offsetLeft) -
                    convertStyleNum(targetNode.marginLeft ||
                        parseFloat(getComputedStyle(targetNode).marginLeft))
                : 0;
            let top = targetNode
                ? convertStyleNum(targetNode.offsetTop) -
                    convertStyleNum(targetNode.marginTop ||
                        parseFloat(getComputedStyle(targetNode).marginTop))
                : 0;
            if (this.readerMode !== "scroll") {
                doc.body.scrollTo(left, 0);
            }
            else {
                this.element.scrollTo(0, top);
            }
            yield this.record();
            this.trigger("rendered");
        });
    }
    removeContent() {
        this.element.innerHTML = "";
    }
    prev() {
        return __awaiter(this, void 0, void 0, function* () {
            // this.trigger("page-changed");
            let doc = this.getDocument();
            let iframe = this.getIframe();
            if (!doc || !iframe) {
                return;
            }
            if ((this.readerMode === "scroll" &&
                convertStyleNum(this.element.scrollTop) === 0) ||
                (this.readerMode !== "scroll" &&
                    convertStyleNum(doc.body.scrollLeft) === 0)) {
                if (this.tempLocation.chapterDocIndex === "0") {
                    return;
                }
                yield handlePrevChapter(this.element, this.flatChapter(this.chapterList), this.chapterDocList, this.readerMode, this.format, this.tempLocation, doc, iframe);
                let chapterDocIndex = parseInt(this.tempLocation.chapterDocIndex || "-1");
                if (chapterDocIndex > -1) {
                    if (this.readerMode === "scroll") {
                        this.element.scrollTo(0, doc.body.scrollHeight);
                    }
                    else {
                        doc.body.scrollTo(doc.body.scrollWidth, 0);
                    }
                }
                this.trigger("rendered");
            }
            else if (this.readerMode === "scroll") {
                // scroll readerMode under normal condition
                this.element.scrollBy({
                    left: 0,
                    top: -(this.element.clientHeight - 50),
                    behavior: "smooth",
                });
            }
            else {
                yield handleScrollPage(this.element, this.animation, 1, doc, this.flipToNextPage, this.flipToPrevPage, this.isMobile);
            }
            yield this.record();
        });
    }
    next() {
        return __awaiter(this, void 0, void 0, function* () {
            // this.trigger("page-changed");
            let doc = this.getDocument();
            let iframe = this.getIframe();
            if (!doc || !iframe) {
                return;
            }
            if ((Math.abs(doc.body.scrollWidth -
                convertStyleNum(doc.body.scrollLeft) -
                doc.body.clientWidth) < 10 &&
                this.readerMode !== "scroll") ||
                (Math.abs(this.element.scrollHeight -
                    convertStyleNum(this.element.scrollTop) -
                    this.element.clientHeight) < 10 &&
                    this.readerMode === "scroll")) {
                // if the last page
                yield handleNextChapter(this.element, this.flatChapter(this.chapterList), this.chapterDocList, this.readerMode, this.format, this.tempLocation, doc, iframe);
                this.trigger("rendered");
            }
            else if (this.readerMode === "scroll") {
                // scroll readerMode under normal condition
                this.element.scrollBy({
                    left: 0,
                    top: this.element.clientHeight - 50,
                    behavior: "smooth",
                });
            }
            else {
                // single and double readerMode under normal condition
                yield handleScrollPage(this.element, this.animation, -1, doc, this.flipToNextPage, this.flipToPrevPage, this.isMobile);
            }
            yield this.record();
        });
    }
    prevChapter() {
        return __awaiter(this, void 0, void 0, function* () {
            // this.trigger("page-changed");
            let doc = this.getDocument();
            let iframe = this.getIframe();
            if (!doc || !iframe)
                return;
            yield handlePrevChapter(this.element, this.flatChapter(this.chapterList), this.chapterDocList, this.readerMode, this.format, this.tempLocation, doc, iframe);
            yield this.record();
            this.trigger("rendered");
        });
    }
    nextChapter() {
        return __awaiter(this, void 0, void 0, function* () {
            // this.trigger("page-changed");
            let doc = this.getDocument();
            let iframe = this.getIframe();
            if (!doc || !iframe)
                return;
            yield handleNextChapter(this.element, this.flatChapter(this.chapterList), this.chapterDocList, this.readerMode, this.format, this.tempLocation, doc, iframe);
            yield this.record();
            this.trigger("rendered");
        });
    }
    visibleText() {
        let doc = this.getDocument();
        if (!doc)
            return "";
        return getVisibleText(this.element, this.readerMode, doc);
    }
    audioText() {
        let doc = this.getDocument();
        if (!doc)
            return "";
        return getAudioText(this.element, this.readerMode, doc);
    }
    chapterText() {
        let doc = this.getDocument();
        if (!doc)
            return "";
        return doc.body.innerText;
    }
    highlightNode(text, style) {
        let doc = this.getDocument();
        if (!doc)
            return;
        handleHighlightNode(text, style, doc);
    }
    doSearch(keyword) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield getSearchResult(keyword, this.chapterDocList);
        });
    }
    getProgress() {
        let doc = this.getDocument();
        if (!doc)
            return;
        return progressInfo(this.readerMode, doc);
    }
    record() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.animation !== "") {
                yield new Promise((r) => setTimeout(r, 1000));
            }
            let doc = this.getDocument();
            if (!doc)
                return;
            yield handleRecord(this.element, this.readerMode, this.flatChapter(this.chapterList), this.chapterDocList, this.tempLocation, doc, null);
            this.trigger("page-changed");
        });
    }
    getPosition() {
        return this.tempLocation;
    }
    getNotePosition() {
        return __awaiter(this, void 0, void 0, function* () {
            let doc = this.getDocument();
            if (!doc)
                return;
            let selectedElement = getSelectedElement(doc);
            if (!selectedElement)
                return;
            yield handleRecord(this.element, this.readerMode, this.flatChapter(this.chapterList), this.chapterDocList, this.tempLocation, doc, selectedElement);
            return this.tempLocation;
        });
    }
    setStyle(css) {
        let doc = this.getDocument();
        if (!doc)
            return;
        var defaultStyle = document.createElement("style");
        defaultStyle.innerHTML = css;
        doc.head.appendChild(defaultStyle);
    }
    getHightlightCoords() {
        return __awaiter(this, void 0, void 0, function* () {
            rangy.init();
            let doc = this.getDocument();
            let iframe = this.getIframe();
            if (!doc || !iframe)
                return;
            let charRange = rangy.getSelection(iframe).saveCharacterRanges(doc.body)[0];
            return charRange;
        });
    }
    renderHighlighters(notes, handleNoteClick) {
        return __awaiter(this, void 0, void 0, function* () {
            let doc = this.getDocument();
            let iframe = this.getIframe();
            if (!doc || !iframe)
                return;
            clearHighlight(doc);
            for (let index = 0; index < notes.length; index++) {
                const item = notes[index];
                try {
                    showNoteHighlight(JSON.parse(item.range), item.color, item.key, handleNoteClick, doc, iframe);
                    // highlighter.highlightSelection(classes[item.color]);
                }
                catch (e) {
                    console.error(e, "Exception has been caught when restore character ranges.");
                    return;
                }
            }
        });
    }
    removeOneNote(key) {
        let doc = this.getDocument();
        if (!doc)
            return;
        const elements = doc.querySelectorAll(".kookit-note");
        for (let index = 0; index < elements.length; index++) {
            const element = elements[index];
            const dataKey = element.getAttribute("data-key");
            if (dataKey === key) {
                element.parentNode.removeChild(element);
            }
        }
    }
    createOneNote(item, handleNoteClick) {
        return __awaiter(this, void 0, void 0, function* () {
            let doc = this.getDocument();
            let iframe = this.getIframe();
            if (!doc || !iframe)
                return;
            showNoteHighlight(JSON.parse(item.range), item.color, item.key, handleNoteClick, doc, iframe);
        });
    }
    displayFontBase64(fontName, fontBase64, fontFormat, fontType) {
        return __awaiter(this, void 0, void 0, function* () {
            let doc = this.getDocument();
            if (!doc || fontBase64.length === 0)
                return;
            const font = new FontFace(fontName, `url(data:font/${fontType};charset=utf-8;base64,${fontBase64})`);
            let loadedFont = yield font.load();
            // 将加载的字体添加到文档的字体集合中
            document.fonts.add(loadedFont);
            const fontFaceCSS = "@font-face {" +
                "  font-family: '" +
                fontName +
                "';" +
                "  src: url('data:font/" +
                fontType +
                ";charset=utf-8;base64," +
                fontBase64 +
                "') format('" +
                fontFormat +
                "');" +
                "}";
            const styleElement = document.createElement("style");
            styleElement.type = "text/css";
            styleElement.appendChild(document.createTextNode(fontFaceCSS));
            doc.head.appendChild(styleElement);
        });
    }
    displayFontUrl(fontName, fontUrl) {
        return __awaiter(this, void 0, void 0, function* () {
            let doc = this.getDocument();
            if (!doc)
                return;
            // 使用 FontFace API 创建字体
            const font = new FontFace(fontName, `url(${fontUrl})`);
            // 加载字体并监听加载完成事件
            let loadedFont = yield font.load();
            // 将加载的字体添加到文档的字体集合中
            document.fonts.add(loadedFont);
            const fontFaceCSS = "@font-face {" +
                "  font-family: '" +
                fontName +
                "';" +
                "  src: url('" +
                fontUrl +
                "') format('truetype');" +
                "}";
            const styleElement = document.createElement("style");
            styleElement.type = "text/css";
            styleElement.appendChild(document.createTextNode(fontFaceCSS));
            doc.head.appendChild(styleElement);
        });
    }
    addTouchEvent(isAndroid) {
        let doc = this.getDocument();
        let iframe = this.getIframe();
        if (!doc || !iframe)
            return;
        if (isAndroid === "yes") {
            addAndroidTouchEvent(doc, iframe, this.element, this.readerMode, this.animation, this);
        }
        else {
            addAppleTouchEvent(doc, iframe, this.element, this.readerMode, this.animation, this);
        }
    }
    clearSelection() {
        var _a, _b;
        let iframe = this.getIframe();
        if (!iframe)
            return;
        let iWin = iframe.contentWindow || ((_a = iframe.contentDocument) === null || _a === void 0 ? void 0 : _a.defaultView);
        if (!iWin || !iWin.getSelection())
            return;
        (_b = iWin.getSelection()) === null || _b === void 0 ? void 0 : _b.empty();
    }
    clearSelectionKeepHighlight() {
        var _a, _b;
        let doc = this.getDocument();
        let iframe = this.getIframe();
        if (!doc || !iframe)
            return;
        let iWin = iframe.contentWindow || ((_a = iframe.contentDocument) === null || _a === void 0 ? void 0 : _a.defaultView);
        if (!iWin || !iWin.getSelection())
            return;
        let sel = doc.getSelection();
        if (!sel)
            return;
        let newRange = sel.getRangeAt(0);
        var safeRanges = getSafeRanges(newRange);
        for (var i = 0; i < safeRanges.length; i++) {
            const rects = filterRects(safeRanges[i].getClientRects());
            for (let index = 0; index < rects.length; index++) {
                const rect = rects[index];
                let newNode = document.createElement("span");
                newNode === null || newNode === void 0 ? void 0 : newNode.setAttribute("style", "position: absolute; background-color: #f3a6a68c;left:" +
                    (Math.min(rect.left, rect.x) + doc.body.scrollLeft) +
                    "px; top:" +
                    (Math.min(rect.top, rect.y) + doc.body.scrollTop) +
                    "px;" +
                    "width:" +
                    rect.width +
                    "px; height:" +
                    rect.height +
                    "px; z-index:-1;");
                newNode.setAttribute("id", "temp-highlight");
                doc.body.appendChild(newNode);
            }
        }
        let charRange = rangy.getSelection(iframe).saveCharacterRanges(doc.body)[0];
        window.charRange = charRange;
        (_b = iWin.getSelection()) === null || _b === void 0 ? void 0 : _b.removeAllRanges();
    }
    restoreSelectionClearHighlight() {
        let doc = this.getDocument();
        if (!doc)
            return;
        let tempHighlights = doc.querySelectorAll("#temp-highlight");
        tempHighlights.forEach((element) => {
            var _a;
            (_a = element.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(element);
        });
        let iframe = this.getIframe();
        if (!iframe)
            return;
        rangy.init();
        let charRange = window.charRange;
        if (!charRange)
            return;
        rangy.getSelection(iframe).restoreCharacterRanges(doc, [charRange]);
    }
}

const mimetype = {
    svg: "image/svg+xml",
    png: "image/png",
    jpg: "image/jpeg",
    jpeg: "image/jpeg",
    gif: "image/gif",
    webp: "image/webp",
    zip: "application/zip",
    rar: "application/x-rar-compressed",
    "7z": "application/x-7z-compressed",
    tar: "application/x-tar",
    html: "text/html",
    htm: "text/html",
    xml: "text/xml",
    xhtml: "application/xhtml+xml",
    css: "text/css",
};
const mimetypeReverse = {
    "image/svg+xml": "svg",
    "image/png": "png",
    "image/jpeg": "jpg",
    "image/gif": "gif",
    "image/webp": "webp",
    "application/zip": "zip",
    "application/x-rar-compressed": "rar",
    "application/x-7z-compressed": "7z",
    "application/x-tar": "tar",
    "text/html": "html",
    "text/xml": "xml",
    "application/xhtml+xml": "xhtml",
    "text/css": "css",
};

const makeCacheBook = (bookBuffer) => __awaiter(void 0, void 0, void 0, function* () {
    let zip = yield JSZip.loadAsync(bookBuffer);
    var tocZip = zip.file("toc.json");
    let toc = [];
    if (tocZip) {
        toc = JSON.parse(yield tocZip.async("string"));
    }
    var sectionsZip = zip.file("sections.json");
    let sections = [];
    if (sectionsZip) {
        sections = JSON.parse(yield sectionsZip.async("string"));
    }
    const load = (index) => __awaiter(void 0, void 0, void 0, function* () {
        var chapterZip = zip.file("chapters/" + index + ".html");
        let chapter = "";
        if (chapterZip) {
            chapter = yield chapterZip.async("string");
        }
        return URL.createObjectURL(new Blob([chapter], { type: "text/html" }));
    });
    const unload = (index) => { };
    const book = {};
    book.getCover = () => "";
    const loadAsset = (url) => __awaiter(void 0, void 0, void 0, function* () {
        var assetZip = zip.file(url);
        let asset;
        if (assetZip) {
            asset = yield assetZip.async("arraybuffer");
        }
        return URL.createObjectURL(new Blob([asset], { type: mimetype[url.split(".").reverse()[0]] }));
    });
    book.sections = sections.map((item, index) => ({
        id: item.href,
        load: () => load(index),
        unload: () => unload(),
        loadAsset: (url) => loadAsset(url),
    }));
    book.toc = toc.map((item) => ({
        label: item.label,
        href: item.href,
        subitems: item.subitems,
    }));
    book.rendition = { layout: "pre-paginated" };
    book.resolveHref = (href) => {
        return { index: _.findLastIndex(sections, { href }) };
    };
    book.splitTOCHref = (href) => [href, null];
    book.getTOCFragment = (doc) => doc.documentElement;
    return book;
});
const getCache = (book) => {
    return new Promise((resolve, reject) => __awaiter(void 0, void 0, void 0, function* () {
        let parser = new GeneralParser(book);
        let chapterList = yield parser.getChapter(book.toc);
        let chapterDocList = yield parser.getChapterDoc();
        let toc = chapterList;
        let sections = chapterDocList.map((item) => {
            return { href: item.href, label: item.label };
        });
        let chapterTexts = yield Promise.all(chapterDocList.map((item) => __awaiter(void 0, void 0, void 0, function* () {
            let chapterText = "";
            if (item.text.load) {
                let blob = yield fetch(yield item.text.load()).then((r) => r.blob());
                chapterText = yield blob.text();
            }
            return chapterText;
        })));
        let zip = new JSZip();
        zip.file("toc.json", JSON.stringify(toc));
        zip.file("sections.json", JSON.stringify(sections));
        let chapters = [];
        //todo get css, fonts and images blob
        for (let index = 0; index < chapterTexts.length; index++) {
            let chapterDoc = new DOMParser().parseFromString(chapterTexts[index], "text/html");
            let imgDomList = getImageElement(chapterDoc);
            for (let subindex = 0; subindex < imgDomList.length; subindex++) {
                let subImgZip = zip.folder("imgs/" + index);
                if (!subImgZip) {
                    break;
                }
                let imageUrl = imgDomList[subindex].getAttribute("src") ||
                    imgDomList[subindex].getAttribute("xlink:href");
                if (imageUrl) {
                    try {
                        let blob = yield fetch(yield imageUrl).then((r) => r.blob());
                        subImgZip.file(subindex + "." + mimetypeReverse[blob.type], blob);
                        let newUrl = "imgs/" +
                            index +
                            "/" +
                            subindex +
                            "." +
                            mimetypeReverse[blob.type];
                        imgDomList[subindex].src = newUrl;
                        if (imgDomList[subindex].getAttribute("xlink:href")) {
                            imgDomList[subindex].setAttribute("xlink:href", newUrl);
                        }
                    }
                    catch (error) {
                        console.error(error);
                    }
                }
            }
            let linkList = Array.from(chapterDoc.getElementsByTagName("link"));
            for (let subindex = 0; subindex < linkList.length; subindex++) {
                let link = linkList[subindex];
                let subCssZip = zip.folder("css/" + index);
                if (!subCssZip) {
                    break;
                }
                if (link.getAttribute("href")) {
                    try {
                        let blob = yield fetch(yield link.getAttribute("href")).then((r) => r.blob());
                        subCssZip.file(subindex + "." + mimetypeReverse[blob.type], blob);
                        link.href =
                            "css/" +
                                index +
                                "/" +
                                subindex +
                                "." +
                                mimetypeReverse[blob.type];
                    }
                    catch (error) {
                        console.error(error);
                    }
                }
            }
            chapters.push(chapterDoc.documentElement.innerHTML);
        }
        let configZip = zip.folder("chapters");
        if (!configZip) {
            return;
        }
        for (let index = 0; index < chapters.length; index++) {
            configZip.file(index + ".html", chapters[index]);
        }
        zip
            .generateAsync({ type: "blob" })
            .then((blob) => __awaiter(void 0, void 0, void 0, function* () {
            resolve(yield new Response(blob).arrayBuffer());
        }))
            .catch((err) => {
            resolve("err");
        });
    }));
};

class EpubRender extends GeneralRender {
    constructor(epubBuffer, config) {
        super(Object.assign({ format: "EPUB" }, config));
        this.epubBuffer = epubBuffer;
    }
    renderTo(element) {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            this.element = element;
            if (!this.book) {
                yield this.parse();
            }
            let parser = new GeneralParser(this.book);
            this.chapterList = yield parser.getChapter(this.book.toc);
            this.chapterDocList = yield parser.getChapterDoc();
            createIframe(element);
            let doc = this.getDocument();
            if (!doc)
                return;
            handleLayout(element, this.readerMode, doc);
            resolve();
        }));
    }
    parse() {
        return __awaiter(this, void 0, void 0, function* () {
            let blob = new Blob([this.epubBuffer]);
            let file = new File([blob], "book", {
                lastModified: new Date().getTime(),
                type: blob.type,
            });
            try {
                const loader = yield this.makeZipLoader(file);
                this.book = yield new EPUB(loader).init();
            }
            catch (error) {
                console.error(error);
                throw error;
            }
        });
    }
    preCache() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                if (!this.book) {
                    yield this.parse();
                }
                return yield getCache(this.book);
            }
            catch (error) {
                return "";
            }
        });
    }
    makeZipLoader(file) {
        return __awaiter(this, void 0, void 0, function* () {
            let zip = yield JSZip.loadAsync(file);
            const entries = zip.files;
            const loadText = (name) => __awaiter(this, void 0, void 0, function* () {
                let entry = zip.file(name);
                if (entry) {
                    return entry.async("string");
                }
                return "";
            });
            const loadBlob = (name) => __awaiter(this, void 0, void 0, function* () {
                let entry = zip.file(name);
                if (entry) {
                    let buffer = yield entry.async("arraybuffer");
                    return new Blob([buffer]);
                }
                return new Blob([new ArrayBuffer(0)]);
            });
            const getSize = (name) => {
                return 0;
            };
            return {
                entries: Object.values(entries).map((item) => {
                    return { filename: item.name };
                }),
                loadText,
                loadBlob,
                getSize,
            };
        });
    }
    getMetadata() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                if (!this.book) {
                    yield this.parse();
                }
                let parser = new GeneralParser(this.book);
                return yield parser.getMetadata();
            }
            catch (error) {
                console.error(error, "error");
                throw error;
            }
        });
    }
}

const unescapeHTML = (str) => {
  if (!str) return "";
  const textarea = document.createElement("textarea");
  textarea.innerHTML = str;
  return textarea.value;
};

const MIME$1 = {
  XML: "application/xml",
  XHTML: "application/xhtml+xml",
  HTML: "text/html",
  CSS: "text/css",
  SVG: "image/svg+xml",
};

const PDB_HEADER = {
  name: [0, 32, "string"],
  type: [60, 4, "string"],
  creator: [64, 4, "string"],
  numRecords: [76, 2, "uint"],
};

const PALMDOC_HEADER = {
  compression: [0, 2, "uint"],
  numTextRecords: [8, 2, "uint"],
  recordSize: [10, 2, "uint"],
  encryption: [12, 2, "uint"],
};

const MOBI_HEADER = {
  magic: [16, 4, "string"],
  length: [20, 4, "uint"],
  type: [24, 4, "uint"],
  encoding: [28, 4, "uint"],
  uid: [32, 4, "uint"],
  version: [36, 4, "uint"],
  titleOffset: [84, 4, "uint"],
  titleLength: [88, 4, "uint"],
  localeRegion: [94, 1, "uint"],
  localeLanguage: [95, 1, "uint"],
  resourceStart: [108, 4, "uint"],
  huffcdic: [112, 4, "uint"],
  numHuffcdic: [116, 4, "uint"],
  exthFlag: [128, 4, "uint"],
  trailingFlags: [240, 4, "uint"],
  indx: [244, 4, "uint"],
};

const KF8_HEADER = {
  resourceStart: [108, 4, "uint"],
  fdst: [192, 4, "uint"],
  numFdst: [196, 4, "uint"],
  frag: [248, 4, "uint"],
  skel: [252, 4, "uint"],
  guide: [260, 4, "uint"],
};

const EXTH_HEADER = {
  magic: [0, 4, "string"],
  length: [4, 4, "uint"],
  count: [8, 4, "uint"],
};

const INDX_HEADER = {
  magic: [0, 4, "string"],
  length: [4, 4, "uint"],
  type: [8, 4, "uint"],
  idxt: [20, 4, "uint"],
  numRecords: [24, 4, "uint"],
  encoding: [28, 4, "uint"],
  language: [32, 4, "uint"],
  total: [36, 4, "uint"],
  ordt: [40, 4, "uint"],
  ligt: [44, 4, "uint"],
  numLigt: [48, 4, "uint"],
  numCncx: [52, 4, "uint"],
};

const TAGX_HEADER = {
  magic: [0, 4, "string"],
  length: [4, 4, "uint"],
  numControlBytes: [8, 4, "uint"],
};

const HUFF_HEADER = {
  magic: [0, 4, "string"],
  offset1: [8, 4, "uint"],
  offset2: [12, 4, "uint"],
};

const CDIC_HEADER = {
  magic: [0, 4, "string"],
  length: [4, 4, "uint"],
  numEntries: [8, 4, "uint"],
  codeLength: [12, 4, "uint"],
};

const FDST_HEADER = {
  magic: [0, 4, "string"],
  numEntries: [8, 4, "uint"],
};

const FONT_HEADER = {
  flags: [8, 4, "uint"],
  dataStart: [12, 4, "uint"],
  keyLength: [16, 4, "uint"],
  keyStart: [20, 4, "uint"],
};

const MOBI_ENCODING = {
  1252: "windows-1252",
  65001: "utf-8",
};

const EXTH_RECORD_TYPE = {
  100: ["creator", "string", true],
  101: ["publisher"],
  103: ["description"],
  104: ["isbn"],
  105: ["subject", "string", true],
  106: ["date"],
  108: ["contributor", "string", true],
  109: ["rights"],
  110: ["subjectCode", "string", true],
  112: ["source", "string", true],
  113: ["asin"],
  121: ["boundary", "uint"],
  122: ["fixedLayout"],
  125: ["numResources", "uint"],
  126: ["originalResolution"],
  127: ["zeroGutter"],
  128: ["zeroMargin"],
  129: ["coverURI"],
  132: ["regionMagnification"],
  201: ["coverOffset", "uint"],
  202: ["thumbnailOffset", "uint"],
  503: ["title"],
  524: ["language", "string", true],
  527: ["pageProgressionDirection"],
};

const MOBI_LANG = {
  1: [
    "ar",
    "ar-SA",
    "ar-IQ",
    "ar-EG",
    "ar-LY",
    "ar-DZ",
    "ar-MA",
    "ar-TN",
    "ar-OM",
    "ar-YE",
    "ar-SY",
    "ar-JO",
    "ar-LB",
    "ar-KW",
    "ar-AE",
    "ar-BH",
    "ar-QA",
  ],
  2: ["bg"],
  3: ["ca"],
  4: ["zh", "zh-TW", "zh-CN", "zh-HK", "zh-SG"],
  5: ["cs"],
  6: ["da"],
  7: ["de", "de-DE", "de-CH", "de-AT", "de-LU", "de-LI"],
  8: ["el"],
  9: [
    "en",
    "en-US",
    "en-GB",
    "en-AU",
    "en-CA",
    "en-NZ",
    "en-IE",
    "en-ZA",
    "en-JM",
    null,
    "en-BZ",
    "en-TT",
    "en-ZW",
    "en-PH",
  ],
  10: [
    "es",
    "es-ES",
    "es-MX",
    null,
    "es-GT",
    "es-CR",
    "es-PA",
    "es-DO",
    "es-VE",
    "es-CO",
    "es-PE",
    "es-AR",
    "es-EC",
    "es-CL",
    "es-UY",
    "es-PY",
    "es-BO",
    "es-SV",
    "es-HN",
    "es-NI",
    "es-PR",
  ],
  11: ["fi"],
  12: ["fr", "fr-FR", "fr-BE", "fr-CA", "fr-CH", "fr-LU", "fr-MC"],
  13: ["he"],
  14: ["hu"],
  15: ["is"],
  16: ["it", "it-IT", "it-CH"],
  17: ["ja"],
  18: ["ko"],
  19: ["nl", "nl-NL", "nl-BE"],
  20: ["no", "nb", "nn"],
  21: ["pl"],
  22: ["pt", "pt-BR", "pt-PT"],
  23: ["rm"],
  24: ["ro"],
  25: ["ru"],
  26: ["hr", null, "sr"],
  27: ["sk"],
  28: ["sq"],
  29: ["sv", "sv-SE", "sv-FI"],
  30: ["th"],
  31: ["tr"],
  32: ["ur"],
  33: ["id"],
  34: ["uk"],
  35: ["be"],
  36: ["sl"],
  37: ["et"],
  38: ["lv"],
  39: ["lt"],
  41: ["fa"],
  42: ["vi"],
  43: ["hy"],
  44: ["az"],
  45: ["eu"],
  46: ["hsb"],
  47: ["mk"],
  48: ["st"],
  49: ["ts"],
  50: ["tn"],
  52: ["xh"],
  53: ["zu"],
  54: ["af"],
  55: ["ka"],
  56: ["fo"],
  57: ["hi"],
  58: ["mt"],
  59: ["se"],
  62: ["ms"],
  63: ["kk"],
  65: ["sw"],
  67: ["uz", null, "uz-UZ"],
  68: ["tt"],
  69: ["bn"],
  70: ["pa"],
  71: ["gu"],
  72: ["or"],
  73: ["ta"],
  74: ["te"],
  75: ["kn"],
  76: ["ml"],
  77: ["as"],
  78: ["mr"],
  79: ["sa"],
  82: ["cy", "cy-GB"],
  83: ["gl", "gl-ES"],
  87: ["kok"],
  97: ["ne"],
  98: ["fy"],
};

const concatTypedArray = (a, b) => {
  const result = new a.constructor(a.length + b.length);
  result.set(a);
  result.set(b, a.length);
  return result;
};
const concatTypedArray3 = (a, b, c) => {
  const result = new a.constructor(a.length + b.length + c.length);
  result.set(a);
  result.set(b, a.length);
  result.set(c, a.length + b.length);
  return result;
};

const decoder = new TextDecoder();
const getString = (buffer) => decoder.decode(buffer);
const getUint = (buffer) => {
  if (!buffer) return;
  const l = buffer.byteLength;
  const func = l === 4 ? "getUint32" : l === 2 ? "getUint16" : "getUint8";
  return new DataView(buffer)[func](0);
};
const getStruct = (def, buffer) =>
  Object.fromEntries(
    Array.from(Object.entries(def)).map(([key, [start, len, type]]) => [
      key,
      (type === "string" ? getString : getUint)(
        buffer.slice(start, start + len)
      ),
    ])
  );

const getDecoder = (x) => new TextDecoder(MOBI_ENCODING[x]);

const getVarLen = (byteArray, i = 0) => {
  let value = 0,
    length = 0;
  for (const byte of byteArray.subarray(i, i + 4)) {
    value = (value << 7) | ((byte & 0b111_1111) >>> 0);
    length++;
    if (byte & 0b1000_0000) break;
  }
  return { value, length };
};

// variable-length quantity, but read from the end of data
const getVarLenFromEnd = (byteArray) => {
  let value = 0;
  for (const byte of byteArray.subarray(-4)) {
    // `byte & 0b1000_0000` indicates the start of value
    if (byte & 0b1000_0000) value = 0;
    value = (value << 7) | (byte & 0b111_1111);
  }
  return value;
};

const countBitsSet = (x) => {
  let count = 0;
  for (; x > 0; x = x >> 1) if ((x & 1) === 1) count++;
  return count;
};

const countUnsetEnd = (x) => {
  let count = 0;
  while ((x & 1) === 0) (x = x >> 1), count++;
  return count;
};

const decompressPalmDOC = (array) => {
  let output = [];
  for (let i = 0; i < array.length; i++) {
    const byte = array[i];
    if (byte === 0) output.push(0); // uncompressed literal, just copy it
    else if (byte <= 8)
      // copy next 1-8 bytes
      for (const x of array.subarray(i + 1, (i += byte) + 1)) output.push(x);
    else if (byte <= 0b0111_1111) output.push(byte); // uncompressed literal
    else if (byte <= 0b1011_1111) {
      // 1st and 2nd bits are 10, meaning this is a length-distance pair
      // read next byte and combine it with current byte
      const bytes = (byte << 8) | array[i++ + 1];
      // the 3rd to 13th bits encode distance
      const distance = (bytes & 0b0011_1111_1111_1111) >>> 3;
      // the last 3 bits, plus 3, is the length to copy
      const length = (bytes & 0b111) + 3;
      for (let j = 0; j < length; j++)
        output.push(output[output.length - distance]);
    }
    // compressed from space plus char
    else output.push(32, byte ^ 0b1000_0000);
  }
  return Uint8Array.from(output);
};

const read32Bits = (byteArray, from) => {
  const startByte = from >> 3;
  const end = from + 32;
  const endByte = end >> 3;
  let bits = 0n;
  for (let i = startByte; i <= endByte; i++)
    bits = (bits << 8n) | BigInt(byteArray[i] ?? 0);
  return (bits >> (8n - BigInt(end & 7))) & 0xffffffffn;
};

const huffcdic = async (mobi, loadRecord) => {
  const huffRecord = await loadRecord(mobi.huffcdic);
  const { magic, offset1, offset2 } = getStruct(HUFF_HEADER, huffRecord);
  if (magic !== "HUFF") throw new Error("Invalid HUFF record");

  // table1 is indexed by byte value
  const table1 = Array.from({ length: 256 }, (_, i) => offset1 + i * 4)
    .map((offset) => getUint(huffRecord.slice(offset, offset + 4)))
    .map((x) => [x & 0b1000_0000, x & 0b1_1111, x >>> 8]);

  // table2 is indexed by code length
  const table2 = [null].concat(
    Array.from({ length: 32 }, (_, i) => offset2 + i * 8).map((offset) => [
      getUint(huffRecord.slice(offset, offset + 4)),
      getUint(huffRecord.slice(offset + 4, offset + 8)),
    ])
  );

  const dictionary = [];
  for (let i = 1; i < mobi.numHuffcdic; i++) {
    const record = await loadRecord(mobi.huffcdic + i);
    const cdic = getStruct(CDIC_HEADER, record);
    if (cdic.magic !== "CDIC") throw new Error("Invalid CDIC record");
    // `numEntries` is the total number of dictionary data across CDIC records
    // so `n` here is the number of entries in *this* record
    const n = Math.min(
      1 << cdic.codeLength,
      cdic.numEntries - dictionary.length
    );
    const buffer = record.slice(cdic.length);
    for (let i = 0; i < n; i++) {
      const offset = getUint(buffer.slice(i * 2, i * 2 + 2));
      const x = getUint(buffer.slice(offset, offset + 2));
      const length = x & 0x7fff;
      const decompressed = x & 0x8000;
      const value = new Uint8Array(
        buffer.slice(offset + 2, offset + 2 + length)
      );
      dictionary.push([value, decompressed]);
    }
  }

  const decompress = (byteArray) => {
    let output = new Uint8Array();
    const bitLength = byteArray.byteLength * 8;
    for (let i = 0; i < bitLength;) {
      const bits = Number(read32Bits(byteArray, i));
      let [found, codeLength, value] = table1[bits >>> 24];
      if (!found) {
        while (bits >>> (32 - codeLength) < table2[codeLength][0])
          codeLength += 1;
        value = table2[codeLength][1];
      }
      if ((i += codeLength) > bitLength) break;

      const code = value - (bits >>> (32 - codeLength));
      let [result, decompressed] = dictionary[code];
      if (!decompressed) {
        // the result is itself compressed
        result = decompress(result);
        // cache the result for next time
        dictionary[code] = [result, true];
      }
      output = concatTypedArray(output, result);
    }
    return output;
  };
  return decompress;
};

const getIndexData = async (indxIndex, loadRecord) => {
  const indxRecord = await loadRecord(indxIndex);
  const indx = getStruct(INDX_HEADER, indxRecord);
  if (indx.magic !== "INDX") throw new Error("Invalid INDX record");
  const decoder = getDecoder(indx.encoding);

  const tagxBuffer = indxRecord.slice(indx.length);
  const tagx = getStruct(TAGX_HEADER, tagxBuffer);
  if (tagx.magic !== "TAGX") throw new Error("Invalid TAGX section");
  const numTags = (tagx.length - 12) / 4;
  const tagTable = Array.from(
    { length: numTags },
    (_, i) => new Uint8Array(tagxBuffer.slice(12 + i * 4, 12 + i * 4 + 4))
  );

  const cncx = {};
  let cncxRecordOffset = 0;
  for (let i = 0; i < indx.numCncx; i++) {
    const record = await loadRecord(indxIndex + indx.numRecords + i + 1);
    const array = new Uint8Array(record);
    for (let pos = 0; pos < array.byteLength;) {
      const index = pos;
      const { value, length } = getVarLen(array, pos);
      pos += length;
      const result = record.slice(pos, pos + value);
      pos += value;
      cncx[cncxRecordOffset + index] = decoder.decode(result);
    }
    cncxRecordOffset += 0x10000;
  }

  const table = [];
  for (let i = 0; i < indx.numRecords; i++) {
    const record = await loadRecord(indxIndex + 1 + i);
    const array = new Uint8Array(record);
    const indx = getStruct(INDX_HEADER, record);
    if (indx.magic !== "INDX") throw new Error("Invalid INDX record");
    for (let j = 0; j < indx.numRecords; j++) {
      const offsetOffset = indx.idxt + 4 + 2 * j;
      const offset = getUint(record.slice(offsetOffset, offsetOffset + 2));

      const length = getUint(record.slice(offset, offset + 1));
      const name = getString(record.slice(offset + 1, offset + 1 + length));

      const tags = [];
      const startPos = offset + 1 + length;
      let controlByteIndex = 0;
      let pos = startPos + tagx.numControlBytes;
      for (const [tag, numValues, mask, end] of tagTable) {
        if (end & 1) {
          controlByteIndex++;
          continue;
        }
        const offset = startPos + controlByteIndex;
        const value = getUint(record.slice(offset, offset + 1)) & mask;
        if (value === mask) {
          if (countBitsSet(mask) > 1) {
            const { value, length } = getVarLen(array, pos);
            tags.push([tag, null, value, numValues]);
            pos += length;
          } else tags.push([tag, 1, null, numValues]);
        } else tags.push([tag, value >> countUnsetEnd(mask), null, numValues]);
      }

      const tagMap = {};
      for (const [tag, valueCount, valueBytes, numValues] of tags) {
        const values = [];
        if (valueCount != null) {
          for (let i = 0; i < valueCount * numValues; i++) {
            const { value, length } = getVarLen(array, pos);
            values.push(value);
            pos += length;
          }
        } else {
          let count = 0;
          while (count < valueBytes) {
            const { value, length } = getVarLen(array, pos);
            values.push(value);
            pos += length;
            count += length;
          }
        }
        tagMap[tag] = values;
      }
      table.push({ name, tagMap });
    }
  }
  return { table, cncx };
};

const getNCX = async (indxIndex, loadRecord) => {
  const { table, cncx } = await getIndexData(indxIndex, loadRecord);
  const items = table.map(({ tagMap }, index) => ({
    index,
    offset: tagMap[1]?.[0],
    size: tagMap[2]?.[0],
    label: cncx[tagMap[3]] ?? "",
    headingLevel: tagMap[4]?.[0],
    pos: tagMap[6],
    parent: tagMap[21]?.[0],
    firstChild: tagMap[22]?.[0],
    lastChild: tagMap[23]?.[0],
  }));
  const getChildren = (item) => {
    if (item.firstChild == null) return item;
    item.children = items
      .filter((x) => x.parent === item.index)
      .map(getChildren);
    return item;
  };
  return items.filter((item) => item.headingLevel === 0).map(getChildren);
};

const getEXTH = (buf, encoding) => {
  const { magic, count } = getStruct(EXTH_HEADER, buf);
  if (magic !== "EXTH") throw new Error("Invalid EXTH header");
  const decoder = getDecoder(encoding);
  const results = {};
  let offset = 12;
  for (let i = 0; i < count; i++) {
    const type = getUint(buf.slice(offset, offset + 4));
    const length = getUint(buf.slice(offset + 4, offset + 8));
    if (type in EXTH_RECORD_TYPE) {
      const [name, typ, many] = EXTH_RECORD_TYPE[type];
      const data = buf.slice(offset + 8, offset + length);
      const value = typ === "uint" ? getUint(data) : decoder.decode(data);
      if (many) {
        results[name] ??= [];
        results[name].push(value);
      } else results[name] = value;
    }
    offset += length;
  }
  return results;
};

const getFont = async (buf, unzlib) => {
  const { flags, dataStart, keyLength, keyStart } = getStruct(FONT_HEADER, buf);
  const array = new Uint8Array(buf.slice(dataStart));
  // deobfuscate font
  if (flags & 0b10) {
    const bytes = keyLength === 16 ? 1024 : 1040;
    const key = new Uint8Array(buf.slice(keyStart, keyStart + keyLength));
    const length = Math.min(bytes, array.length);
    for (var i = 0; i < length; i++) array[i] = array[i] ^ key[i % key.length];
  }
  // decompress font
  if (flags & 1)
    try {
      return await unzlib(array);
    } catch (e) {
      console.warn(e);
      console.warn("Failed to decompress font");
    }
  return array;
};

const isMOBI = async (file) => {
  const magic = getString(await file.slice(60, 68).arrayBuffer());
  return magic === "BOOKMOBI"; // || magic === 'TEXtREAd'
};

class PDB {
  #file;
  #offsets;
  pdb;
  async open(file) {
    this.#file = file;
    const pdb = getStruct(PDB_HEADER, await file.slice(0, 78).arrayBuffer());
    this.pdb = pdb;
    const buffer = await file.slice(78, 78 + pdb.numRecords * 8).arrayBuffer();
    // get start and end offsets for each record
    this.#offsets = Array.from({ length: pdb.numRecords }, (_, i) =>
      getUint(buffer.slice(i * 8, i * 8 + 4))
    ).map((x, i, a) => [x, a[i + 1]]);
  }
  loadRecord(index) {
    const offsets = this.#offsets[index];
    if (!offsets) throw new RangeError("Record index out of bounds");
    return this.#file.slice(...offsets).arrayBuffer();
  }
  async loadMagic(index) {
    const start = this.#offsets[index][0];
    return getString(await this.#file.slice(start, start + 4).arrayBuffer());
  }
}

class MOBI extends PDB {
  #start = 0;
  #resourceStart;
  #decoder;
  #encoder;
  #decompress;
  #removeTrailingEntries;
  constructor({ unzlib }) {
    super();
    this.unzlib = unzlib;
  }
  async open(file) {
    await super.open(file);
    // TODO: if (this.pdb.type === 'TEXt')
    this.headers = this.#getHeaders(await super.loadRecord(0));
    this.#resourceStart = this.headers.mobi.resourceStart;
    let isKF8 = this.headers.mobi.version >= 8;
    if (!isKF8) {
      const boundary = this.headers.exth?.boundary;
      if (boundary < 0xffffffff)
        try {
          // it's a "combo" MOBI/KF8 file; try to open the KF8 part
          this.headers = this.#getHeaders(await super.loadRecord(boundary));
          this.#start = boundary;
          isKF8 = true;
        } catch (e) {
          console.warn(e);
          console.warn("Failed to open KF8; falling back to MOBI");
        }
    }
    await this.#setup();
    return isKF8 ? new KF8(this).init() : new MOBI6(this).init();
  }
  #getHeaders(buf) {
    const palmdoc = getStruct(PALMDOC_HEADER, buf);
    const mobi = getStruct(MOBI_HEADER, buf);
    if (mobi.magic !== "MOBI") throw new Error("Missing MOBI header");

    const { titleOffset, titleLength, localeLanguage, localeRegion } = mobi;
    mobi.title = buf.slice(titleOffset, titleOffset + titleLength);
    const lang = MOBI_LANG[localeLanguage];
    mobi.language = lang?.[localeRegion >> 2] ?? lang?.[0];

    const exth =
      mobi.exthFlag & 0b100_0000
        ? getEXTH(buf.slice(mobi.length + 16), mobi.encoding)
        : null;
    const kf8 = mobi.version >= 8 ? getStruct(KF8_HEADER, buf) : null;
    return { palmdoc, mobi, exth, kf8 };
  }
  async #setup() {
    const { palmdoc, mobi } = this.headers;
    this.#decoder = getDecoder(mobi.encoding);
    // `TextEncoder` only supports UTF-8
    // we are only encoding ASCII anyway, so I think it's fine
    this.#encoder = new TextEncoder();

    // set up decompressor
    const { compression } = palmdoc;
    this.#decompress =
      compression === 1
        ? (f) => f
        : compression === 2
          ? decompressPalmDOC
          : compression === 17480
            ? await huffcdic(mobi, this.loadRecord.bind(this))
            : null;
    if (!this.#decompress) throw new Error("Unknown compression type");

    // set up function for removing trailing bytes
    const { trailingFlags } = mobi;
    const multibyte = trailingFlags & 1;
    const numTrailingEntries = countBitsSet(trailingFlags >>> 1);
    this.#removeTrailingEntries = (array) => {
      for (let i = 0; i < numTrailingEntries; i++) {
        const length = getVarLenFromEnd(array);
        array = array.subarray(0, -length);
      }
      if (multibyte) {
        const length = (array[array.length - 1] & 0b11) + 1;
        array = array.subarray(0, -length);
      }
      return array;
    };
  }
  decode(...args) {
    return this.#decoder.decode(...args);
  }
  encode(...args) {
    return this.#encoder.encode(...args);
  }
  loadRecord(index) {
    return super.loadRecord(this.#start + index);
  }
  loadMagic(index) {
    return super.loadMagic(this.#start + index);
  }
  loadText(index) {
    return this.loadRecord(index + 1)
      .then((buf) => new Uint8Array(buf))
      .then(this.#removeTrailingEntries)
      .then(this.#decompress);
  }
  async loadResource(index) {
    const buf = await super.loadRecord(this.#resourceStart + index);
    const magic = getString(buf.slice(0, 4));
    if (magic === "FONT") return getFont(buf, this.unzlib);
    if (magic === "VIDE" || magic === "AUDI") return buf.slice(12);
    return buf;
  }
  getNCX() {
    const index = this.headers.mobi.indx;
    if (index < 0xffffffff) return getNCX(index, this.loadRecord.bind(this));
  }
  getMetadata() {
    const { mobi, exth } = this.headers;
    return {
      identifier: mobi.uid.toString(),
      title: unescapeHTML(exth?.title || this.decode(mobi.title)),
      author: exth?.creator?.map(unescapeHTML),
      publisher: unescapeHTML(exth?.publisher),
      language: exth?.language ?? mobi.language,
      published: exth?.date,
      description: unescapeHTML(exth?.description),
      subject: exth?.subject?.map(unescapeHTML),
      rights: unescapeHTML(exth?.rights),
    };
  }
  async getCover() {
    const { exth } = this.headers;
    const offset =
      exth?.coverOffset < 0xffffffff
        ? exth?.coverOffset
        : exth?.thumbnailOffset < 0xffffffff
          ? exth?.thumbnailOffset
          : null;
    if (offset != null) {
      const buf = await this.loadResource(offset);
      return new Blob([buf]);
    }
  }
}

const mbpPagebreakRegex = /<\s*(?:mbp:)?pagebreak[^>]*>/gi;
const fileposRegex = /<[^<>]+filepos=['"]{0,1}(\d+)[^<>]*>/gi;

const getIndent = (el) => {
  let x = 0;
  while (el) {
    const parent = el.parentElement;
    if (parent) {
      const tag = parent.tagName.toLowerCase();
      if (tag === "p") x += 1.5;
      else if (tag === "blockquote") x += 2;
    }
    el = parent;
  }
  return x;
};

class MOBI6 {
  parser = new DOMParser();
  serializer = new XMLSerializer();
  #resourceCache = new Map();
  #textCache = new Map();
  #cache = new Map();
  #sections;
  #fileposList = [];
  #type = MIME$1.HTML;
  constructor(mobi) {
    this.mobi = mobi;
  }
  async init() {
    // load all text records in an array
    let array = new Uint8Array();
    for (let i = 0; i < this.mobi.headers.palmdoc.numTextRecords; i++)
      array = concatTypedArray(array, await this.mobi.loadText(i));

    // convert to string so we can use regex
    // note that `filepos` are byte offsets
    // so it needs to preserve each byte as a separate character
    // (see https://stackoverflow.com/q/50198017)
    const str = Array.from(new Uint8Array(array), (c) =>
      String.fromCharCode(c)
    ).join("");

    // split content into sections at each `<mbp:pagebreak>`
    this.#sections = [0]
      .concat(Array.from(str.matchAll(mbpPagebreakRegex), (m) => m.index))
      .map((x, i, a) => str.slice(x, a[i + 1]))
      // recover the original raw bytes
      .map((str) => Uint8Array.from(str, (x) => x.charCodeAt(0)))
      .map((raw) => ({ book: this, raw }))
      // get start and end filepos for each section
      .reduce((arr, x) => {
        const last = arr[arr.length - 1];
        x.start = last?.end ?? 0;
        x.end = x.start + x.raw.byteLength;
        return arr.concat(x);
      }, []);

    this.sections = this.#sections.map((section, index) => ({
      id: index,
      load: () => this.loadSection(section),
      createDocument: () => this.createDocument(section),
      size: section.end - section.start,
    }));

    try {
      this.landmarks = await this.getGuide();
      const tocHref = this.landmarks.find(({ type }) =>
        type?.includes("toc")
      )?.href;
      if (tocHref) {
        const { index } = this.resolveHref(tocHref);
        const doc = await this.sections[index].createDocument();
        let lastItem;
        let lastLevel = 0;
        let lastIndent = 0;
        const lastLevelOfIndent = new Map();
        const lastParentOfLevel = new Map();
        this.toc = Array.from(doc.querySelectorAll("a[filepos]")).reduce(
          (arr, a) => {
            const indent = getIndent(a);
            const item = {
              label: a.innerText?.trim(),
              href: `filepos:${a.getAttribute("filepos")}`,
            };
            const level =
              indent > lastIndent
                ? lastLevel + 1
                : indent === lastIndent
                  ? lastLevel
                  : lastLevelOfIndent.get(indent) ?? Math.max(0, lastLevel - 1);
            if (level > lastLevel) {
              if (lastItem) {
                lastItem.subitems ??= [];
                lastItem.subitems.push(item);
                lastParentOfLevel.set(level, lastItem);
              } else arr.push(item);
            } else {
              const parent = lastParentOfLevel.get(level);
              if (parent) parent.subitems.push(item);
              else arr.push(item);
            }
            lastItem = item;
            lastLevel = level;
            lastIndent = indent;
            lastLevelOfIndent.set(indent, level);
            return arr;
          },
          []
        );
      }
    } catch (e) {
      console.warn(e);
    }

    // get list of all `filepos` references in the book,
    // which will be used to insert anchor elements
    // because only then can they be referenced in the DOM
    this.#fileposList = [
      ...new Set(Array.from(str.matchAll(fileposRegex), (m) => m[1])),
    ]
      .map((filepos) => ({ filepos, number: Number(filepos) }))
      .sort((a, b) => a.number - b.number);

    this.metadata = this.mobi.getMetadata();
    this.getCover = this.mobi.getCover.bind(this.mobi);
    return this;
  }
  async getGuide() {
    const doc = await this.createDocument(this.#sections[0]);
    return Array.from(doc.getElementsByTagName("reference"), (ref) => ({
      label: ref.getAttribute("title"),
      type: ref.getAttribute("type")?.split(/\s/),
      href: `filepos:${ref.getAttribute("filepos")}`,
    }));
  }
  async loadResource(index) {
    if (this.#resourceCache.has(index)) return this.#resourceCache.get(index);
    const raw = await this.mobi.loadResource(index);
    const url = URL.createObjectURL(new Blob([raw]));
    this.#resourceCache.set(index, url);
    return url;
  }
  async loadRecindex(recindex) {
    return this.loadResource(Number(recindex) - 1);
  }
  async replaceResources(doc) {
    for (const img of doc.querySelectorAll("img[recindex]")) {
      const recindex = img.getAttribute("recindex");
      try {
        img.src = await this.loadRecindex(recindex);
      } catch (e) {
        console.warn(`Failed to load image ${recindex}`);
      }
    }
    for (const media of doc.querySelectorAll("[mediarecindex]")) {
      const mediarecindex = media.getAttribute("mediarecindex");
      const recindex = media.getAttribute("recindex");
      try {
        media.src = await this.loadRecindex(mediarecindex);
        if (recindex) media.poster = await this.loadRecindex(recindex);
      } catch (e) {
        console.warn(`Failed to load media ${mediarecindex}`);
      }
    }
    for (const a of doc.querySelectorAll("[filepos]")) {
      const filepos = a.getAttribute("filepos");
      a.href = `filepos:${filepos}`;
    }
  }
  async loadText(section) {
    if (this.#textCache.has(section)) return this.#textCache.get(section);
    const { raw } = section;

    // insert anchor elements for each `filepos`
    const fileposList = this.#fileposList
      .filter(({ number }) => number >= section.start && number < section.end)
      .map((obj) => ({ ...obj, offset: obj.number - section.start }));
    let arr = raw;
    if (fileposList.length) {
      arr = raw.subarray(0, fileposList[0].offset);
      fileposList.forEach(({ filepos, offset }, i) => {
        const next = fileposList[i + 1];
        const a = this.mobi.encode(`<a id="filepos${filepos}"></a>`);
        arr = concatTypedArray3(arr, a, raw.subarray(offset, next?.offset));
      });
    }
    const str = this.mobi.decode(arr).replaceAll(mbpPagebreakRegex, "");
    this.#textCache.set(section, str);
    return str;
  }
  async createDocument(section) {
    const str = await this.loadText(section);
    return this.parser.parseFromString(str, this.#type);
  }
  async loadSection(section) {
    if (this.#cache.has(section)) return this.#cache.get(section);
    const doc = await this.createDocument(section);

    // inject default stylesheet
    const style = doc.createElement("style");
    doc.head.append(style);
    // blockquotes in MOBI seem to have only a small left margin by default
    // many books seem to rely on this, as it's the only way to set margin
    // (since there's no CSS)
    style.append(
      doc.createTextNode(`blockquote {
            margin-block-start: 0;
            margin-block-end: 0;
            margin-inline-start: 1em;
            margin-inline-end: 0;
        }`)
    );

    await this.replaceResources(doc);
    const result = this.serializer.serializeToString(doc);
    const url = URL.createObjectURL(new Blob([result], { type: this.#type }));
    this.#cache.set(section, url);
    return url;
  }
  resolveHref(href) {
    const filepos = href.match(/filepos:(.*)/)[1];
    const number = Number(filepos);
    const index = this.#sections.findIndex((section) => section.end > number);
    const anchor = (doc) => doc.getElementById(`filepos${filepos}`);
    return { index, anchor };
  }
  splitTOCHref(href) {
    const filepos = href.match(/filepos:(.*)/)[1];
    const number = Number(filepos);
    const index = this.#sections.findIndex((section) => section.end > number);
    return [index, `filepos${filepos}`];
  }
  getTOCFragment(doc, id) {
    return doc.getElementById(id);
  }
  isExternal(uri) {
    return /^(?!blob|filepos)\w+:/i.test(uri);
  }
  destroy() {
    for (const url of this.#resourceCache.values()) URL.revokeObjectURL(url);
    for (const url of this.#cache.values()) URL.revokeObjectURL(url);
  }
}

// handlers for `kindle:` uris
const kindleResourceRegex =
  /kindle:(flow|embed):(\w+)(?:\?mime=(\w+\/[-+.\w]+))?/;
const kindlePosRegex = /kindle:pos:fid:(\w+):off:(\w+)/;
const parseResourceURI = (str) => {
  const [resourceType, id, type] = str.match(kindleResourceRegex).slice(1);
  return { resourceType, id: parseInt(id, 32), type };
};
const parsePosURI = (str) => {
  const [fid, off] = str.match(kindlePosRegex).slice(1);
  return { fid: parseInt(fid, 32), off: parseInt(off, 32) };
};
const makePosURI = (fid = 0, off = 0) =>
  `kindle:pos:fid:${fid.toString(32).toUpperCase().padStart(4, "0")}:off:${off
    .toString(32)
    .toUpperCase()
    .padStart(10, "0")}`;

// `kindle:pos:` links are originally links that contain fragments identifiers
// so there should exist an element with `id` or `name`
// otherwise try to find one with an `aid` attribute
const getFragmentSelector = (str) => {
  const match = str.match(/\s(id|name|aid)\s*=\s*['"]([^'"]*)['"]/i);
  if (!match) return;
  const [, attr, value] = match;
  return `[${attr}="${CSS.escape(value)}"]`;
};

// replace asynchronously and sequentially
const replaceSeries = async (str, regex, f) => {
  const matches = [];
  str.replace(regex, (...args) => (matches.push(args), null));
  const results = [];
  for (const args of matches) results.push(await f(...args));
  return str.replace(regex, () => results.shift());
};

const getPageSpread = (properties) => {
  for (const p of properties) {
    if (p === "page-spread-left" || p === "rendition:page-spread-left")
      return "left";
    if (p === "page-spread-right" || p === "rendition:page-spread-right")
      return "right";
    if (p === "rendition:page-spread-center") return "center";
  }
};

class KF8 {
  parser = new DOMParser();
  serializer = new XMLSerializer();
  #cache = new Map();
  #fragmentOffsets = new Map();
  #fragmentSelectors = new Map();
  #tables = {};
  #sections;
  #fullRawLength;
  #rawHead = new Uint8Array();
  #rawTail = new Uint8Array();
  #lastLoadedHead = -1;
  #lastLoadedTail = -1;
  #type = MIME$1.XHTML;
  #inlineMap = new Map();
  constructor(mobi) {
    this.mobi = mobi;
  }
  async init() {
    const loadRecord = this.mobi.loadRecord.bind(this.mobi);
    const { kf8 } = this.mobi.headers;

    try {
      const fdstBuffer = await loadRecord(kf8.fdst);
      const fdst = getStruct(FDST_HEADER, fdstBuffer);
      if (fdst.magic !== "FDST") throw new Error("Missing FDST record");
      const fdstTable = Array.from(
        { length: fdst.numEntries },
        (_, i) => 12 + i * 8
      ).map((offset) => [
        getUint(fdstBuffer.slice(offset, offset + 4)),
        getUint(fdstBuffer.slice(offset + 4, offset + 8)),
      ]);
      this.#tables.fdstTable = fdstTable;
      this.#fullRawLength = fdstTable[fdstTable.length - 1][1];
    } catch { }

    const skelTable = (await getIndexData(kf8.skel, loadRecord)).table.map(
      ({ name, tagMap }, index) => ({
        index,
        name,
        numFrag: tagMap[1][0],
        offset: tagMap[6][0],
        length: tagMap[6][1],
      })
    );
    const fragData = await getIndexData(kf8.frag, loadRecord);
    const fragTable = fragData.table.map(({ name, tagMap }) => ({
      insertOffset: parseInt(name),
      selector: fragData.cncx[tagMap[2][0]],
      index: tagMap[4][0],
      offset: tagMap[6][0],
      length: tagMap[6][1],
    }));
    this.#tables.skelTable = skelTable;
    this.#tables.fragTable = fragTable;

    this.#sections = skelTable.reduce((arr, skel) => {
      const last = arr[arr.length - 1];
      const fragStart = last?.fragEnd ?? 0,
        fragEnd = fragStart + skel.numFrag;
      const frags = fragTable.slice(fragStart, fragEnd);
      const length =
        skel.length + frags.map((f) => f.length).reduce((a, b) => a + b);
      const totalLength = (last?.totalLength ?? 0) + length;
      return arr.concat({ skel, frags, fragEnd, length, totalLength });
    }, []);

    const resources = await this.getResourcesByMagic(["RESC", "PAGE"]);
    const pageSpreads = new Map();
    if (resources.RESC) {
      const buf = await this.mobi.loadRecord(resources.RESC);
      const str = this.mobi.decode(buf.slice(16)).replace(/\0/g, "");
      // the RESC record lacks the root `<package>` element
      // but seem to be otherwise valid XML
      const index = str.search(/\?>/);
      const xmlStr = `<package>${str.slice(index)}</package>`;
      const opf = this.parser.parseFromString(xmlStr, MIME$1.XML);
      for (const $itemref of opf.querySelectorAll("spine > itemref")) {
        const i = parseInt($itemref.getAttribute("skelid"));
        pageSpreads.set(
          i,
          getPageSpread($itemref.getAttribute("properties")?.split(" ") ?? [])
        );
      }
    }

    this.sections = this.#sections.map((section, index) =>
      section.frags.length
        ? {
          id: index,
          load: () => this.loadSection(section),
          createDocument: () => this.createDocument(section),
          size: section.length,
          pageSpread: pageSpreads.get(index),
        }
        : { linear: "no" }
    );

    try {
      const ncx = await this.mobi.getNCX();
      const map = ({ label, pos, children }) => {
        const [fid, off] = pos;
        const href = makePosURI(fid, off);
        const arr = this.#fragmentOffsets.get(fid);
        if (arr) arr.push(off);
        else this.#fragmentOffsets.set(fid, [off]);
        return {
          label: unescapeHTML(label),
          href,
          subitems: children?.map(map),
        };
      };
      this.toc = ncx?.map(map);
      this.landmarks = await this.getGuide();
    } catch (e) {
      console.warn(e);
    }

    const { exth } = this.mobi.headers;
    this.dir = exth.pageProgressionDirection;
    this.rendition = {
      layout: exth.fixedLayout === "true" ? "pre-paginated" : "reflowable",
      viewport: Object.fromEntries(
        exth.originalResolution
          ?.split("x")
          ?.slice(0, 2)
          ?.map((x, i) => [i ? "height" : "width", x]) ?? []
      ),
    };

    this.metadata = this.mobi.getMetadata();
    this.getCover = this.mobi.getCover.bind(this.mobi);
    return this;
  }
  // is this really the only way of getting to RESC, PAGE, etc.?
  async getResourcesByMagic(keys) {
    const results = {};
    const start = this.mobi.headers.kf8.resourceStart;
    const end = this.mobi.pdb.numRecords;
    for (let i = start; i < end; i++) {
      try {
        const magic = await this.mobi.loadMagic(i);
        const match = keys.find((key) => key === magic);
        if (match) results[match] = i;
      } catch { }
    }
    return results;
  }
  async getGuide() {
    const index = this.mobi.headers.kf8.guide;
    if (index < 0xffffffff) {
      const loadRecord = this.mobi.loadRecord.bind(this.mobi);
      const { table, cncx } = await getIndexData(index, loadRecord);
      return table.map(({ name, tagMap }) => ({
        label: cncx[tagMap[1][0]] ?? "",
        type: name?.split(/\s/),
        href: makePosURI(tagMap[6]?.[0] ?? tagMap[3]?.[0]),
      }));
    }
  }
  async loadResourceBlob(str) {
    const { resourceType, id, type } = parseResourceURI(str);
    const raw =
      resourceType === "flow"
        ? await this.loadFlow(id)
        : await this.mobi.loadResource(id - 1);
    const result = [MIME$1.XHTML, MIME$1.HTML, MIME$1.CSS, MIME$1.SVG].includes(type)
      ? await this.replaceResources(this.mobi.decode(raw))
      : raw;
    const doc =
      type === MIME$1.SVG ? this.parser.parseFromString(result, type) : null;
    return [
      new Blob([result], { type }),
      // SVG wrappers need to be inlined
      // as browsers don't allow external resources when loading SVG as an image
      doc?.getElementsByTagNameNS("http://www.w3.org/2000/svg", "image")?.length
        ? doc.documentElement
        : null,
    ];
  }
  async loadResource(str) {
    if (this.#cache.has(str)) return this.#cache.get(str);
    const [blob, inline] = await this.loadResourceBlob(str);
    const url = inline ? str : URL.createObjectURL(blob);
    if (inline) this.#inlineMap.set(url, inline);
    this.#cache.set(str, url);
    return url;
  }
  replaceResources(str) {
    const regex = new RegExp(kindleResourceRegex, "g");
    return replaceSeries(str, regex, this.loadResource.bind(this));
  }
  // NOTE: there doesn't seem to be a way to access text randomly?
  // how to know the decompressed size of the records without decompressing?
  // 4096 is just the maximum size
  async loadRaw(start, end) {
    // here we load either from the front or back until we have reached the
    // required offsets; at worst you'd have to load half the book at once
    const distanceHead = end - this.#rawHead.length;
    const distanceEnd =
      this.#fullRawLength == null
        ? Infinity
        : this.#fullRawLength - this.#rawTail.length - start;
    // load from the start
    if (distanceHead < 0 || distanceHead < distanceEnd) {
      while (this.#rawHead.length < end) {
        const index = ++this.#lastLoadedHead;
        const data = await this.mobi.loadText(index);
        this.#rawHead = concatTypedArray(this.#rawHead, data);
      }
      return this.#rawHead.slice(start, end);
    }
    // load from the end
    while (this.#fullRawLength - this.#rawTail.length > start) {
      const index =
        this.mobi.headers.palmdoc.numTextRecords - 1 - ++this.#lastLoadedTail;
      const data = await this.mobi.loadText(index);
      this.#rawTail = concatTypedArray(data, this.#rawTail);
    }
    const rawTailStart = this.#fullRawLength - this.#rawTail.length;
    return this.#rawTail.slice(start - rawTailStart, end - rawTailStart);
  }
  loadFlow(index) {
    if (index < 0xffffffff)
      return this.loadRaw(...this.#tables.fdstTable[index]);
  }
  async loadText(section) {
    const { skel, frags, length } = section;
    const raw = await this.loadRaw(skel.offset, skel.offset + length);
    let skeleton = raw.slice(0, skel.length);
    for (const frag of frags) {
      const insertOffset = frag.insertOffset - skel.offset;
      const offset = skel.length + frag.offset;
      const fragRaw = raw.slice(offset, offset + frag.length);
      skeleton = concatTypedArray3(
        skeleton.slice(0, insertOffset),
        fragRaw,
        skeleton.slice(insertOffset)
      );

      const offsets = this.#fragmentOffsets.get(frag.index);
      if (offsets)
        for (const offset of offsets) {
          const str = this.mobi.decode(fragRaw).slice(offset);
          const selector = getFragmentSelector(str);
          this.#setFragmentSelector(frag.index, offset, selector);
        }
    }
    return this.mobi.decode(skeleton);
  }
  async createDocument(section) {
    const str = await this.loadText(section);
    return this.parser.parseFromString(str, this.#type);
  }
  async loadSection(section) {
    if (this.#cache.has(section)) return this.#cache.get(section);
    const str = await this.loadText(section);
    const replaced = await this.replaceResources(str);

    // by default, type is XHTML; change to HTML if it's not valid XHTML
    let doc = this.parser.parseFromString(replaced, this.#type);
    if (doc.querySelector("parsererror")) {
      this.#type = MIME$1.HTML;
      doc = this.parser.parseFromString(replaced, this.#type);
    }
    for (const [url, node] of this.#inlineMap) {
      for (const el of doc.querySelectorAll(`img[src="${url}"]`))
        el.replaceWith(node);
    }
    const url = URL.createObjectURL(
      new Blob([this.serializer.serializeToString(doc)], { type: this.#type })
    );
    this.#cache.set(section, url);
    return url;
  }
  getIndexByFID(fid) {
    return this.#sections.findIndex((section) =>
      section.frags.some((frag) => frag.index === fid)
    );
  }
  #setFragmentSelector(id, offset, selector) {
    const map = this.#fragmentSelectors.get(id);
    if (map) map.set(offset, selector);
    else {
      const map = new Map();
      this.#fragmentSelectors.set(id, map);
      map.set(offset, selector);
    }
  }
  async resolveHref(href) {
    const { fid, off } = parsePosURI(href);
    const index = this.getIndexByFID(fid);
    if (index < 0) return;

    const saved = this.#fragmentSelectors.get(fid)?.get(off);
    if (saved) return { index, anchor: (doc) => doc.querySelector(saved) };

    const { skel, frags } = this.#sections[index];
    const frag = frags.find((frag) => frag.index === fid);
    const offset = skel.offset + skel.length + frag.offset;
    const fragRaw = await this.loadRaw(offset, offset + frag.length);
    const str = this.mobi.decode(fragRaw).slice(off);
    const selector = getFragmentSelector(str);
    this.#setFragmentSelector(fid, off, selector);
    const anchor = (doc) => doc.querySelector(selector);
    return { index, anchor };
  }
  splitTOCHref(href) {
    const pos = parsePosURI(href);
    const index = this.getIndexByFID(pos.fid);
    return [index, pos];
  }
  getTOCFragment(doc, { fid, off }) {
    const selector = this.#fragmentSelectors.get(fid)?.get(off);
    return doc.querySelector(selector);
  }
  isExternal(uri) {
    return /^(?!blob|kindle)\w+:/i.test(uri);
  }
  destroy() {
    for (const url of this.#cache.values()) URL.revokeObjectURL(url);
  }
}

class MobiRender extends GeneralRender {
    constructor(mobiBuffer, config) {
        super(Object.assign({ format: "MOBI" }, config));
        this.mobiBuffer = mobiBuffer;
    }
    renderTo(element) {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            this.element = element;
            if (!this.book) {
                yield this.parse();
            }
            let parser = new GeneralParser(this.book);
            this.chapterList = yield parser.getChapter(this.book.toc);
            this.chapterDocList = yield parser.getChapterDoc();
            createIframe(element);
            let doc = this.getDocument();
            if (!doc)
                return;
            handleLayout(element, this.readerMode, doc);
            resolve();
        }));
    }
    parse() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                let blob = new Blob([this.mobiBuffer]);
                let file = new File([blob], "book", {
                    lastModified: new Date().getTime(),
                    type: blob.type,
                });
                if (yield isMOBI(file)) {
                    this.book = yield new MOBI({ unzlib: unzlibSync }).open(file);
                }
            }
            catch (error) {
                console.error(error);
                throw error;
            }
        });
    }
    preCache() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.book) {
                yield this.parse();
            }
            return yield getCache(this.book);
        });
    }
    getMetadata() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                if (!this.book) {
                    yield this.parse();
                }
                let parser = new GeneralParser(this.book);
                return yield parser.getMetadata();
            }
            catch (error) {
                console.error(error);
                throw error;
            }
        });
    }
}

const pdfjsPath = path => `${isElectron() ? "." : ""}/lib/pdfjs/${path}`;

const pdfjsLib = window.pdfjsLib;

const fetchText = async url => await (await fetch(url)).text();
const isElectron = () => {
  // Renderer process
  if (typeof window !== 'undefined' && typeof window.process === 'object' && window.process.type === 'renderer') {
    return true;
  }
  // Main process
  if (typeof process !== 'undefined' && typeof process.versions === 'object' && !!process.versions.electron) {
    return true;
  }
  // Detect the user agent when the `nodeIntegration` option is set to true
  if (typeof navigator === 'object' && typeof navigator.userAgent === 'string' && navigator.userAgent.indexOf('Electron') >= 0) {
    return true;
  }

  return false;
};

// https://github.com/mozilla/pdf.js/blob/642b9a5ae67ef642b9a8808fd9efd447e8c350e2/web/text_layer_builder.css
const textLayerBuilderCSS = async () => await fetchText(pdfjsPath('text_layer_builder.css'));
// https://github.com/mozilla/pdf.js/blob/642b9a5ae67ef642b9a8808fd9efd447e8c350e2/web/annotation_layer_builder.css
const annotationLayerBuilderCSS = async () => await fetchText(pdfjsPath('annotation_layer_builder.css'));

const render = async (page, doc, zoom) => {
  const scale = zoom * devicePixelRatio;
  let docLayer = doc.querySelector('#koodoPDFLayer');
  docLayer.style.visibility = 'hidden';
  docLayer.style.transform = `scale(${1 / devicePixelRatio})`;
  docLayer.style.transformOrigin = 'top left';
  docLayer.style.setProperty('--scale-factor', scale);
  const viewport = page.getViewport({ scale });


  // the canvas must be in the `PDFDocument`'s `ownerDocument`
  // (`globalThis.document` by default); that's where the fonts are loaded
  const canvas = document.createElement('canvas');
  docLayer.style.width = `${viewport.width}px`;
  docLayer.style.height = `${viewport.height}px`;
  canvas.height = viewport.height;
  canvas.width = viewport.width;
  const canvasContext = canvas.getContext('2d');
  await page.render({ canvasContext, viewport, background: 'rgba(0,0,0,0)', }).promise;
  doc.querySelector('#canvas').replaceChildren(doc.adoptNode(canvas));
  docLayer.style.overflow = 'hidden';
  const container = doc.querySelector('#textLayer');
  const textLayer = new pdfjsLib.TextLayer({
    textContentSource: await page.streamTextContent(),
    container, viewport,
  });
  await textLayer.render();

  // hide "offscreen" canvases appended to docuemnt when rendering text layer
  // https://github.com/mozilla/pdf.js/blob/642b9a5ae67ef642b9a8808fd9efd447e8c350e2/web/pdf_viewer.css#L51-L58
  for (const canvas of document.querySelectorAll('.hiddenCanvasElement'))
    Object.assign(canvas.style, {
      position: 'absolute',
      top: '0',
      left: '0',
      width: '0',
      height: '0',
      display: 'none',
    });

  // fix text selection
  // https://github.com/mozilla/pdf.js/blob/642b9a5ae67ef642b9a8808fd9efd447e8c350e2/web/text_layer_builder.js#L105-L107
  const endOfContent = document.createElement('div');
  endOfContent.className = 'endOfContent';
  container.append(endOfContent);
  // TODO: this only works in Firefox; see https://github.com/mozilla/pdf.js/pull/17923
  container.onpointerdown = () => container.classList.add('selecting');
  container.onpointerup = () => container.classList.remove('selecting');

  const div = doc.querySelector('#annotationLayer');
  await new pdfjsLib.AnnotationLayer({ page, viewport, div }).render({
    annotations: await page.getAnnotations(),
    linkService: {
      goToDestination: () => { },
      getDestinationHash: dest => JSON.stringify(dest),
      addLinkAttributes: (link, url) => link.href = url,
    },
  });
  docLayer.style.marginLeft = `calc(50% - ${docLayer.getBoundingClientRect().width / 2}px)`;
  docLayer.style.visibility = 'visible';
};

const renderPage = async (page, getImageBlob) => {
  const viewport = page.getViewport({ scale: 1 });
  if (getImageBlob) {
    const canvas = document.createElement('canvas');
    canvas.height = viewport.height;
    canvas.width = viewport.width;
    const canvasContext = canvas.getContext('2d');
    await page.render({ canvasContext, viewport }).promise;
    return new Promise(resolve => canvas.toBlob(resolve))
  }
  const src = URL.createObjectURL(new Blob([`
        <!DOCTYPE html>
        <html lang="en">
        <meta charset="utf-8">
        <meta name="viewport" content="width=${viewport.width}, height=${viewport.height}">
        <style>
        html, body {
            margin: 0;
            padding: 0;
        }
        ${await textLayerBuilderCSS()}
        ${await annotationLayerBuilderCSS()}
        </style>
        <div class="noteLayer"></div>
        <div class="koodoPDFLayer" id="koodoPDFLayer">
            <div class="textLayer" id="textLayer"></div>
            <div class="annotationLayer" id="annotationLayer"></div>
            <div id="canvas"></div>
        </div>
    `], { type: 'text/html' }));
  return src
};

const makeTOCItem = item => ({
  label: item.title,
  href: item.dest ? JSON.stringify(item.dest) : null,
  subitems: item.items.length ? item.items.map(makeTOCItem) : null,
});

const makePDF = async (file, readerMode) => {
  const transport = new pdfjsLib.PDFDataRangeTransport(file.size, []);
  transport.requestDataRange = (begin, end) => {
    file.slice(begin, end).arrayBuffer().then(chunk => {
      transport.onDataRange(begin, chunk);
    });
  };
  const pdf = await pdfjsLib.getDocument({
    range: transport,
    cMapUrl: pdfjsPath('cmaps/'),
    standardFontDataUrl: pdfjsPath('standard_fonts/'),
    isEvalSupported: false,
  }).promise;

  const book = { rendition: { layout: 'pre-paginated' } };

  const { metadata, info } = await pdf.getMetadata() ?? {};
  // TODO: for better results, parse `metadata.getRaw()`
  book.metadata = {
    title: metadata?.get('dc:title') ?? info?.Title,
    author: metadata?.get('dc:creator') ?? info?.Author,
    contributor: metadata?.get('dc:contributor'),
    description: metadata?.get('dc:description') ?? info?.Subject,
    language: metadata?.get('dc:language'),
    publisher: metadata?.get('dc:publisher'),
    subject: metadata?.get('dc:subject'),
    identifier: metadata?.get('dc:identifier'),
    source: metadata?.get('dc:source'),
    rights: metadata?.get('dc:rights'),
  };

  const outline = await pdf.getOutline();
  book.toc = outline?.map(makeTOCItem);

  const cache = new Map();
  book.sections = Array.from({ length: pdf.numPages }).map((_, i) => ({
    id: i,
    load: async () => {
      const cached = cache.get(i);
      if (cached) return cached
      const url = await renderPage(await pdf.getPage(i + 1));
      cache.set(i, url);
      return url
    },
    unload: async () => {
      let page = await pdf.getPage(i + 1);
      page.cleanup();
    },
    render: async (doc, scale) => {
      await render(await pdf.getPage(i + 1), doc, scale);
    },
    size: 1000,
    getDimension: async () => {
      let viewport = (await pdf.getPage(i + 1)).getViewport({ scale: 1 });
      return { width: viewport.width, height: viewport.height }
    },
    getPage: async () => {
      return await pdf.getPage(i + 1)
    }
  }));
  book.isExternal = uri => /^\w+:/i.test(uri);
  book.resolveHref = async href => {
    const parsed = JSON.parse(href);
    const dest = typeof parsed === 'string'
      ? await pdf.getDestination(parsed) : parsed;
    const index = await pdf.getPageIndex(dest[0]);
    return { index }
  };
  book.splitTOCHref = async href => {
    const parsed = JSON.parse(href);
    const dest = typeof parsed === 'string'
      ? await pdf.getDestination(parsed) : parsed;
    const index = await pdf.getPageIndex(dest[0]);
    return [index, null]
  };
  book.getTOCFragment = doc => doc.documentElement;
  book.getCover = async () => renderPage(await pdf.getPage(1), true);
  book.destroy = () => pdf.destroy();
  return book
};
const isPDF = async file => {
  const arr = new Uint8Array(await file.slice(0, 5).arrayBuffer());
  return arr[0] === 0x25
    && arr[1] === 0x50 && arr[2] === 0x44 && arr[3] === 0x46
    && arr[4] === 0x2d
};

const handleRenderPDFChapter = (chapterDocIndex, chapterTitle, chapterHref, chapterDocList, element, readerMode, tempLocation, doc) => __awaiter(void 0, void 0, void 0, function* () {
    let subIframe = doc.getElementById("pdf-iframe-" + chapterDocIndex);
    let subDoc = subIframe === null || subIframe === void 0 ? void 0 : subIframe.contentDocument;
    if (!subDoc)
        return;
    if (subDoc.body.innerHTML) {
        return;
    }
    subDoc.body.innerHTML = "";
    let blob = yield fetch(yield chapterDocList[chapterDocIndex].text.load()).then((r) => r.blob());
    let chapterText = yield blob.text();
    subDoc.body.innerHTML = chapterText;
    let scale = yield getPdfScale(element, readerMode, chapterDocList, chapterDocIndex);
    yield chapterDocList[chapterDocIndex].text.render(subDoc, scale, readerMode);
    tempLocation.chapterTitle = chapterTitle;
    tempLocation.chapterHref = chapterHref;
    tempLocation.chapterDocIndex = chapterDocIndex + "";
    tempLocation.percentage = chapterDocIndex / chapterDocList.length + "";
    tempLocation.text = "";
});
const getPdfScale = (element, readerMode, chapterDocList, chapterDocIndex) => __awaiter(void 0, void 0, void 0, function* () {
    let { width, height } = yield chapterDocList[chapterDocIndex].text.getDimension();
    let columnNum = readerMode === "double" ? 2 : 1;
    let section = Math.floor(element.clientWidth / 12);
    let gap = section % 2 === 0 ? section : section - 1;
    let viewWidth = (element.clientWidth - gap) / columnNum;
    if (readerMode === "single") {
        viewWidth = element.clientWidth;
    }
    let viewHeight = element.clientHeight;
    let scale = Math.min(viewWidth / width, viewHeight / height);
    if (readerMode === "scroll") {
        scale = viewWidth / width;
    }
    return scale;
});
const handlePDFLayout = (element, readerMode, doc) => {
    if (readerMode === "scroll")
        return;
    let scale = readerMode === "double" ? 2 : 1;
    let section = Math.floor(element.clientWidth / 12);
    let gap = section % 2 === 0 ? section : section - 1;
    doc.body.setAttribute("style", element.getAttribute("style") +
        `height: 100%;overflow-y: hidden;overflow-X: hidden;padding-left: 0px;padding-right: 0px;margin: 0px;box-sizing: border-box;touch-action: pan-y; overscroll-behavior: none;max-width: inherit;column-fill: auto;column-gap: ${gap}px; column-width: ${(element.clientWidth - gap) / scale}px;`);
};
const createPDFIframe = (element, chapterDocList, viewport) => {
    var _a;
    for (let index = 0; index < chapterDocList.length; index++) {
        // Create container with aspect ratio
        const iframeContainer = document.createElement("div");
        iframeContainer.style.position = "relative";
        iframeContainer.style.width = "100%";
        // Set aspect ratio based on PDF page dimensions
        const aspectRatio = (viewport === null || viewport === void 0 ? void 0 : viewport.width) / (viewport === null || viewport === void 0 ? void 0 : viewport.height) || 0.75; // Default to 3:4 if viewport unknown
        iframeContainer.style.paddingTop = `${(1 / aspectRatio) * 100}%`;
        // Create iframe with absolute positioning
        let iframe = document.createElement("iframe");
        iframe.style.position = "absolute";
        iframe.style.top = "0";
        iframe.style.left = "0";
        iframe.style.width = "100%";
        iframe.style.height = "100%";
        iframe.style.border = "0";
        iframe.style.margin = "0";
        iframe.style.padding = "0";
        iframe.style.fontSize = "100%";
        iframe.style.font = "inherit";
        iframe.scrolling = "no";
        iframe.tabIndex = 0;
        iframe.id = "pdf-iframe-" + index;
        // Add style element
        let style = document.createElement("style");
        style.id = "default-style";
        style.textContent =
            "p,empty-line{display: inherit;margin-block-start: inherit;margin-block-end: inherit;margin-inline-start: inherit;margin-inline-end: inherit;}body{margin: 0px}";
        // Append iframe to container, then container to parent
        iframeContainer.appendChild(iframe);
        element.appendChild(iframeContainer);
        // Add style to iframe after it's in the DOM
        (_a = iframe.contentDocument) === null || _a === void 0 ? void 0 : _a.head.appendChild(style);
    }
};
const handleScrollPDFPosition = (chapterDocIndex, readerMode, doc) => __awaiter(void 0, void 0, void 0, function* () {
    let targetNode = doc.getElementById("pdf-iframe-" + chapterDocIndex);
    if (!targetNode)
        return;
    targetNode = targetNode.parentElement;
    if (readerMode !== "scroll") {
        let left = targetNode
            ? convertStyleNum(targetNode.offsetLeft) -
                convertStyleNum(targetNode.marginLeft ||
                    parseFloat(getComputedStyle(targetNode).marginLeft))
            : 0;
        console.log(left, "left");
        doc.body.scrollTo(left, 0);
    }
    else {
        targetNode.scrollIntoView();
    }
    targetNode.scrollIntoView();
});
const handlePDFScrollEvent = (chapterDocList, element, readerMode, tempLocation, doc) => {
    let subIframes = doc.querySelectorAll("iframe");
    console.log(subIframes, "subiframes");
    for (let index = 0; index < subIframes.length; index++) {
        let subIframe = subIframes[index];
        if (isPDFScrolledIntoView(element, subIframe, readerMode)) {
            handleRenderPDFChapter(index, "", "", chapterDocList, element, readerMode, tempLocation, doc);
        }
    }
};
const isPDFScrolledIntoView = (element, el, readerMode) => {
    var isVisible = false;
    var rect = el.getBoundingClientRect();
    console.log(rect, "rect");
    if (readerMode !== "scroll") {
        let elemLeft = rect.left;
        isVisible = elemLeft > -10 && elemLeft <= element.clientWidth;
    }
    else {
        let elemTop = rect.top;
        let elemBottom = rect.bottom;
        isVisible =
            (elemTop >= element.scrollTop &&
                elemTop <= element.scrollTop + element.clientHeight) ||
                (elemBottom >= element.scrollTop &&
                    elemBottom <= element.scrollTop + element.clientHeight);
    }
    return isVisible;
};
const renderPdfPage = (chapterDocIndex, chapterTitle, chapterHref, chapterDocList, element, readerMode, tempLocation, doc) => __awaiter(void 0, void 0, void 0, function* () {
    yield handleRenderPDFChapter(chapterDocIndex, chapterTitle, chapterHref, chapterDocList, element, readerMode, tempLocation, doc);
    if (readerMode === "double") {
        yield handleRenderPDFChapter(chapterDocIndex + 1, chapterTitle, chapterHref, chapterDocList, element, readerMode, tempLocation, doc);
    }
});
const handlePDFRecord = (element, readerMode, tempLocation, doc) => __awaiter(void 0, void 0, void 0, function* () {
    let subIframes = doc.querySelectorAll("iframe");
    console.log(subIframes, "subiframes");
    for (let index = 0; index < subIframes.length; index++) {
        let subIframe = subIframes[index];
        if (isPDFScrolledIntoView(element, subIframe, readerMode)) {
            tempLocation.chapterDocIndex = index + "";
            tempLocation.percentage = index / subIframes.length + "";
            break;
        }
    }
});

class PdfRender extends GeneralRender {
    constructor(pdfBuffer, config) {
        super(Object.assign(Object.assign({ format: "PDF" }, config), { convertChinese: "Default" }));
        this.pdfBuffer = pdfBuffer;
    }
    renderTo(element) {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            this.element = element;
            if (!this.book) {
                yield this.parse();
            }
            let parser = new GeneralParser(this.book);
            this.chapterList = yield parser.getChapter(this.book.toc);
            this.chapterDocList = yield parser.getChapterDoc();
            createIframe(element);
            const viewport = yield this.chapterDocList[0].text.getDimension();
            console.log("viewport", viewport);
            let doc = this.getDocument();
            if (!doc)
                return;
            console.log("doc", doc);
            createPDFIframe(doc.body || doc.documentElement, this.chapterDocList, viewport);
            if (this.readerMode === "scroll") {
                let subIframe = doc.querySelectorAll("iframe")[0];
                let iframeHeight = subIframe === null || subIframe === void 0 ? void 0 : subIframe.getBoundingClientRect().height;
                let iframe = this.getIframe();
                if (!iframe)
                    return;
                iframe.style.height = iframeHeight * this.chapterDocList.length + "px";
                this.element.addEventListener("scroll", (e) => {
                    console.log("scroll");
                    handlePDFScrollEvent(this.chapterDocList, element, this.readerMode, this.tempLocation, doc);
                });
            }
            handlePDFLayout(element, this.readerMode, doc);
            resolve();
        }));
    }
    parse() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                let blob = new Blob([this.pdfBuffer]);
                let file = new File([blob], "book", {
                    lastModified: new Date().getTime(),
                    type: blob.type,
                });
                if (yield isPDF(file)) {
                    this.book = yield makePDF(file, this.readerMode);
                }
            }
            catch (error) {
                console.error(error);
                throw error;
            }
        });
    }
    preCache() {
        return __awaiter(this, void 0, void 0, function* () {
            return "";
            // if (!this.book) {
            //   await this.parse();
            // }
            // return await getCache(this.book);
        });
    }
    goToChapterIndex(targetChapterIndex) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.flattenChapters.length > 0) {
                yield this.goToChapter(this.flattenChapters[targetChapterIndex].index, this.flattenChapters[targetChapterIndex].href, this.flattenChapters[targetChapterIndex].label);
            }
        });
    }
    goToChapter(chapterDocIndex, chapterHref, chapterTitle) {
        return __awaiter(this, void 0, void 0, function* () {
            let doc = this.getDocument();
            let iframe = this.getIframe();
            if (!doc || !iframe)
                return;
            yield renderPdfPage(chapterDocIndex, chapterTitle, chapterHref, this.chapterDocList, this.element, this.readerMode, this.tempLocation, doc);
            yield this.record();
            this.trigger("rendered");
        });
    }
    goToPosition(bookLocationStr) {
        return __awaiter(this, void 0, void 0, function* () {
            let doc = this.getDocument();
            let iframe = this.getIframe();
            if (!doc || !iframe)
                return;
            let bookLocation = JSON.parse(bookLocationStr);
            this.tempLocation = {
                text: bookLocation.text,
                chapterTitle: bookLocation.chapterTitle,
                chapterDocIndex: bookLocation.chapterDocIndex,
                chapterHref: bookLocation.chapterHref,
                count: bookLocation.count,
                page: bookLocation.page,
            };
            let { chapterTitle, chapterDocIndex, chapterHref } = bookLocation;
            console.log(chapterDocIndex, "chapterdocindex");
            yield renderPdfPage(parseInt(chapterDocIndex), chapterTitle, chapterHref, this.chapterDocList, this.element, this.readerMode, this.tempLocation, doc);
            yield handleScrollPDFPosition(parseInt(chapterDocIndex), this.readerMode, doc);
            yield this.record();
            this.trigger("rendered");
            // this.addPageAnimation();
        });
    }
    prev() {
        return __awaiter(this, void 0, void 0, function* () {
            // this.trigger("page-changed");
            let doc = this.getDocument();
            let iframe = this.getIframe();
            if (!doc || !iframe) {
                return;
            }
            if (this.readerMode === "scroll") {
                // scroll readerMode under normal condition
                this.element.scrollBy({
                    left: 0,
                    top: -(this.element.clientHeight - 50),
                    behavior: "smooth",
                });
            }
            else {
                yield handleScrollPage(this.element, this.animation, 1, doc, this.flipToNextPage, this.flipToPrevPage, this.isMobile);
                yield renderPdfPage(parseInt(this.tempLocation.chapterDocIndex) -
                    (this.readerMode === "double" ? 2 : 1), this.tempLocation.chapterTitle, this.tempLocation.chapterHref, this.chapterDocList, this.element, this.readerMode, this.tempLocation, doc);
            }
            this.trigger("rendered");
            yield this.record();
        });
    }
    next() {
        return __awaiter(this, void 0, void 0, function* () {
            // this.trigger("page-changed");
            let doc = this.getDocument();
            let iframe = this.getIframe();
            if (!doc || !iframe) {
                return;
            }
            if (this.readerMode === "scroll") {
                // scroll readerMode under normal condition
                this.element.scrollBy({
                    left: 0,
                    top: this.element.clientHeight - 50,
                    behavior: "smooth",
                });
            }
            else {
                // single and double readerMode under normal condition
                yield handleScrollPage(this.element, this.animation, -1, doc, this.flipToNextPage, this.flipToPrevPage, this.isMobile);
                console.log(this.tempLocation.chapterDocIndex, "this.tempLocation.chapterDocIndex");
                yield renderPdfPage(parseInt(this.tempLocation.chapterDocIndex) +
                    (this.readerMode === "double" ? 2 : 1), this.tempLocation.chapterTitle, this.tempLocation.chapterHref, this.chapterDocList, this.element, this.readerMode, this.tempLocation, doc);
            }
            this.trigger("rendered");
            yield this.record();
        });
    }
    record() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.animation !== "") {
                yield new Promise((r) => setTimeout(r, 1000));
            }
            let doc = this.getDocument();
            if (!doc)
                return;
            yield handlePDFRecord(this.element, this.readerMode, this.tempLocation, doc);
            this.trigger("page-changed");
        });
    }
    getMetadata() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                if (!this.book) {
                    yield this.parse();
                }
                let parser = new GeneralParser(this.book);
                return yield parser.getMetadata();
            }
            catch (error) {
                console.error(error);
                throw error;
            }
        });
    }
    getProgress() {
        return {
            totalPage: this.chapterDocList.length,
            currentPage: this.tempLocation.chapterDocIndex,
        };
    }
    getSubDocument(chapterDocIndex) {
        let pageArea = document.getElementById("page-area");
        if (!pageArea)
            return null;
        let iframe = pageArea.getElementsByTagName("iframe")[0];
        if (!iframe)
            return null;
        let doc = iframe.contentDocument;
        if (!doc) {
            return null;
        }
        let subIframe = doc.getElementById("pdf-iframe-" + chapterDocIndex);
        if (subIframe) {
            doc = subIframe.contentDocument;
        }
        return doc;
    }
    getSubIframe(chapterDocIndex) {
        let pageArea = document.getElementById("page-area");
        if (!pageArea)
            return null;
        let iframe = pageArea.getElementsByTagName("iframe")[0];
        if (!iframe)
            return null;
        let doc = iframe.contentDocument;
        if (!doc) {
            return null;
        }
        iframe = doc.getElementById("pdf-iframe-" + chapterDocIndex);
        return iframe;
    }
    getHightlightCoords(chapterDocIndex) {
        return __awaiter(this, void 0, void 0, function* () {
            let pageIndex = chapterDocIndex || this.tempLocation.chapterDocIndex;
            let doc = this.getSubDocument(chapterDocIndex);
            if (!doc)
                return;
            var selectionRects = doc.getSelection().getRangeAt(0).getClientRects();
            let page = yield this.chapterDocList[pageIndex].text.getPage();
            let scale = yield getPdfScale(this.element, this.readerMode, this.chapterDocList, pageIndex);
            var viewport = page.getViewport({ scale: scale });
            let canvas = doc.querySelector("canvas");
            var pageRect = canvas === null || canvas === void 0 ? void 0 : canvas.getClientRects()[0];
            let tempRect = [];
            for (let i = 0; i < selectionRects.length; i++) {
                if (i === 0) {
                    tempRect.push({
                        bottom: selectionRects[i].bottom,
                        top: selectionRects[i].top,
                        left: selectionRects[i].left,
                        right: selectionRects[i].right,
                    });
                }
                else if (Math.abs(tempRect[tempRect.length - 1].bottom - selectionRects[i].bottom) < 5) {
                    if (tempRect[tempRect.length - 1].left > selectionRects[i].left) {
                        tempRect[tempRect.length - 1].left = selectionRects[i].left;
                    }
                    if (tempRect[tempRect.length - 1].right < selectionRects[i].right) {
                        tempRect[tempRect.length - 1].right = selectionRects[i].right;
                    }
                }
                else {
                    tempRect.push({
                        bottom: selectionRects[i].bottom,
                        top: selectionRects[i].top,
                        left: selectionRects[i].left,
                        right: selectionRects[i].right,
                    });
                }
            }
            var selected = tempRect.map(function (r) {
                return viewport
                    .convertToPdfPoint(r.left - pageRect.x, r.top - pageRect.y)
                    .concat(viewport.convertToPdfPoint(r.right - pageRect.x, r.bottom - pageRect.y));
            });
            return { page: pageIndex, coords: selected, readerMode: this.readerMode };
        });
    }
    renderHighlighters(notes, handleNoteClick, chapterDocIndex) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            let chapterIndex = chapterDocIndex || this.tempLocation.chapterDocIndex;
            let iframe = this.getSubIframe(chapterIndex);
            let doc = this.getSubDocument(chapterIndex);
            if (!doc || !iframe)
                return;
            clearHighlight(doc);
            console.log("sdfasfswe");
            let iWin = iframe.contentWindow || ((_a = iframe.contentDocument) === null || _a === void 0 ? void 0 : _a.defaultView);
            for (let index = 0; index < notes.length; index++) {
                const item = notes[index];
                let selected = JSON.parse(item.range);
                var pageIndex = selected.page;
                if (pageIndex !== chapterIndex) {
                    continue;
                }
                let page = yield this.chapterDocList[pageIndex].text.getPage();
                let scale = yield getPdfScale(this.element, this.readerMode, this.chapterDocList, pageIndex);
                console.log(page, "page");
                try {
                    showPDFHighlight(selected, item.color, item.key, handleNoteClick, page, scale, doc);
                }
                catch (e) {
                    console.warn(e, "Exception has been caught when restore character ranges.");
                    return;
                }
                if (!iWin || !iWin.getSelection())
                    return;
                (_b = iWin.getSelection()) === null || _b === void 0 ? void 0 : _b.empty();
            }
        });
    }
    removeOneNote(key, chapterDocIndex) {
        let doc = this.getSubDocument(chapterDocIndex || this.tempLocation.chapterDocIndex);
        if (!doc)
            return;
        const elements = doc.querySelectorAll(".kookit-note");
        for (let index = 0; index < elements.length; index++) {
            const element = elements[index];
            const dataKey = element.getAttribute("data-key");
            if (dataKey === key) {
                element.parentNode.removeChild(element);
            }
        }
    }
    createOneNote(item, handleNoteClick, chapterDocIndex) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            let iframe = this.getSubIframe(chapterDocIndex || this.tempLocation.chapterDocIndex);
            let doc = this.getSubDocument(chapterDocIndex || this.tempLocation.chapterDocIndex);
            if (!doc || !iframe)
                return;
            let iWin = iframe.contentWindow || ((_a = iframe.contentDocument) === null || _a === void 0 ? void 0 : _a.defaultView);
            let selected = JSON.parse(item.range);
            var pageIndex = selected.page;
            let page = yield this.chapterDocList[pageIndex].text.getPage();
            let scale = yield getPdfScale(this.element, this.readerMode, this.chapterDocList, pageIndex);
            showPDFHighlight(selected, item.color, item.key, handleNoteClick, page, scale, doc);
            if (!iWin || !iWin.getSelection())
                return;
            (_b = iWin.getSelection()) === null || _b === void 0 ? void 0 : _b.empty();
        });
    }
}

class TxtRender extends GeneralRender {
    constructor(txtBuffer, config) {
        super(Object.assign({ format: "TXT" }, config));
        this.txtBuffer = txtBuffer;
        this.charset = config.charset;
        this.parserRegex = config.parserRegex;
    }
    renderTo(element) {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            this.element = element;
            if (!this.book) {
                yield this.parse();
            }
            let parser = new GeneralParser(this.book);
            this.chapterList = yield parser.getChapter(this.book.toc);
            this.chapterDocList = yield parser.getChapterDoc();
            createIframe(element);
            let doc = this.getDocument();
            if (!doc)
                return;
            handleLayout(element, this.readerMode, doc);
            resolve();
        }));
    }
    parse() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const textDecoder = new TextDecoder(this.charset);
                const bytes = new Uint8Array(this.txtBuffer);
                let text = textDecoder.decode(bytes);
                this.book = makeHtmlBook(text, true, this.parserRegex);
            }
            catch (error) {
                console.error(error);
                throw error;
            }
        });
    }
    preCache() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.book) {
                yield this.parse();
            }
            return yield getCache(this.book);
        });
    }
    getMetadata(txtBuffer) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const array = new Uint8Array(txtBuffer);
                let charset = chardet.detect(array);
                this.charset = charset || "utf8";
                return { charset: charset || "utf8" };
            }
            catch (error) {
                console.error(error);
                throw error;
            }
        });
    }
}

const makeComicBook = ({ entries, loadBlob, getSize }, file, readerMode) => {
  const cache = new Map();
  const urls = new Map();
  const load = async (name, nameExtra) => {
    if (cache.has(name)) return cache.get(name);
    if (nameExtra) {
      const src = URL.createObjectURL(await loadBlob(name));
      const srcExtra = URL.createObjectURL(await loadBlob(nameExtra));
      const page = URL.createObjectURL(
        new Blob([`<div style="width:100%; height:100%"><img src="${src}"></div><div style="width:100%; height:100%"><img src="${srcExtra}"></div>`], { type: "text/html" })
      );
      urls.set(name, [src, page]);
      cache.set(name, page);
      return page;
    } else {
      const src = URL.createObjectURL(await loadBlob(name));
      const page = URL.createObjectURL(
        new Blob([`<div style="width:100%; height:100%"><img src="${src}"></div>`], { type: "text/html" })
      );
      urls.set(name, [src, page]);
      cache.set(name, page);
      return page;
    }


  };
  const unload = (name) => {
    urls.get(name)?.forEach?.((url) => URL.revokeObjectURL(url));
    urls.delete(name);
    cache.delete(name);
  };

  const exts = [".jpg", ".jpeg", ".png", ".gif", ".bmp", ".webp", ".svg"];
  const files = entries
    .map((entry) => entry.filename)
    .filter((name) => exts.some((ext) => name.endsWith(ext)))
    .sort();

  const book = {};
  book.getCover = () => loadBlob(files[0]);
  book.metadata = { title: file.name };
  book.sections = files.map((name, index) => ({
    id: name,
    load: () => {
      if (readerMode === "double") {
        const nameExtra = files[index + 1];
        return load(name, nameExtra)
      } else {
        return load(name)
      }

    },
    unload: () => unload(name),
    size: getSize(name),
  })).filter((_, i) => {
    if (readerMode === "double") {
      return i % 2 === 0
    } else {
      return true
    }
  });
  book.toc = files.map((name) => ({ label: name, href: name })).filter((_, i) => {
    if (readerMode === "double") {
      return i % 2 === 0
    } else {
      return true
    }
  });
  book.rendition = { layout: "pre-paginated" };
  book.resolveHref = (href) => ({
    index: book.sections.findIndex((s) => s.id === href),
  });
  book.splitTOCHref = (href) => [href, null];
  book.getTOCFragment = (doc) => doc.documentElement;
  return book;
};

class ComicRender extends GeneralRender {
    constructor(comicBuffer, config) {
        super(config);
        this.comicBuffer = comicBuffer;
        this.readerMode = config.readerMode;
        this.format = config.format;
        this.chapterList = [];
        this.chapterDocList = [];
        this.book = "";
        this.element = "";
        this.rpc;
    }
    renderTo(element) {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            this.element = element;
            createIframe(element);
            if (!this.book) {
                try {
                    yield this.parse();
                }
                catch (error) {
                    console.error(error);
                    reject(error);
                }
            }
            let parser = new GeneralParser(this.book);
            this.chapterList = yield parser.getChapter(this.book.toc);
            this.chapterDocList = yield parser.getChapterDoc();
            let doc = this.getDocument();
            if (!doc)
                return;
            handleLayout(element, this.readerMode, doc);
            resolve();
        }));
    }
    parse() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                let blob = new Blob([this.comicBuffer]);
                let file = new File([blob], "book." + this.format.toLocaleLowerCase(), {
                    lastModified: new Date().getTime(),
                    type: blob.type,
                });
                if (this.format === "CBZ") {
                    const loader = yield this.makeZipLoader(file);
                    this.book = makeComicBook(loader, file, this.readerMode);
                }
                else if (this.format === "CBT") {
                    const loader = yield this.makeTarLoader();
                    this.book = makeComicBook(loader, file, this.readerMode);
                }
                else if (this.format === "CBR") {
                    this.rpc = yield window.RPC.new("./lib/libunrar/worker.js", {
                        loaded: function () {
                            console.info("loaded");
                        },
                        progressShow: function (fileName, fileSize, progress) {
                            console.info(progress);
                        },
                    });
                    yield new Promise((r) => setTimeout(r, 200));
                    const loader = yield this.makeRarLoader();
                    this.book = makeComicBook(loader, file, this.readerMode);
                }
                else if (this.format === "CB7") {
                    const loader = yield this.make7zLoader();
                    this.book = makeComicBook(loader, file, this.readerMode);
                }
            }
            catch (error) {
                console.error(error);
                throw error;
            }
        });
    }
    preCache() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.book) {
                yield this.parse();
            }
            return yield getCache(this.book);
        });
    }
    makeZipLoader(file) {
        return __awaiter(this, void 0, void 0, function* () {
            let zip = yield JSZip.loadAsync(file);
            const entries = zip.files;
            const loadText = (name) => __awaiter(this, void 0, void 0, function* () {
                let entry = zip.file(name);
                if (entry) {
                    return entry.async("string");
                }
                return "";
            });
            const loadBlob = (name) => __awaiter(this, void 0, void 0, function* () {
                let entry = zip.file(name);
                if (entry) {
                    let buffer = yield entry.async("arraybuffer");
                    return new Blob([buffer]);
                }
                return new Blob([new ArrayBuffer(0)]);
            });
            const getSize = (name) => {
                return 0;
            };
            return {
                entries: Object.values(entries).map((item) => {
                    return { filename: item.name };
                }),
                loadText,
                loadBlob,
                getSize,
            };
        });
    }
    makeTarLoader() {
        return __awaiter(this, void 0, void 0, function* () {
            const entries = yield untar(this.comicBuffer);
            const map = new Map(entries.map((entry) => [entry.name, entry]));
            const load = (f) => (name, ...args) => map.has(name) ? f(map.get(name), ...args) : null;
            const loadText = load((entry) => entry.readAsString());
            const loadBlob = load((entry, type) => entry.blob);
            const getSize = (name) => { var _a, _b; return (_b = (_a = map.get(name)) === null || _a === void 0 ? void 0 : _a.size) !== null && _b !== void 0 ? _b : 0; };
            return {
                entries: entries.map((item) => {
                    return { filename: item.name };
                }),
                loadText,
                loadBlob,
                getSize,
            };
        });
    }
    makeRarLoader() {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                var buffers = [this.comicBuffer];
                var dataToPass = [{ name: "book.rar", content: this.comicBuffer }];
                var password = null;
                this.rpc.transferables = buffers;
                this.rpc
                    .unrar(dataToPass, password, 0)
                    .then((ret) => {
                    let entries = this.getRarEntries(ret.ls);
                    const map = new Map(Object.values(entries).map((entry) => [
                        entry.fullFileName,
                        entry,
                    ]));
                    const load = (f) => (name, ...args) => map.has(name) ? f(map.get(name), ...args) : null;
                    const loadText = load((entry) => entry.fullFileName);
                    const loadBlob = load((entry, type) => new Blob([entry.fileContent]));
                    const getSize = (name) => { var _a, _b; return (_b = (_a = map.get(name)) === null || _a === void 0 ? void 0 : _a.fileSize) !== null && _b !== void 0 ? _b : 0; };
                    resolve({
                        entries: Object.values(entries).map((item) => {
                            return { filename: item.fullFileName };
                        }),
                        loadText,
                        loadBlob,
                        getSize,
                    });
                })
                    .catch((err) => {
                    console.error(err);
                    reject(err);
                });
            });
        });
    }
    make7zLoader() {
        return __awaiter(this, void 0, void 0, function* () {
            const wasmBinaryFile = "./lib/7z-wasm/7zz.wasm";
            if (!window.wasmBinary) {
                const response = yield fetch(wasmBinaryFile, {
                    credentials: "same-origin",
                });
                if (!response["ok"]) {
                    throw "failed to load wasm binary file at '" + wasmBinaryFile + "'";
                }
                window.wasmBinary = yield response["arrayBuffer"]();
            }
            const sevenZip = yield window.SevenZip({
                wasmBinary: window.wasmBinary,
            });
            const archiveData = new Uint8Array(this.comicBuffer);
            const archiveName = "archive.cb7";
            const stream = sevenZip.FS.open(archiveName, "w+");
            sevenZip.FS.write(stream, archiveData, 0, archiveData.length);
            sevenZip.FS.close(stream);
            sevenZip.callMain(["x", archiveName]);
            const loader = sevenZip.FS;
            const entries = this.get7zEntries(loader.lookupPath("/").node);
            const map = new Map(entries.map((entry) => [entry.name, entry]));
            const load = (f) => (name, ...args) => map.has(name) ? f(map.get(name), ...args) : null;
            const loadText = load((entry) => entry.name);
            const loadBlob = load((entry, type) => new Blob([entry.buffer]));
            const getSize = (name) => { var _a, _b; return (_b = (_a = map.get(name)) === null || _a === void 0 ? void 0 : _a.packSize) !== null && _b !== void 0 ? _b : 0; };
            return {
                entries: entries.map((item) => {
                    return { filename: item.name };
                }),
                loadText,
                loadBlob,
                getSize,
            };
        });
    }
    getRarEntries(Node) {
        const list = Object.keys(Node);
        let entries = [];
        for (let index = 0; index < list.length; index++) {
            const item = list[index];
            if (Node[item].type === "dir") {
                entries = entries.concat(this.getRarEntries(Node[item].ls));
            }
            else {
                entries.push({
                    fullFileName: item,
                    fileContent: Node[item].fileContent,
                    fileSize: Node[item].fileSize,
                });
            }
        }
        return entries;
    }
    get7zEntries(FSNode) {
        const contents = FSNode.contents;
        const list = Object.keys(contents).filter((item) => {
            return (item != "archive.cb7" &&
                item != "dev" &&
                item != "home" &&
                item != "proc" &&
                item != "tmp");
        });
        let entries = [];
        for (let index = 0; index < list.length; index++) {
            const item = list[index];
            if (contents[item].isFolder) {
                entries = entries.concat(this.get7zEntries(contents[item]));
            }
            else {
                entries.push({
                    name: item,
                    buffer: contents[item].contents,
                    size: contents[item].usedBytes,
                });
            }
        }
        return entries;
    }
    getMetadata() {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                try {
                    if (!this.book) {
                        yield this.parse();
                    }
                    const coverBlob = yield this.book.getCover();
                    var reader = new FileReader();
                    reader.readAsDataURL(coverBlob);
                    reader.onloadend = () => {
                        resolve({
                            cover: reader.result,
                        });
                    };
                }
                catch (error) {
                    console.error(error);
                    reject(error);
                }
            }));
        });
    }
}

const trim = (str) => str?.trim()?.replace(/\s{2,}/g, " ");
const getElementText = (el) => trim(el?.textContent);

const NS = {
  XLINK: "http://www.w3.org/1999/xlink",
  EPUB: "http://www.idpf.org/2007/ops",
};

const MIME = {
  XML: "application/xml",
  XHTML: "application/xhtml+xml",
};

const STYLE = {
  strong: ["strong", "self"],
  emphasis: ["em", "self"],
  style: ["span", "self"],
  a: "anchor",
  strikethrough: ["s", "self"],
  sub: ["sub", "self"],
  sup: ["sup", "self"],
  code: ["code", "self"],
  image: "image",
};

const TABLE = {
  tr: ["tr", ["align"]],
  th: ["th", ["colspan", "rowspan", "align", "valign"]],
  td: ["td", ["colspan", "rowspan", "align", "valign"]],
};

const POEM = {
  epigraph: ["blockquote"],
  subtitle: ["h2", STYLE],
  "text-author": ["p", STYLE],
  date: ["p", STYLE],
  stanza: "stanza",
};

const SECTION = {
  title: [
    "header",
    {
      p: ["h1", STYLE],
      "empty-line": ["br"],
    },
  ],
  epigraph: ["blockquote", "self"],
  image: "image",
  annotation: ["aside"],
  section: ["section", "self"],
  p: ["p", STYLE],
  poem: ["blockquote", POEM],
  subtitle: ["h2", STYLE],
  cite: ["blockquote", "self"],
  "empty-line": ["br"],
  table: ["table", TABLE],
  "text-author": ["p", STYLE],
};
POEM["epigraph"].push(SECTION);

const BODY = {
  image: "image",
  title: [
    "section",
    {
      p: ["h1", STYLE],
      "empty-line": ["br"],
    },
  ],
  epigraph: ["section", SECTION],
  section: ["section", SECTION],
};

const getImageSrc = (el) => {
  const href = el.getAttributeNS(NS.XLINK, "href");
  const [, id] = href.split("#");
  const bin = el.getRootNode().getElementById(id);
  return bin
    ? `data:${bin.getAttribute("content-type")};base64,${bin.textContent}`
    : href;
};

class FB2Converter {
  constructor(fb2) {
    this.fb2 = fb2;
    this.doc = document.implementation.createDocument(NS.XHTML, "html");
  }
  image(node) {
    const el = this.doc.createElement("img");
    el.alt = node.getAttribute("alt");
    el.title = node.getAttribute("title");
    el.setAttribute("src", getImageSrc(node));
    return el;
  }
  anchor(node) {
    const el = this.convert(node, { a: ["a", STYLE] });
    el.setAttribute("href", node.getAttributeNS(NS.XLINK, "href"));
    if (node.getAttribute("type") === "note")
      el.setAttributeNS(NS.EPUB, "epub:type", "noteref");
    return el;
  }
  stanza(node) {
    const el = this.convert(node, {
      stanza: [
        "p",
        {
          title: [
            "header",
            {
              p: ["strong", STYLE],
              "empty-line": ["br"],
            },
          ],
          subtitle: ["p", STYLE],
        },
      ],
    });
    for (const child of node.children)
      if (child.nodeName === "v") {
        el.append(this.doc.createTextNode(child.textContent));
        el.append(this.doc.createElement("br"));
      }
    return el;
  }
  convert(node, def) {
    // not an element; return text content
    if (node.nodeType === 3) return this.doc.createTextNode(node.textContent);
    if (node.nodeType === 4)
      return this.doc.createCDATASection(node.textContent);
    if (node.nodeType === 8) return this.doc.createComment(node.textContent);

    const d = def?.[node.nodeName];
    if (!d) return null;
    if (typeof d === "string") return this[d](node);

    const [name, opts] = d;
    const el = this.doc.createElement(name);

    // copy the ID, and set class name from original element name
    if (node.id) el.id = node.id;
    el.classList.add(node.nodeName);

    // copy attributes
    if (Array.isArray(opts))
      for (const attr of opts) el.setAttribute(attr, node.getAttribute(attr));

    // process child elements recursively
    const childDef = opts === "self" ? def : Array.isArray(opts) ? null : opts;
    let child = node.firstChild;
    while (child) {
      const childEl = this.convert(child, childDef);
      if (childEl) el.append(childEl);
      child = child.nextSibling;
    }
    return el;
  }
}

const parseXML = async (blob) => {
  const buffer = await blob.arrayBuffer();
  const str = new TextDecoder("utf-8").decode(buffer);
  const parser = new DOMParser();
  const doc = parser.parseFromString(str, MIME.XML);
  const encoding =
    doc.xmlEncoding ||
    // `Document.xmlEncoding` is deprecated, and already removed in Firefox
    // so parse the XML declaration manually
    str.match(
      /^<\?xml\s+version\s*=\s*["']1.\d+"\s+encoding\s*=\s*["']([A-Za-z0-9._-]*)["']/
    )?.[1];
  if (encoding && encoding.toLowerCase() !== "utf-8") {
    const str = new TextDecoder(encoding).decode(buffer);
    return parser.parseFromString(str, MIME.XML);
  }
  return doc;
};

const style = URL.createObjectURL(
  new Blob(
    [
      `
@namespace epub "http://www.idpf.org/2007/ops";
body > img, section > img {
    display: block;
    margin: auto;
}
.title {
    text-align: center;
}
body > section > .title, body.notesBodyType > .title {
    margin: 3em 0;
}
body.notesBodyType > section .title {
    text-align: left;
    margin: 1em 0;
}
p {
    text-indent: 1em;
    margin: 0;
}
:not(p) + p, p:first-child {
    text-indent: 0;
}
.poem p {
    text-indent: 0;
    margin: 1em 0;
}
.text-author, .date {
    text-align: end;
}
.text-author:before {
    content: "—";
}
table {
    border-collapse: collapse;
}
td, th {
    padding: .25em;
}
a[epub|type~="noteref"] {
    font-size: .75em;
    vertical-align: super;
}
body:not(.notesBodyType) > .title, body:not(.notesBodyType) > .epigraph {
    margin: 3em 0;
}
`,
    ],
    { type: "text/css" }
  )
);

const template = (html) => `<?xml version="1.0" encoding="utf-8"?>
<html xmlns="http://www.w3.org/1999/xhtml">
    <head><link href="${style}" rel="stylesheet" type="text/css"/></head>
    <body>${html}</body>
</html>`;

// name of custom ID attribute for TOC items
const dataID = "data-foliate-id";

const makeFB2 = async (blob) => {
  const book = {};
  const doc = await parseXML(blob);
  const converter = new FB2Converter(doc);

  const $ = (x) => doc.querySelector(x);
  const $$ = (x) => [...doc.querySelectorAll(x)];
  const getPerson = (el) => {
    const nick = getElementText(el.querySelector("nickname"));
    if (nick) return nick;
    const first = getElementText(el.querySelector("first-name"));
    const middle = getElementText(el.querySelector("middle-name"));
    const last = getElementText(el.querySelector("last-name"));
    const name = [first, middle, last].filter((x) => x).join(" ");
    const sortAs = last
      ? [last, [first, middle].filter((x) => x).join(" ")].join(", ")
      : null;
    return { name, sortAs };
  };
  const getDate = (el) => el?.getAttribute("value") ?? getElementText(el);
  const annotation = $("title-info annotation");
  book.metadata = {
    title: getElementText($("title-info book-title")),
    identifier: getElementText($("document-info id")),
    language: getElementText($("title-info lang")),
    author: $$("title-info author").map(getPerson),
    translator: $$("title-info translator").map(getPerson),
    producer: $$("document-info author")
      .map(getPerson)
      .concat($$("document-info program-used").map(getElementText)),
    publisher: getElementText($("publish-info publisher")),
    published: getDate($("title-info date")),
    modified: getDate($("document-info date")),
    description: annotation
      ? converter.convert(annotation, { annotation: ["div", SECTION] })
          .innerHTML
      : null,
    subject: $$("title-info genre").map(getElementText),
  };
  book.getCover = () =>
    fetch(getImageSrc($("coverpage image"))).then((res) => res.blob());

  // get convert each body
  const bodyData = Array.from(doc.querySelectorAll("body"), (body) => {
    const converted = converter.convert(body, { body: ["body", BODY] });
    return [
      Array.from(converted.children, (el) => {
        // get list of IDs in the section
        const ids = [el, ...el.querySelectorAll("[id]")].map((el) => el.id);
        return { el, ids };
      }),
      converted,
    ];
  });

  const sectionData = bodyData[0][0]
    // make a separate section for each section in the first body
    .map(({ el, ids }) => {
      // set up titles for TOC
      const titles = Array.from(
        el.querySelectorAll(":scope > section > .title"),
        (el, index) => {
          el.setAttribute(dataID, index);
          return { title: getElementText(el), index };
        }
      );
      return { ids, titles, el };
    })
    // for additional bodies, only make one section for each body
    .concat(
      bodyData.slice(1).map(([sections, body]) => {
        const ids = sections.map((s) => s.ids).flat();
        body.classList.add("notesBodyType");
        return { ids, el: body, linear: "no" };
      })
    )
    .map(({ ids, titles, el, linear }) => {
      const str = template(el.outerHTML);
      const blob = new Blob([str], { type: MIME.XHTML });
      const url = URL.createObjectURL(blob);
      const title = trim(
        el.querySelector(".title, .subtitle, p")?.textContent ??
          (el.classList.contains("title") ? el.textContent : "")
      );
      return {
        ids,
        title,
        titles,
        load: () => url,
        createDocument: () => new DOMParser().parseFromString(str, MIME.XHTML),
        // doo't count image data as it'd skew the size too much
        size:
          blob.size -
          Array.from(
            el.querySelectorAll("[src]"),
            (el) => el.getAttribute("src")?.length ?? 0
          ).reduce((a, b) => a + b, 0),
        linear,
      };
    });

  const idMap = new Map();
  book.sections = sectionData.map((section, index) => {
    const { ids, load, createDocument, size, linear } = section;
    for (const id of ids) if (id) idMap.set(id, index);
    return { id: index, load, createDocument, size, linear };
  });

  book.toc = sectionData
    .map(({ title, titles }, index) => {
      const id = index.toString();
      return {
        label: title,
        href: id,
        subitems: titles?.length
          ? titles.map(({ title, index }) => ({
              label: title,
              href: `${id}#${index}`,
            }))
          : null,
      };
    })
    .filter((item) => item);

  book.resolveHref = (href) => {
    const [a, b] = href.split("#");
    return a
      ? // the link is from the TOC
        {
          index: Number(a),
          anchor: (doc) => doc.querySelector(`[${dataID}="${b}"]`),
        }
      : // link from within the page
        { index: idMap.get(b), anchor: (doc) => doc.getElementById(b) };
  };
  book.splitTOCHref = (href) => href?.split("#")?.map((x) => Number(x)) ?? [];
  book.getTOCFragment = (doc, id) => doc.querySelector(`[${dataID}="${id}"]`);

  return book;
};

class Fb2Render extends GeneralRender {
    constructor(fb2Buffer, config) {
        super(Object.assign({ format: "FB2" }, config));
        this.fb2Buffer = fb2Buffer;
    }
    renderTo(element) {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            this.element = element;
            if (!this.book) {
                yield this.parse();
            }
            let parser = new GeneralParser(this.book);
            this.chapterList = yield parser.getChapter(this.book.toc);
            this.chapterDocList = yield parser.getChapterDoc();
            createIframe(element);
            let doc = this.getDocument();
            if (!doc)
                return;
            handleLayout(element, this.readerMode, doc);
            resolve();
        }));
    }
    parse() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                let blob = new Blob([this.fb2Buffer]);
                this.book = yield makeFB2(blob);
            }
            catch (error) {
                console.error(error);
                throw error;
            }
        });
    }
    preCache() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.book) {
                yield this.parse();
            }
            return yield getCache(this.book);
        });
    }
    getMetadata() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                if (!this.book) {
                    yield this.parse();
                }
                let parser = new GeneralParser(this.book);
                return yield parser.getMetadata();
            }
            catch (error) {
                console.error(error);
                throw error;
            }
        });
    }
}

class CacheRender extends GeneralRender {
    constructor(cacheBuffer, config) {
        super(Object.assign({ format: "CACHE" }, config));
        this.cacheBuffer = cacheBuffer;
    }
    renderTo(element) {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            this.element = element;
            this.book = yield makeCacheBook(this.cacheBuffer);
            let parser = new GeneralParser(this.book);
            this.chapterList = yield parser.getChapter(this.book.toc);
            this.chapterDocList = yield parser.getChapterDoc();
            createIframe(element);
            let doc = this.getDocument();
            if (!doc)
                return;
            handleLayout(element, this.readerMode, doc);
            resolve();
        }));
    }
}

class DocxRender extends GeneralRender {
    constructor(docxBuffer, config) {
        super(Object.assign({ format: "DOCX" }, config));
        this.docxBuffer = docxBuffer;
    }
    renderTo(element) {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            this.element = element;
            if (!this.book) {
                yield this.parse();
            }
            let parser = new GeneralParser(this.book);
            this.chapterList = yield parser.getChapter(this.book.toc);
            this.chapterDocList = yield parser.getChapterDoc();
            createIframe(element);
            let doc = this.getDocument();
            if (!doc)
                return;
            handleLayout(element, this.readerMode, doc);
            resolve();
        }));
    }
    parse() {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                try {
                    mammoth
                        .convertToHtml({ arrayBuffer: this.docxBuffer })
                        .then((res) => __awaiter(this, void 0, void 0, function* () {
                        this.book = makeHtmlBook(res.value, false);
                        resolve();
                    }));
                }
                catch (error) {
                    console.error(error);
                    reject(error);
                }
            });
        });
    }
    preCache() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.book) {
                yield this.parse();
            }
            return yield getCache(this.book);
        });
    }
}

class MdRender extends GeneralRender {
    constructor(mdBuffer, config) {
        super(Object.assign({ format: "MD" }, config));
        this.mdBuffer = mdBuffer;
    }
    renderTo(element) {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            this.element = element;
            if (!this.book) {
                yield this.parse();
            }
            let parser = new GeneralParser(this.book);
            this.chapterList = yield parser.getChapter(this.book.toc);
            this.chapterDocList = yield parser.getChapterDoc();
            createIframe(element);
            let doc = this.getDocument();
            if (!doc)
                return;
            handleLayout(element, this.readerMode, doc);
            resolve();
        }));
    }
    parse() {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                try {
                    var blob = new Blob([this.mdBuffer], { type: "text/plain" });
                    var reader = new FileReader();
                    reader.onload = (evt) => __awaiter(this, void 0, void 0, function* () {
                        var _a;
                        let docStr = yield marked((_a = evt.target) === null || _a === void 0 ? void 0 : _a.result);
                        this.book = makeHtmlBook(docStr, false);
                        resolve();
                    });
                    reader.readAsText(blob, "UTF-8");
                }
                catch (error) {
                    console.error(error);
                    reject(error);
                }
            });
        });
    }
    preCache() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.book) {
                yield this.parse();
            }
            return yield getCache(this.book);
        });
    }
}

class HtmlRender extends GeneralRender {
    constructor(htmlBuffer, config) {
        super(config);
        this.htmlBuffer = htmlBuffer;
    }
    renderTo(element) {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            this.element = element;
            if (!this.book) {
                yield this.parse();
            }
            let parser = new GeneralParser(this.book);
            this.chapterList = yield parser.getChapter(this.book.toc);
            this.chapterDocList = yield parser.getChapterDoc();
            createIframe(element);
            let doc = this.getDocument();
            if (!doc)
                return;
            handleLayout(element, this.readerMode, doc);
            resolve();
        }));
    }
    parse() {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                try {
                    var blob = new Blob([this.htmlBuffer], {
                        type: mimetype[this.format.toLocaleLowerCase()],
                    });
                    var reader = new FileReader();
                    reader.onload = (evt) => __awaiter(this, void 0, void 0, function* () {
                        var _a;
                        let html = (_a = evt.target) === null || _a === void 0 ? void 0 : _a.result;
                        if (this.format === "MHTML") {
                            html =
                                mhtml2html.convert(html).window.document.documentElement
                                    .innerHTML;
                        }
                        this.book = makeHtmlBook(html, false);
                        resolve();
                    });
                    reader.readAsText(blob, "UTF-8");
                }
                catch (error) {
                    console.error(error);
                    reject(error);
                }
            });
        });
    }
    preCache() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.book) {
                yield this.parse();
            }
            return yield getCache(this.book);
        });
    }
}

export { CacheRender, ComicRender, DocxRender, EpubRender, Fb2Render, HtmlRender, MdRender, MobiRender, PdfRender, TxtRender };
