import axios from 'axios';
import { createClient, AuthType } from 'webdav/dist/web/index.js';

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

const CloudConfig = {
    publicUrl: "https://api.960960.xyz",
    cloudUrl: "https://cloud.960960.xyz",
    devUrl: "https://cloudtest.960960.xyz",
};
const ThirdpartyConfig = {
    callbackUrl: "https://web.koodoreader.com/",
    dropboxClientId: "vnc67byrssocvy1",
    microsoftClientId: "506df58a-29ab-4020-afc5-6f423dc80f35",
    googleClientId: "1051055003225-ph1f5fvh328dhv7bco5jitlnfhg6ks2t.apps.googleusercontent.com",
    facebookClientId: "2845583825559500",
    githubClientId: "Ov23liJVzfvJMMEEZ8v2",
};
const LoginAuthRequest = {
    google: {
        clientId: ThirdpartyConfig.googleClientId,
        scopes: ["openid"],
        usePKCE: false,
        responseType: "code",
        redirectUri: ThirdpartyConfig.callbackUrl,
        extraParams: {
            prompt: "consent",
            scope: "openid",
        },
    },
    microsoft: {
        clientId: ThirdpartyConfig.microsoftClientId,
        scopes: ["openid", "profile", "User.Read", "offline_access"],
        usePKCE: false,
        responseType: "code",
        redirectUri: ThirdpartyConfig.callbackUrl,
        extraParams: {
            scope: "openid profile User.Read offline_access",
        },
    },
    facebook: {
        clientId: ThirdpartyConfig.facebookClientId,
        scopes: [],
        usePKCE: false,
        responseType: "code",
        redirectUri: ThirdpartyConfig.callbackUrl,
        extraParams: {
            scope: "",
        },
    },
    github: {
        clientId: ThirdpartyConfig.githubClientId,
        scopes: [],
        usePKCE: false,
        responseType: "code",
        redirectUri: ThirdpartyConfig.callbackUrl,
        extraParams: {
            scope: "",
        },
    },
};
const LoginDiscovery = {
    microsoft: {
        authorizationEndpoint: "https://login.microsoftonline.com/common/oauth2/v2.0/authorize",
        tokenEndpoint: "https://login.microsoftonline.com/common/oauth2/v2.0/token",
    },
    google: {
        authorizationEndpoint: "https://accounts.google.com/o/oauth2/v2/auth",
        tokenEndpoint: "https://oauth2.googleapis.com/token",
    },
    facebook: {
        authorizationEndpoint: "https://www.facebook.com/v12.0/dialog/oauth",
        tokenEndpoint: "https://graph.facebook.com/v12.0/oauth/access_token",
    },
    github: {
        authorizationEndpoint: "https://github.com/login/oauth/authorize",
        tokenEndpoint: "https://github.com/login/oauth/access_token",
    },
};
const DriveAuthRequest = {
    dropbox: {
        clientId: ThirdpartyConfig.dropboxClientId,
        scopes: [],
        usePKCE: false,
        responseType: "code",
        redirectUri: ThirdpartyConfig.callbackUrl,
        extraParams: {
            token_access_type: "offline",
        },
    },
    microsoft: {
        clientId: ThirdpartyConfig.microsoftClientId,
        scopes: [],
        usePKCE: false,
        responseType: "code",
        redirectUri: ThirdpartyConfig.callbackUrl,
        extraParams: {
            scope: "files.readwrite.appfolder offline_access",
        },
    },
    google: {
        clientId: ThirdpartyConfig.googleClientId,
        scopes: [],
        usePKCE: false,
        responseType: "code",
        redirectUri: ThirdpartyConfig.callbackUrl,
        extraParams: {
            prompt: "consent",
            scope: "https://www.googleapis.com/auth/drive.appdata",
            access_type: "offline",
        },
    },
};
const DriveDiscovery = {
    dropbox: {
        authorizationEndpoint: "https://www.dropbox.com/oauth2/authorize",
        tokenEndpoint: "https://www.dropbox.com/oauth2/token",
    },
    microsoft: {
        authorizationEndpoint: "https://login.microsoftonline.com/common/oauth2/v2.0/authorize",
        tokenEndpoint: "https://login.microsoftonline.com/common/oauth2/v2.0/token",
    },
    google: {
        authorizationEndpoint: "https://accounts.google.com/o/oauth2/v2/auth",
        tokenEndpoint: "https://oauth2.googleapis.com/token",
    },
};
var config = {
    CloudConfig,
    ThirdpartyConfig,
    LoginAuthRequest,
    LoginDiscovery,
    DriveAuthRequest,
    DriveDiscovery,
};

class DropboxBase {
    constructor(config, thirdpartyRequest) {
        this.config = config;
        this.thirdpartyRequest = thirdpartyRequest;
        // Initialize Dropbox client
    }
    listFiles(path) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const accessToken = yield this.refreshToken();
                const response = yield axios.post("https://api.dropboxapi.com/2/files/list_folder", {
                    path: "/" + path,
                }, {
                    headers: {
                        Authorization: `Bearer ${accessToken}`,
                        "Content-Type": "application/json",
                    },
                });
                console.log(response.data.entries.map((item) => item.name));
                return response.data.entries.map((item) => item.name);
            }
            catch (error) {
                console.error("Error listing files:", error);
                return [];
            }
        });
    }
    refreshToken() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.config.access_token &&
                this.config.expires_at > new Date().getTime()) {
                return this.config.access_token;
            }
            // Get access token
            let refreshToken = this.config.refresh_token;
            let res = yield this.thirdpartyRequest.refreshThirdToken({
                provider: "dropbox",
                refresh_token: refreshToken,
            });
            this.config.access_token = res.data.access_token;
            this.config.expires_at = new Date().getTime() + res.data.expires_in * 1000;
            return res.data.access_token;
        });
    }
    authToken(code) {
        return __awaiter(this, void 0, void 0, function* () {
            // Get refresh token
            let res = yield this.thirdpartyRequest.authThirdToken({
                provider: "dropbox",
                redirect_uri: ThirdpartyConfig.callbackUrl,
                code,
            });
            console.log(res);
            return res.data.refresh_token;
        });
    }
    getAuthUrl() {
        return `https://www.dropbox.com/oauth2/authorize?response_type=code&token_access_type=offline&client_id=${ThirdpartyConfig.dropboxClientId}&redirect_uri=${ThirdpartyConfig.callbackUrl}`;
    }
}

class DropboxUtil extends DropboxBase {
    constructor(config, thirdpartyRequest) {
        super(config, thirdpartyRequest);
        // Initialize Dropbox client
    }
    uploadFile(blob, destPath) {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            try {
                const accessToken = yield this.refreshToken();
                console.log("accessToken", accessToken);
                let fileName = destPath.split("/").pop() || "";
                let file = new File([blob], fileName, {
                    lastModified: new Date().getTime(),
                    type: blob.type,
                });
                const response = yield axios.post("https://content.dropboxapi.com/2/files/upload", file, {
                    headers: {
                        Authorization: `Bearer ${accessToken}`,
                        "Content-Type": "application/octet-stream",
                        "Dropbox-API-Arg": JSON.stringify({
                            path: "/" + fileName,
                            mode: "overwrite",
                            autorename: true,
                            mute: false,
                        }),
                    },
                    maxContentLength: Infinity,
                    maxBodyLength: Infinity,
                });
                console.log("File uploaded successfully:", response);
                if (response.status >= 300) {
                    console.error("Error occurred during file download:", response);
                    resolve(false);
                    return;
                }
                resolve(true);
            }
            catch (error) {
                console.error("Error uploading file:", error);
                resolve(false);
            }
        }));
        // Upload file
    }
    downloadFile(sourcePath) {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            try {
                const accessToken = yield this.refreshToken();
                const response = yield axios({
                    url: "https://content.dropboxapi.com/2/files/download",
                    method: "post",
                    headers: {
                        Authorization: `Bearer ${accessToken}`,
                        "Dropbox-API-Arg": JSON.stringify({
                            path: "/" + sourcePath,
                        }),
                    },
                    maxContentLength: Infinity,
                    maxBodyLength: Infinity,
                    responseType: "arraybuffer",
                });
                if (response.status >= 300) {
                    console.error("Error occurred during file download:", response);
                    resolve(new ArrayBuffer(0));
                    return;
                }
                resolve(response.data);
            }
            catch (error) {
                console.error("Error occurred during file download:", error);
                reject(error);
            }
        }));
    }
}

class GoogleDriveBase {
    constructor(config, thirdpartyRequest) {
        this.config = config;
        this.thirdpartyRequest = thirdpartyRequest;
        // Initialize Dropbox client
    }
    getFileId(fileName, folderId) {
        return __awaiter(this, void 0, void 0, function* () {
            const accessToken = yield this.refreshToken();
            const url = `https://www.googleapis.com/drive/v3/files?q=name='${fileName}'+and+'${folderId}'+in+parents&spaces=appDataFolder&fields=files(id,name)`;
            try {
                const response = yield axios.get(url, {
                    headers: {
                        Authorization: "Bearer " + accessToken,
                    },
                });
                if (response.data.files.length === 0) {
                    return "";
                }
                const files = response.data.files;
                console.log(files);
                if (files.length > 0) {
                    return files[0].id;
                }
                else {
                    return null;
                }
            }
            catch (error) {
                console.error("Error occurred during file list retrieval:", error);
                return "";
            }
        });
    }
    checkFolder(folderName) {
        return __awaiter(this, void 0, void 0, function* () {
            const accessToken = yield this.refreshToken();
            const folderId = yield this.getFolderId(folderName);
            if (folderId) {
                console.log("Folder already exists:", folderId);
                return folderId;
            }
            const metadata = {
                name: folderName,
                mimeType: "application/vnd.google-apps.folder",
                parents: ["appDataFolder"],
            };
            try {
                const response = yield axios.post("https://www.googleapis.com/drive/v3/files", metadata, {
                    headers: {
                        Authorization: `Bearer ${accessToken}`,
                        "Content-Type": "application/json",
                    },
                });
                console.log("Folder created:", response.data.id);
                return response.data.id;
            }
            catch (error) {
                console.error("Error occurred during folder creation:", error);
                throw error;
            }
        });
    }
    getFolderId(folderName) {
        return __awaiter(this, void 0, void 0, function* () {
            const accessToken = yield this.refreshToken();
            const url = `https://www.googleapis.com/drive/v3/files?q=name='${folderName}'+and+mimeType='application/vnd.google-apps.folder'+and+'appDataFolder'+in+parents&spaces=appDataFolder&fields=files(id,name)`;
            try {
                const response = yield axios.get(url, {
                    headers: {
                        Authorization: `Bearer ${accessToken}`,
                    },
                });
                const folders = response.data.files;
                if (folders.length > 0) {
                    return folders[0].id;
                }
                else {
                    return null;
                }
            }
            catch (error) {
                console.error("Error occurred during fetching folder ID:", error);
                throw error;
            }
        });
    }
    listFiles(path) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const accessToken = yield this.refreshToken();
                let folderId = yield this.checkFolder(path);
                console.log(folderId);
                const url = `https://www.googleapis.com/drive/v3/files?q='${folderId}'+in+parents&spaces=appDataFolder&fields=files(id,name)`;
                const response = yield axios.get(url, {
                    headers: {
                        Authorization: `Bearer ${accessToken}`,
                    },
                });
                console.log("Files in folder:", response.data.files.map((item) => item.name));
                return response.data.files;
            }
            catch (error) {
                console.error("Error listing files:", error);
                return [];
            }
        });
    }
    refreshToken() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.config.access_token &&
                this.config.expires_at > new Date().getTime()) {
                return this.config.access_token;
            }
            // Get access token
            let refreshToken = this.config.refresh_token;
            let res = yield this.thirdpartyRequest.refreshThirdToken({
                provider: "google",
                refresh_token: refreshToken,
            });
            this.config.access_token = res.data.access_token;
            this.config.expires_at = new Date().getTime() + res.data.expires_in * 1000;
            return res.data.access_token;
        });
    }
    authToken(code) {
        return __awaiter(this, void 0, void 0, function* () {
            let res = yield this.thirdpartyRequest.authThirdToken({
                provider: "google",
                redirect_uri: ThirdpartyConfig.callbackUrl,
                code,
            });
            console.log(res);
            return res.data.refresh_token;
        });
    }
    getAuthUrl() {
        return `https://accounts.google.com/o/oauth2/v2/auth?redirect_uri=${ThirdpartyConfig.callbackUrl}&prompt=consent&response_type=code&client_id=${ThirdpartyConfig.googleClientId}&scope=https://www.googleapis.com/auth/drive.appdata&access_type=offline`;
    }
}

const getMimeType = (ext) => {
    //包括json,所有的图片,压缩包,电子书
    if (ext === "json") {
        return "application/json";
    }
    else if (["jpg", "jpeg", "png", "gif", "bmp"].includes(ext)) {
        return "image/" + ext;
    }
    else if (ext === "zip") {
        return "application/zip";
    }
    else if (ext === "epub") {
        return "application/epub+zip";
    }
    else if (ext === "txt") {
        return "text/plain";
    }
    else if (ext === "pdf") {
        return "application/pdf";
    }
    else if (ext === "mobi") {
        return "application/x-mobipocket-ebook";
    }
    else if (ext === "azw3" || ext === "azw") {
        return "application/vnd.amazon.ebook";
    }
    else if (ext === "cbz") {
        return "application/x-cbz";
    }
    else if (ext === "cbr") {
        return "application/x-cbr";
    }
    else if (ext === "cbt") {
        return "application/x-cbt";
    }
    else if (ext === "cb7") {
        return "application/x-cb7";
    }
    else if (ext === "fb2") {
        return "application/x-fictionbook+xml";
    }
    else if (ext === "html") {
        return "text/html";
    }
    else if (ext === "css") {
        return "text/css";
    }
    else if (ext === "js") {
        return "application/javascript";
    }
    else if (ext === "xml") {
        return "application/xml";
    }
    else if (ext === "xhtml") {
        return "application/xhtml+xml";
    }
    else if (ext === "opf") {
        return "application/oebps-package+xml";
    }
    else if (ext === "ncx") {
        return "application/x-dtbncx+xml";
    }
    else if (ext === "mp3") {
        return "audio/mpeg";
    }
    else if (ext === "wav") {
        return "audio/wav";
    }
    else if (ext === "ogg") {
        return "audio/ogg";
    }
    else if (ext === "mp4") {
        return "video/mp4";
    }
    else if (ext === "webm") {
        return "video/webm";
    }
    else if (ext === "avi") {
        return "video/x-msvideo";
    }
    else if (ext === "wmv") {
        return "video/x-ms-wmv";
    }
    else if (ext === "flv") {
        return "video/x-flv";
    }
    else if (ext === "m3u8") {
        return "application/x-mpegURL";
    }
    else if (ext === "ts") {
        return "video/MP2T";
    }
    else if (ext === "3gp") {
        return "video/3gpp";
    }
    else if (ext === "3g2") {
        return "video/3gpp2";
    }
    else if (ext === "db") {
        return "application/x-sqlite3";
    }
};
const databaseList = ["books", "notes", "bookmarks", "plugins", "words"];
const configList = [
    "readerConfig",
    "themeColors",
    "readingTime",
    "recentBooks",
    "deletedBooks",
    "favoriteBooks",
    "shelfList",
    "noteTags",
    "recordLocation",
    "dataSourceList",
    "sortedShelfList",
];
const copyArrayBuffer = (src) => {
    var dst = new ArrayBuffer(src.byteLength);
    new Uint8Array(dst).set(new Uint8Array(src));
    return dst;
};
const base64ToArrayBuffer = (base64) => {
    const binaryString = atob(base64);
    const len = binaryString.length;
    const bytes = new Uint8Array(len);
    for (let i = 0; i < len; i++) {
        bytes[i] = binaryString.charCodeAt(i);
    }
    return bytes.buffer;
};
const arrayBufferToBase64 = (buffer) => {
    let binary = "";
    const bytes = new Uint8Array(buffer);
    const len = bytes.byteLength;
    for (let i = 0; i < len; i++) {
        binary += String.fromCharCode(bytes[i]);
    }
    return btoa(binary);
};
function generateSHA256Hash(message) {
    return __awaiter(this, void 0, void 0, function* () {
        // Encode the message as a Uint8Array
        const msgBuffer = new TextEncoder().encode(message);
        // Hash the message
        const hashBuffer = yield crypto.subtle.digest("SHA-256", msgBuffer);
        // Convert the hash to a byte array
        const hashArray = Array.from(new Uint8Array(hashBuffer));
        // Convert the byte array to a hex string
        const hashHex = hashArray
            .map((b) => b.toString(16).padStart(2, "0"))
            .join("");
        return hashHex;
    });
}
var common = {
    getMimeType,
    databaseList,
    configList,
    copyArrayBuffer,
    base64ToArrayBuffer,
    arrayBufferToBase64,
    generateSHA256Hash,
};

class GoogleDriveUtil extends GoogleDriveBase {
    constructor(config, thirdpartyRequest) {
        super(config, thirdpartyRequest);
        this.getData = (file) => {
            return new Promise((resolve, reject) => {
                if (file) {
                    const fr = new FileReader();
                    fr.onload = (f) => resolve({
                        fileName: file.name,
                        mimeType: file.type,
                        fileSize: file.size,
                        data: f.target.result,
                    });
                    fr.onerror = (err) => reject(err);
                    fr.readAsArrayBuffer(file);
                }
                else {
                    resolve({});
                }
            });
        };
        // Initialize Dropbox client
    }
    uploadFile(blob, destPath) {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            try {
                const accessToken = yield this.refreshToken();
                console.log(accessToken);
                let fileName = destPath.split("/").pop() || "";
                let file = new File([blob], fileName, {
                    lastModified: new Date().getTime(),
                    type: blob.type,
                });
                let fileType = destPath.split(".").pop();
                let mimeType = getMimeType(fileType || "");
                let folderName = destPath.split("/")[0];
                let folderId = yield this.checkFolder(folderName);
                let fileId = yield this.getFileId(fileName || "", folderId);
                console.log(fileId, "fileId");
                const metadata = {
                    mimeType: mimeType,
                    name: fileName,
                    parents: [folderId],
                };
                const url = fileId
                    ? `https://www.googleapis.com/upload/drive/v3/files/${fileId}?uploadType=resumable`
                    : "https://www.googleapis.com/upload/drive/v3/files?uploadType=resumable";
                console.log(url);
                const res = yield axios({
                    method: fileId ? "PATCH" : "POST",
                    url: url,
                    data: fileId ? null : JSON.stringify(metadata),
                    headers: {
                        Authorization: "Bearer " + accessToken,
                        "Content-Type": "application/json; charset=UTF-8",
                    },
                });
                const location = res.headers.location;
                console.log(location);
                const fileObj = yield this.getData(file);
                if (Object.keys(fileObj).length === 0) {
                    console.log("No file.");
                    return;
                }
                const response = yield axios.put(location, fileObj.data, {
                    headers: {
                        Authorization: "Bearer " + accessToken,
                        "Content-Type": "application/zip",
                        "Content-Range": `bytes 0-${fileObj.fileSize - 1}/${fileObj.fileSize}`,
                    },
                    maxContentLength: Infinity,
                    maxBodyLength: Infinity,
                });
                console.log("File uploaded successfully:", response);
                if (response.status >= 300) {
                    console.error("Error occurred during file download:", response);
                    resolve(false);
                    return;
                }
                resolve(true);
            }
            catch (error) {
                console.error("Error uploading file:", error);
                resolve(false);
            }
        }));
        // Upload file
    }
    downloadFile(sourcePath) {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            try {
                const accessToken = yield this.refreshToken();
                let fileName = sourcePath.split("/").pop();
                let folderName = sourcePath.split("/")[0];
                let folderId = yield this.checkFolder(folderName);
                let fileId = yield this.getFileId(fileName || "", folderId);
                if (!fileId) {
                    console.error("File not found");
                    reject(new Error("File not found"));
                }
                const downloadUrl = `https://www.googleapis.com/drive/v3/files/${fileId}?alt=media`;
                const response = yield axios.get(downloadUrl, {
                    headers: {
                        Authorization: "Bearer " + accessToken,
                    },
                    maxContentLength: Infinity,
                    maxBodyLength: Infinity,
                    responseType: "arraybuffer",
                });
                resolve(response.data);
            }
            catch (error) {
                console.error("Error occurred during file download:", error);
                reject(error);
            }
        }));
    }
}

class OneDriveBase {
    constructor(config, thirdpartyRequest) {
        this.config = config;
        this.thirdpartyRequest = thirdpartyRequest;
        // Initialize Dropbox client
    }
    listFiles(path) {
        return __awaiter(this, void 0, void 0, function* () {
            const accessToken = yield this.refreshToken();
            const response = yield axios.get(`https://graph.microsoft.com/v1.0/me/drive/special/approot:/${path}:/children`, {
                headers: {
                    Authorization: `Bearer ${accessToken}`,
                    "Content-Type": "application/json",
                },
            });
            if (response.status >= 300) {
                return [];
            }
            console.log(response.data, "response.data");
            console.log("Files in folder:", response.data.value.map((item) => item.name));
            return response.data.value.map((item) => item.name);
        });
    }
    refreshToken() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.config.access_token &&
                this.config.expires_at > new Date().getTime()) {
                return this.config.access_token;
            }
            // Get access token
            let refreshToken = this.config.refresh_token;
            let res = yield this.thirdpartyRequest.refreshThirdToken({
                provider: "microsoft",
                refresh_token: refreshToken,
            });
            this.config.access_token = res.data.access_token;
            this.config.expires_at = new Date().getTime() + res.data.expires_in * 1000;
            return res.data.access_token;
        });
    }
    authToken(code) {
        return __awaiter(this, void 0, void 0, function* () {
            console.log(code, "safdfsfd");
            console.log({
                provider: "microsoft",
                redirect_uri: ThirdpartyConfig.callbackUrl,
                code,
            });
            console.log(this.thirdpartyRequest, "this.thirdpartyRequest");
            let res = yield this.thirdpartyRequest.authThirdToken({
                provider: "microsoft",
                redirect_uri: ThirdpartyConfig.callbackUrl,
                code,
            });
            console.log(res);
            return res.data.refresh_token;
        });
    }
    getAuthUrl() {
        return `https://login.microsoftonline.com/common/oauth2/v2.0/authorize?client_id=${ThirdpartyConfig.microsoftClientId}&scope=files.readwrite.appfolder offline_access&response_type=code&redirect_uri=${ThirdpartyConfig.callbackUrl}`;
    }
}

class OneDriveUtil extends OneDriveBase {
    constructor(config, thirdpartyRequest) {
        super(config, thirdpartyRequest);
        // Initialize Dropbox client
    }
    uploadFile(blob, destPath) {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            try {
                const accessToken = yield this.refreshToken();
                console.log(accessToken);
                let fileName = destPath.split("/").pop() || "";
                let file = new File([blob], fileName, {
                    lastModified: new Date().getTime(),
                    type: blob.type,
                });
                const uploadSessionUrl = "https://graph.microsoft.com/v1.0/me/drive/special/approot:/" +
                    destPath +
                    ":/createUploadSession";
                const sessionResponse = yield axios.post(uploadSessionUrl, null, {
                    headers: {
                        Authorization: "Bearer " + accessToken,
                        "Content-Type": "application/json",
                    },
                });
                let fileSize = file.size;
                const mimeType = file.type;
                const uploadUrl = sessionResponse.data.uploadUrl;
                //TODO 是否能上传否则参考mobile
                const response = yield axios.put(uploadUrl, file, {
                    headers: {
                        "Content-Type": mimeType,
                        "Content-Range": `bytes 0-${fileSize - 1}/${fileSize}`,
                    },
                    maxContentLength: Infinity,
                    maxBodyLength: Infinity,
                });
                console.log("File uploaded successfully:", response);
                if (response.status >= 300) {
                    console.error("Error occurred during file download:", response);
                    resolve(false);
                    return;
                }
                resolve(true);
            }
            catch (error) {
                console.error("Error uploading file:", error);
                resolve(false);
            }
        }));
        // Upload file
    }
    downloadFile(sourcePath) {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            try {
                const accessToken = yield this.refreshToken();
                const downloadUrl = `https://graph.microsoft.com/v1.0/me/drive/special/approot:/${sourcePath}:/content`;
                const response = yield axios.get(downloadUrl, {
                    responseType: "arraybuffer",
                    headers: {
                        Authorization: "Bearer " + accessToken,
                    },
                    maxContentLength: Infinity,
                    maxBodyLength: Infinity,
                });
                console.log("File downloaded successfully:", response);
                resolve(response.data);
            }
            catch (error) {
                console.error("Error occurred during file download:", error);
                reject(error);
            }
        }));
    }
}

class OtherUtil {
    downloadFile(fileName, destPath) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve) => {
                resolve(true);
            });
        });
    }
    uploadFile(fileName, destPath) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve) => {
                resolve(true);
            });
        });
    }
    listFiles(path) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve) => {
                resolve([]);
            });
        });
    }
    authToken(code) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve) => {
                resolve("");
            });
        });
    }
    getAuthUrl() {
        return "";
    }
}

class S3Util {
    constructor(config, thirdpartyRequest) {
        this.config = config;
        this.thirdpartyRequest = thirdpartyRequest;
        // Initialize Dropbox client
    }
    uploadFile(blob, destPath) {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            let { endpoint, region, bucketName, accessKeyId, secretAccessKey } = this.config;
            try {
                let res = yield this.thirdpartyRequest.s3Upload({
                    bucket_name: bucketName,
                    object_key: destPath,
                    region: region,
                    endpoint: endpoint,
                    access_key_id: accessKeyId,
                    secret_access_key: secretAccessKey,
                });
                const uploadUrl = res.data.url;
                let fileName = destPath.split("/").pop() || "";
                let file = new File([blob], fileName, {
                    lastModified: new Date().getTime(),
                    type: blob.type,
                });
                const response = yield axios.put(uploadUrl, file, {
                    headers: {},
                });
                console.log("File uploaded successfully:", response);
                resolve(true);
            }
            catch (error) {
                console.error("Error occurred during file upload:", error);
                resolve(false);
            }
        }));
    }
    downloadFile(sourcePath) {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            let { endpoint, region, bucketName, accessKeyId, secretAccessKey } = this.config;
            try {
                let res = yield this.thirdpartyRequest.s3Download({
                    bucket_name: bucketName,
                    object_key: sourcePath,
                    region: region,
                    endpoint: endpoint,
                    access_key_id: accessKeyId,
                    secret_access_key: secretAccessKey,
                });
                const downloadUrl = res.data.url;
                const response = yield axios({
                    url: downloadUrl,
                    method: "post",
                    headers: {},
                    responseType: "arraybuffer",
                });
                resolve(response.data);
            }
            catch (error) {
                console.error("Error occurred during file download:", error);
                resolve(false);
            }
        }));
    }
    listFiles(targetPath) {
        return __awaiter(this, void 0, void 0, function* () {
            let { endpoint, region, bucketName, accessKeyId, secretAccessKey } = this.config;
            try {
                let res = yield this.thirdpartyRequest.s3List({
                    bucket_name: bucketName,
                    object_key: targetPath,
                    region: region,
                    endpoint: endpoint,
                    access_key_id: accessKeyId,
                    secret_access_key: secretAccessKey,
                });
                console.log("Files in folder:", res.data.contents.map((item) => item.split("/").pop()));
                return res.data.contents.map((item) => item.split("/").pop());
            }
            catch (error) {
                console.error("Error listing files:", error);
                return [];
            }
        });
    }
}

class WebDAVUtil {
    constructor(config) {
        let { username, password, url } = config;
        this.client = createClient(url, {
            authType: AuthType.Password,
            username,
            password,
        });
        this.username = username;
        this.password = password;
    }
    uploadFile(blob, destPath) {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            try {
                if ((yield this.client.exists(destPath.substring(0, destPath.lastIndexOf("/")))) === false) {
                    yield this.client.createDirectory(destPath.substring(0, destPath.lastIndexOf("/")));
                }
                let fileName = destPath.split("/").pop() || "";
                let file = new File([blob], fileName, {
                    lastModified: new Date().getTime(),
                    type: blob.type,
                });
                let uploadLink = this.client.getFileUploadLink(destPath);
                const parsedUrl = new URL(uploadLink);
                parsedUrl.search = ""; // 清除查询参数
                uploadLink = parsedUrl.toString();
                const base64Token = btoa(this.username + ":" + this.password);
                const response = yield axios.put(uploadLink, file, {
                    headers: {
                        Authorization: "Basic " + base64Token,
                    },
                });
                console.log("File uploaded successfully:", response);
                resolve(true);
            }
            catch (error) {
                console.error("Error uploading file:", error);
                resolve(false);
            }
        }));
        // Upload file
    }
    downloadFile(sourcePath) {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            try {
                const downloadLink = this.client.getFileDownloadLink(sourcePath);
                console.log(downloadLink);
                const base64Token = btoa(this.username + ":" + this.password);
                const response = yield axios({
                    url: downloadLink,
                    method: "get",
                    headers: {
                        Authorization: "Basic " + base64Token,
                    },
                    responseType: "arraybuffer",
                });
                if (response.status >= 300) {
                    console.error("Error occurred during file download:", response);
                    resolve(new ArrayBuffer(0));
                    return;
                }
                resolve(response.data);
            }
            catch (error) {
                console.error("Error occurred during file download:", error);
                reject(error);
            }
        }));
    }
    listFiles(path) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                let files = yield this.client.getDirectoryContents(path);
                console.log(files.map((file) => file.basename));
                return files.map((file) => file.basename);
            }
            catch (error) {
                console.error("Error listing files:", error);
                return [];
            }
        });
    }
}

const syncFolder = ["book", "config", "cover", "font"];
class SyncUtil {
    constructor(type, config, thirdpartyRequest) {
        this.type = type;
        if (type === "dropbox") {
            this.remote = new DropboxUtil(config, thirdpartyRequest);
        }
        else if (type === "microsoft") {
            this.remote = new OneDriveUtil(config, thirdpartyRequest);
        }
        else if (type === "google") {
            this.remote = new GoogleDriveUtil(config, thirdpartyRequest);
        }
        else if (type === "s3compatible") {
            this.remote = new S3Util(config, thirdpartyRequest);
        }
        else if (type === "webdav") {
            this.remote = new WebDAVUtil(config);
        }
        else {
            this.remote = new OtherUtil();
        }
    }
    downloadFile(fileName, type) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.remote.downloadFile(type + "/" + fileName);
        });
    }
    uploadFile(fileName, type, blob) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.remote.uploadFile(blob, type + "/" + fileName);
        });
    }
    listFiles(path) {
        return __awaiter(this, void 0, void 0, function* () {
            // List files
            return yield this.remote.listFiles(path);
        });
    }
    isExist(path, key) {
        return __awaiter(this, void 0, void 0, function* () {
            // Check if file exists
            let fileNames = yield this.listFiles(path);
            return fileNames.find((item) => item.indexOf(key) !== -1);
        });
    }
    downloadAllFiles() {
        return __awaiter(this, void 0, void 0, function* () {
            // Download all files
            for (let folder of syncFolder) {
                let files = yield this.listFiles(folder);
                for (let file of files) {
                    yield this.downloadFile(file, folder);
                }
            }
        });
    }
    authToken(code) {
        return __awaiter(this, void 0, void 0, function* () {
            // Auth token
            return yield this.remote.authToken(code);
        });
    }
    getAuthUrl() {
        return this.remote.getAuthUrl ? this.remote.getAuthUrl() : "";
    }
}

const createTableStatement = {
    notes: `
      CREATE TABLE IF NOT EXISTS "notes" (
        "key" text PRIMARY KEY,
        "bookKey" text,
        "date" object,
        "chapter" text,
        "chapterIndex" integer,
        "text" text,
        "cfi" text,
        "range" text,
        "notes" text,
        "percentage" text,
        "color" integer,
        "tag" array
      )
    `,
    bookmarks: `
      CREATE TABLE IF NOT EXISTS "bookmarks" (
        "key" text PRIMARY KEY,
        "bookKey" text,
        "cfi" text,
        "label" text,
        "percentage" text,
        "chapter" text
      );
    `,
    books: `
      CREATE TABLE IF NOT EXISTS "books" (
        "key" text PRIMARY KEY,
        "name" text,
        "author" text,
        "description" text,
        "md5" text,
        "cover" text,
        "format" text,
        "publisher" text,
        "size" integer,
        "page" integer,
        "path" text,
        "charset" text
      );
    `,
    plugins: `
      CREATE TABLE IF NOT EXISTS "plugins" (
        "key" text PRIMARY KEY,
        "type" text,
        "displayName" text,
        "icon" text,
        "version" text,
        "config" object,
        "autoValue" string,
        "langList" text,
        "voiceList" text,
        "scriptSHA256" text,
        "script" text
      );
    `,
    words: `
      CREATE TABLE IF NOT EXISTS "words" (
        "key" text PRIMARY KEY,
        "bookKey" text,
        "date" object,
        "word" text,
        "chapter" text
      );
    `,
};
const getAllStatement = {
    notes: "SELECT * FROM notes",
    bookmarks: "SELECT * FROM bookmarks",
    books: "SELECT * FROM books",
    plugins: "SELECT * FROM plugins",
    words: "SELECT * FROM words",
};
const saveStatement = {
    notes: "INSERT OR REPLACE INTO notes (key, bookKey, chapter, chapterIndex, text, cfi, range, notes, date, percentage, color, tag) VALUES (@key, @bookKey, @chapter, @chapterIndex, @text, @cfi, @range, @notes, @date, @percentage, @color, @tag)",
    bookmarks: "INSERT OR REPLACE INTO bookmarks (key, bookKey, cfi, label, percentage, chapter) VALUES (@key, @bookKey, @cfi, @label, @percentage, @chapter)",
    books: "INSERT OR REPLACE INTO books (key, name, author, description, md5, cover, format, publisher, size, page, path, charset) VALUES (@key, @name, @author, @description, @md5, @cover, @format, @publisher, @size, @page, @path, @charset)",
    plugins: "INSERT OR REPLACE INTO plugins (key, type, displayName, icon, version, config, autoValue, langList, voiceList, scriptSHA256, script) VALUES (@key, @type, @displayName, @icon, @version, @config, @autoValue, @langList, @voiceList, @scriptSHA256, @script)",
    words: "INSERT OR REPLACE INTO words (key, bookKey, date, word, chapter) VALUES (@key, @bookKey, @date, @word, @chapter)",
};
const deleteAllStatement = {
    notes: "DELETE FROM notes",
    bookmarks: "DELETE FROM bookmarks",
    books: "DELETE FROM books",
    plugins: "DELETE FROM plugins",
    words: "DELETE FROM words",
};
const updateStatement = {
    notes: "UPDATE notes SET bookKey = @bookKey, chapter = @chapter, chapterIndex = @chapterIndex, text = @text, cfi = @cfi, range = @range, notes = @notes, date = @date, percentage = @percentage, color = @color, tag = @tag WHERE key = @key",
    bookmarks: "UPDATE bookmarks SET bookKey = @bookKey, cfi = @cfi, label = @label, percentage = @percentage, chapter = @chapter WHERE key = @key",
    books: "UPDATE books SET name = @name, author = @author, description = @description, md5 = @md5, cover = @cover, format = @format, publisher = @publisher, size = @size, page = @page, path = @path, charset = @charset WHERE key = @key",
    plugins: "UPDATE plugins SET type = @type, displayName = @displayName, icon = @icon, version = @version, config = @config, autoValue = @autoValue, langList = @langList, voiceList = @voiceList, scriptSHA256 = @scriptSHA256, script = @script WHERE key = @key",
    words: "UPDATE words SET bookKey = @bookKey, date = @date, word = @word, chapter = @chapter WHERE key = @key",
};
const deleteStatement = {
    notes: "DELETE FROM notes WHERE key = ?",
    bookmarks: "DELETE FROM bookmarks WHERE key = ?",
    books: "DELETE FROM books WHERE key = ?",
    plugins: "DELETE FROM plugins WHERE key = ?",
    words: "DELETE FROM words WHERE key = ?",
};
const getStatement = {
    notes: `SELECT * FROM notes WHERE key = ?`,
    bookmarks: "SELECT * FROM bookmarks WHERE key = ?",
    books: "SELECT * FROM books WHERE key = ?",
    plugins: "SELECT * FROM plugins WHERE key = ?",
    words: "SELECT * FROM words WHERE key = ?",
};
const getByBookKeyStatement = {
    notes: `SELECT * FROM notes WHERE bookKey = ?`,
    bookmarks: "SELECT * FROM bookmarks WHERE bookKey = ?",
    words: "SELECT * FROM words WHERE bookKey = ?",
    books: "SELECT * FROM books WHERE key = ?",
};
const deleteByBookKeyStatement = {
    notes: `DELETE FROM notes WHERE bookKey = ?`,
    bookmarks: "DELETE FROM bookmarks WHERE bookKey = ?",
    words: "DELETE FROM words WHERE bookKey = ?",
};
const getByBookKeysStatement = {
    notes: (bookKeys) => `SELECT * FROM notes WHERE bookKey IN (${bookKeys
        .map(() => "?")
        .join(",")})`,
    bookmarks: (bookKeys) => `SELECT * FROM bookmarks WHERE bookKey IN (${bookKeys
        .map(() => "?")
        .join(",")})`,
    words: (bookKeys) => `SELECT * FROM words WHERE bookKey IN (${bookKeys
        .map(() => "?")
        .join(",")})`,
    books: (bookKeys) => `SELECT * FROM books WHERE key IN (${bookKeys.map(() => "?").join(",")})`,
};
const sqlStatement = {
    createTableStatement: addTempPrefix(createTableStatement),
    getAllStatement: addTempPrefix(getAllStatement),
    saveStatement: addTempPrefix(saveStatement),
    deleteAllStatement: addTempPrefix(deleteAllStatement),
    updateStatement: addTempPrefix(updateStatement),
    deleteStatement: addTempPrefix(deleteStatement),
    getStatement: addTempPrefix(getStatement),
    getByBookKeyStatement: addTempPrefix(getByBookKeyStatement),
    getByBookKeysStatement: addTempPrefix(getByBookKeysStatement),
    deleteByBookKeyStatement: addTempPrefix(deleteByBookKeyStatement),
};
function addTempPrefix(obj) {
    for (const key in obj) {
        if (obj.hasOwnProperty(key)) {
            obj[`temp-${key}`] = obj[key];
        }
    }
    return obj;
}
const jsonToSqlite = {
    notes: (note) => {
        let noteRaw = Object.assign({}, note);
        noteRaw.date = JSON.stringify(note.date);
        noteRaw.tag = JSON.stringify(note.tag);
        return noteRaw;
    },
    bookmarks: (bookmark) => {
        return bookmark;
    },
    books: (book) => {
        let bookRaw = Object.assign({}, book);
        bookRaw.page = book.page || 0;
        return bookRaw;
    },
    plugins: (plugin) => {
        let pluginRaw = Object.assign({}, plugin);
        if (!plugin.autoValue) {
            pluginRaw.autoValue = null;
        }
        if (!plugin.langList) {
            pluginRaw.langList = null;
        }
        else {
            pluginRaw.langList = JSON.stringify(plugin.langList);
        }
        if (!plugin.voiceList) {
            pluginRaw.voiceList = null;
        }
        else {
            pluginRaw.voiceList = JSON.stringify(plugin.voiceList);
        }
        pluginRaw.config = JSON.stringify(plugin.config);
        return pluginRaw;
    },
    words: (word) => {
        let wordRaw = Object.assign({}, word);
        wordRaw.date = JSON.stringify(word.date);
        return wordRaw;
    },
};
const sqliteToJson = {
    notes: (note) => {
        let noteRaw = Object.assign({}, note);
        noteRaw.date = JSON.parse(note.date);
        noteRaw.tag = JSON.parse(note.tag);
        return noteRaw;
    },
    bookmarks: (bookmark) => {
        return bookmark;
    },
    books: (book) => {
        return book;
    },
    plugins: (plugin) => {
        let pluginRaw = Object.assign({}, plugin);
        if (!plugin.autoValue) {
            delete pluginRaw.autoValue;
        }
        if (!plugin.langList) {
            delete pluginRaw.langList;
        }
        else {
            pluginRaw.langList = JSON.parse(plugin.langList);
        }
        if (!plugin.voiceList) {
            delete pluginRaw.voiceList;
        }
        else {
            pluginRaw.voiceList = JSON.parse(plugin.voiceList);
        }
        pluginRaw.config = JSON.parse(plugin.config);
        return pluginRaw;
    },
    words: (word) => {
        let wordRaw = Object.assign({}, word);
        wordRaw.date = JSON.parse(word.date);
        return wordRaw;
    },
};
var sqlStatement$1 = {
    sqlStatement,
    jsonToSqlite: addTempPrefix(jsonToSqlite),
    sqliteToJson: addTempPrefix(sqliteToJson),
};
// module.exports = { sqlStatement, jsonToSqlite, sqliteToJson };

class Book {
    constructor(key, name, author, description, md5, cover, format, publisher, size, page, path, charset) {
        this.key = key;
        this.name = name;
        this.author = author;
        this.description = description;
        this.md5 = md5;
        this.cover = cover;
        this.format = format;
        this.publisher = publisher;
        this.size = size;
        this.page = page;
        this.path = path;
        this.charset = charset;
    }
}

var _a;
class BookHelper {
    static generateBook(bookName, extension, md5, size, path, file_content, rendition) {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            try {
                let cover = "";
                let key, name, author, publisher, description, charset, page;
                [name, author, description, publisher, charset, page] = [
                    bookName,
                    "",
                    "",
                    "",
                    "",
                    0,
                ];
                let metadata;
                switch (extension) {
                    case "pdf":
                    case "epub":
                    case "mobi":
                    case "azw":
                    case "azw3":
                    case "fb2":
                        metadata = yield rendition.getMetadata();
                        [name, author, description, publisher, cover] = [
                            metadata.name || bookName,
                            metadata.author || "",
                            metadata.description || "",
                            metadata.publisher || "",
                            metadata.cover || "",
                        ];
                        break;
                    case "cbr":
                    case "cbt":
                    case "cbz":
                    case "cb7":
                        metadata = yield rendition.getMetadata();
                        cover = metadata.cover;
                        break;
                    case "txt":
                        metadata = yield rendition.getMetadata(file_content);
                        charset = metadata.charset;
                        break;
                    default:
                        break;
                }
                let format = extension.toUpperCase();
                key = new Date().getTime() + "";
                resolve(new Book(key, name, author, description, md5, cover, format, publisher, size, page, path, charset));
            }
            catch (error) {
                console.log(error);
                reject(error);
            }
        }));
    }
}
_a = BookHelper;
BookHelper.getRendtion = (result, format, readerMode, charset, animation, Kookit) => {
    let rendition;
    if (format === "CACHE") {
        rendition = new Kookit.CacheRender(result, readerMode, animation);
    }
    else if (format === "MOBI" || format === "AZW3" || format === "AZW") {
        rendition = new Kookit.MobiRender(result, readerMode, animation);
    }
    else if (format === "EPUB") {
        rendition = new Kookit.EpubRender(result, readerMode, animation);
    }
    else if (format === "TXT") {
        // let text = iconv.decode(Buffer.from(result), charset || "utf8");
        rendition = new Kookit.TxtRender(result, readerMode, animation, charset);
    }
    else if (format === "MD") {
        rendition = new Kookit.MdRender(result, readerMode, animation);
    }
    else if (format === "PDF") {
        rendition = new Kookit.PdfRender(result, readerMode, animation);
    }
    else if (format === "FB2") {
        rendition = new Kookit.Fb2Render(result, readerMode, animation);
    }
    else if (format === "DOCX") {
        rendition = new Kookit.DocxRender(result, readerMode, animation);
    }
    else if (format === "HTML" ||
        format === "XHTML" ||
        format === "MHTML" ||
        format === "HTM" ||
        format === "XML") {
        rendition = new Kookit.HtmlRender(result, readerMode, format, animation);
    }
    else if (format === "CBR" ||
        format === "CBT" ||
        format === "CBZ" ||
        format === "CB7") {
        rendition = new Kookit.ComicRender(copyArrayBuffer(result), readerMode, format, animation);
    }
    return rendition;
};
BookHelper.addMobileBook = (bookBase64, bookName, extension, md5, size, path) => __awaiter(void 0, void 0, void 0, function* () {
    let file_content = base64ToArrayBuffer(bookBase64);
    let rendition = _a.getRendtion(file_content, extension.toUpperCase(), "", "", "", window.Kookit);
    let bookInfo = yield BookHelper.generateBook(bookName, extension, md5, size, path, file_content, rendition);
    if (!bookInfo || !bookInfo.key) {
        return;
    }
    window.ReactNativeWebView.postMessage(JSON.stringify({ event: "metadata", bookInfo: bookInfo }));
    let cache = yield rendition.preCache(file_content);
    if (cache !== "err") {
        let cacheBase64 = arrayBufferToBase64(cache);
        window.ReactNativeWebView.postMessage(JSON.stringify({
            event: "cache",
            cacheBase64: cacheBase64,
            key: bookInfo.key,
        }));
    }
    else {
        window.ReactNativeWebView.postMessage(JSON.stringify({
            event: "error",
            message: "Parse book failed",
        }));
    }
});

class ReaderRequest {
    constructor(token) {
        this.accessToken = token;
    }
    getGoogleFont(fontFamily) {
        return __awaiter(this, void 0, void 0, function* () {
            let res = yield axios.post(CloudConfig.devUrl + "/api/v1/reader/get_google_font", {
                font_family: fontFamily,
            });
            console.log(res.data, "res.data");
            return {
                family: res.data.family,
                variants: JSON.parse(res.data.variants),
                files: JSON.parse(res.data.files),
            };
        });
    }
}

class BaseRequest {
    constructor(TokenService) {
        this.TokenService = TokenService;
    }
    refreshUserToken() {
        return __awaiter(this, void 0, void 0, function* () {
            let refreshToken = yield this.TokenService.getToken("refresh_token");
            let res = yield axios.post(CloudConfig.devUrl + "/api/v1/public/user/refresh_token", {
                refresh_token: refreshToken,
            });
            let result = res.data;
            console.log(result, "result");
            if (result.code === 200) {
                yield this.TokenService.setToken("access_token", result.data.access_token);
                yield this.TokenService.setToken("refresh_token", result.data.refresh_token);
            }
            return result;
        });
    }
    requestWithRetry(config) {
        return __awaiter(this, void 0, void 0, function* () {
            let accessToken = yield this.TokenService.getToken("access_token");
            config.baseURL = CloudConfig.devUrl;
            config.headers = {
                Authorization: "Bearer " + accessToken,
            };
            let res = yield axios(config);
            console.log(res.data, "res.data");
            let result = res.data;
            if (result.code === 402) {
                let response = yield this.refreshUserToken();
                if (response.code === 200) {
                    config.headers = config.headers || {};
                    config.headers.Authorization = "Bearer " + accessToken;
                    let res = yield axios(config);
                    let result = res.data;
                    return result;
                }
                else {
                    return response;
                }
            }
            return result;
        });
    }
}

class ThirdpartyRequest extends BaseRequest {
    constructor(TokenService) {
        // TODO 获取token改为从本地存储中获取
        super(TokenService);
    }
    encryptToken(request) {
        return __awaiter(this, void 0, void 0, function* () {
            console.log(request, "request");
            const config = {
                method: "post",
                url: "/api/v1/pro/thirdparty/encrypt_token",
                data: request,
            };
            let result = yield this.requestWithRetry(config);
            console.log(result, "result");
            return result;
        });
    }
    decryptToken(request) {
        return __awaiter(this, void 0, void 0, function* () {
            console.log(request, "request");
            const config = {
                method: "post",
                url: "/api/v1/pro/thirdparty/decrypt_token",
                data: request,
            };
            let result = yield this.requestWithRetry(config);
            console.log(result, "result");
            return result;
        });
    }
    authThirdToken(request) {
        return __awaiter(this, void 0, void 0, function* () {
            console.log(request, "request");
            const config = {
                method: "post",
                url: "/api/v1/pro/thirdparty/auth_token",
                data: request,
            };
            let result = yield this.requestWithRetry(config);
            console.log(result, "result");
            return result;
        });
    }
    refreshThirdToken(request) {
        return __awaiter(this, void 0, void 0, function* () {
            console.log(request, "request");
            const config = {
                method: "post",
                url: "/api/v1/pro/thirdparty/refresh_token",
                data: request,
            };
            let result = yield this.requestWithRetry(config);
            console.log(result, "result");
            return result;
        });
    }
    s3Upload(request) {
        return __awaiter(this, void 0, void 0, function* () {
            console.log(request, "request");
            const config = {
                method: "post",
                url: "/api/v1/pro/thirdparty/s3_upload",
                data: request,
            };
            let result = yield this.requestWithRetry(config);
            console.log(result, "result");
            return result;
        });
    }
    s3Download(request) {
        return __awaiter(this, void 0, void 0, function* () {
            console.log(request, "request");
            const config = {
                method: "post",
                url: "/api/v1/pro/thirdparty/s3_download",
                data: request,
            };
            let result = yield this.requestWithRetry(config);
            console.log(result, "result");
            return result;
        });
    }
    s3List(request) {
        return __awaiter(this, void 0, void 0, function* () {
            console.log(request, "request");
            const config = {
                method: "post",
                url: "/api/v1/pro/thirdparty/s3_list",
                data: request,
            };
            let result = yield this.requestWithRetry(config);
            console.log(result, "result");
            return result;
        });
    }
    getSyncState() {
        return __awaiter(this, void 0, void 0, function* () {
            const config = {
                method: "get",
                url: "/api/v1/pro/thirdparty/get_sync_state",
            };
            let result = yield this.requestWithRetry(config);
            console.log(result, "result");
            return result;
        });
    }
    deleteSyncState() {
        return __awaiter(this, void 0, void 0, function* () {
            const config = {
                method: "post",
                url: "/api/v1/pro/thirdparty/delete_sync_state",
            };
            let result = yield this.requestWithRetry(config);
            console.log(result, "result");
            return result;
        });
    }
}

class UserRequest extends BaseRequest {
    constructor(TokenService) {
        super(TokenService);
    }
    loginRegister(request) {
        return __awaiter(this, void 0, void 0, function* () {
            console.log(request, "request");
            const config = {
                method: "post",
                url: "/api/v1/public/user/login_register",
                data: request,
            };
            let result = yield this.requestWithRetry(config);
            console.log(result, "result");
            return result;
        });
    }
    logout() {
        return __awaiter(this, void 0, void 0, function* () {
            const config = {
                method: "post",
                url: "/api/v1/member/user/logout",
            };
            let result = yield this.requestWithRetry(config);
            console.log(result, "result");
            return result;
        });
    }
    getLogins() {
        return __awaiter(this, void 0, void 0, function* () {
            const config = {
                method: "get",
                url: "/api/v1/member/user/get_logins",
            };
            console.log(config, "config");
            let result = yield this.requestWithRetry(config);
            console.log(result, "result");
            return result;
        });
    }
    addLogin(request) {
        return __awaiter(this, void 0, void 0, function* () {
            console.log(request, "request");
            const config = {
                method: "post",
                url: "/api/v1/member/user/add_login",
                data: request,
            };
            let result = yield this.requestWithRetry(config);
            console.log(result, "result");
            return result;
        });
    }
    removeLogin(request) {
        return __awaiter(this, void 0, void 0, function* () {
            console.log(request, "request");
            const config = {
                method: "post",
                url: "/api/v1/member/user/remove_login",
                data: request,
            };
            let result = yield this.requestWithRetry(config);
            console.log(result, "result");
            return result;
        });
    }
}

const getAuthUrl = (provider, mode) => {
    let url = "";
    if (provider === "github") {
        url = `https://github.com/login/oauth/authorize?client_id=${ThirdpartyConfig.githubClientId}&redirect_uri=${ThirdpartyConfig.callbackUrl}&scope=openid`;
    }
    else if (provider === "google") {
        url = `https://accounts.google.com/o/oauth2/v2/auth?redirect_uri=${ThirdpartyConfig.callbackUrl}&prompt=consent&response_type=code&client_id=${ThirdpartyConfig.googleClientId}&scope=openid&access_type=offline`;
    }
    else if (provider === "facebook") {
        url = `https://www.facebook.com/v12.0/dialog/oauth?client_id=${ThirdpartyConfig.facebookClientId}&redirect_uri=${ThirdpartyConfig.callbackUrl}&scope=&response_type=code`;
    }
    else if (provider === "microsoft") {
        url = `https://login.microsoftonline.com/common/oauth2/v2.0/authorize?client_id=${ThirdpartyConfig.microsoftClientId}&scope=openid profile User.Read offline_access&response_type=code&redirect_uri=${ThirdpartyConfig.callbackUrl}`;
    }
    if (mode === "manual") {
        return url;
    }
    let state = JSON.stringify({
        deeplink: mode === "desktop"
            ? "koodo-reader://callback"
            : mode === "browser"
                ? "http://localhost:3000/#/login"
                : "",
        service: provider,
    });
    let stateParam = "state|" + encodeURIComponent(state);
    return `${url}&state=${stateParam}`;
};
var loginHelper = { getAuthUrl };

class SyncHelper {
    static CompareDatabase(localSyncRecords, cloudSyncRecords) {
        return __awaiter(this, void 0, void 0, function* () {
            let localBooks = Object.keys(localSyncRecords).filter((item) => item.startsWith("database.sqlite.books"));
            let localNotes = Object.keys(localSyncRecords).filter((item) => item.startsWith("database.sqlite.notes"));
            let localBookmarks = Object.keys(localSyncRecords).filter((item) => item.startsWith("database.sqlite.bookmarks"));
            let localPlugins = Object.keys(localSyncRecords).filter((item) => item.startsWith("database.sqlite.plugins"));
            let localWords = Object.keys(localSyncRecords).filter((item) => item.startsWith("database.sqlite.words"));
            let cloudBooks = Object.keys(cloudSyncRecords).filter((item) => item.startsWith("database.sqlite.books"));
            let cloudNotes = Object.keys(cloudSyncRecords).filter((item) => item.startsWith("database.sqlite.notes"));
            let cloudBookmarks = Object.keys(cloudSyncRecords).filter((item) => item.startsWith("database.sqlite.bookmarks"));
            let cloudPlugins = Object.keys(cloudSyncRecords).filter((item) => item.startsWith("database.sqlite.plugins"));
            let cloudWords = Object.keys(cloudSyncRecords).filter((item) => item.startsWith("database.sqlite.words"));
            let sumBookRecords = Array.from(new Set(localBooks.concat(cloudBooks)));
            let sumNoteRecords = Array.from(new Set(localNotes.concat(cloudNotes)));
            let sumBookmarkRecords = Array.from(new Set(localBookmarks.concat(cloudBookmarks)));
            let sumPluginRecords = Array.from(new Set(localPlugins.concat(cloudPlugins)));
            let sumWordRecords = Array.from(new Set(localWords.concat(cloudWords)));
            let sumRecords = {
                books: sumBookRecords,
                notes: sumNoteRecords,
                bookmarks: sumBookmarkRecords,
                plugins: sumPluginRecords,
                words: sumWordRecords,
            };
            let databaseResult = {
                books: {
                    save: [],
                    update: [],
                    delete: [],
                    conflict: [],
                    upload: [],
                },
                notes: {
                    save: [],
                    update: [],
                    delete: [],
                    conflict: [],
                    upload: [],
                },
                bookmarks: {
                    save: [],
                    update: [],
                    delete: [],
                    conflict: [],
                    upload: [],
                },
                plugins: {
                    save: [],
                    update: [],
                    delete: [],
                    conflict: [],
                    upload: [],
                },
                words: {
                    save: [],
                    update: [],
                    delete: [],
                    conflict: [],
                    upload: [],
                },
            };
            let database = ["books", "notes", "bookmarks", "plugins", "words"];
            for (let item of database) {
                for (let record of sumRecords[item]) {
                    //忽略表示直接用本地覆盖云端
                    let recordKey = record.split(".")[3];
                    let localRecord = localSyncRecords[record];
                    let cloudRecord = cloudSyncRecords[record];
                    if (!localRecord) {
                        databaseResult[item].save.push(recordKey);
                        localSyncRecords[record] = cloudRecord;
                    }
                    else if (!cloudRecord) {
                        databaseResult[item].upload.push(recordKey);
                    }
                    else {
                        if (cloudRecord.operation === "save") {
                            if (localRecord.operation === "update" ||
                                localRecord.operation === "delete") {
                                databaseResult[item].upload.push(recordKey);
                            }
                            else {
                                console.log("ignore", cloudRecord);
                            }
                        }
                        if (cloudRecord.operation === "delete") {
                            if (localRecord.operation === "save") {
                                databaseResult[item].delete.push(recordKey);
                                localSyncRecords[record] = cloudRecord;
                            }
                            if (localRecord.operation === "update") {
                                if (localRecord.time < cloudRecord.time) {
                                    databaseResult[item].delete.push(recordKey);
                                    localSyncRecords[record] = cloudRecord;
                                }
                                else if (localRecord.time > cloudRecord.time) {
                                    databaseResult[item].conflict.push(recordKey);
                                }
                                else {
                                    console.log("ignore", cloudRecord);
                                }
                            }
                            if (localRecord.operation === "delete") {
                                console.log("ignore", cloudRecord);
                            }
                        }
                        if (cloudRecord.operation === "update") {
                            if (localRecord.operation === "save") {
                                databaseResult[item].update.push(recordKey);
                                localSyncRecords[record] = cloudRecord;
                            }
                            if (localRecord.operation === "update") {
                                if (localRecord.time < cloudRecord.time) {
                                    databaseResult[item].update.push(recordKey);
                                    localSyncRecords[record] = cloudRecord;
                                }
                                else if (localRecord.time > cloudRecord.time) {
                                    databaseResult[item].upload.push(recordKey);
                                }
                                else {
                                    console.log("ignore", cloudRecord);
                                }
                            }
                            if (localRecord.operation === "delete") {
                                if (localRecord.time < cloudRecord.time) {
                                    databaseResult[item].conflict.push(recordKey);
                                }
                                else if (localRecord.time > cloudRecord.time) {
                                    databaseResult[item].upload.push(recordKey);
                                }
                                else {
                                    console.log("ignore", cloudRecord);
                                }
                            }
                        }
                    }
                }
            }
            return {
                compareResult: databaseResult,
                syncRecords: localSyncRecords,
            };
        });
    }
    static CompareConfig(localSyncRecords, cloudSyncRecords) {
        return __awaiter(this, void 0, void 0, function* () {
            let localReaderConfigRecords = Object.keys(localSyncRecords).filter((item) => item.startsWith("config.readerConfig"));
            let localListConfigRecords = Object.keys(localSyncRecords).filter((item) => item.startsWith("config.listConfig"));
            let localObjectConfigRecords = Object.keys(localSyncRecords).filter((item) => item.startsWith("config.objectConfig"));
            let localMapConfigRecords = Object.keys(localSyncRecords).filter((item) => item.startsWith("config.mapConfig"));
            let cloudReaderConfigRecords = Object.keys(cloudSyncRecords).filter((item) => item.startsWith("config.readerConfig"));
            let cloudListConfigRecords = Object.keys(cloudSyncRecords).filter((item) => item.startsWith("config.listConfig"));
            let cloudObjectConfigRecords = Object.keys(cloudSyncRecords).filter((item) => item.startsWith("config.objectConfig"));
            let cloudMapConfigRecords = Object.keys(cloudSyncRecords).filter((item) => item.startsWith("config.mapConfig"));
            let sumReaderConfigRecords = Array.from(new Set(localReaderConfigRecords.concat(cloudReaderConfigRecords)));
            let sumListConfigRecords = Array.from(new Set(localListConfigRecords.concat(cloudListConfigRecords)));
            let sumObjectConfigRecords = Array.from(new Set(localObjectConfigRecords.concat(cloudObjectConfigRecords)));
            let sumMapConfigRecords = Array.from(new Set(localMapConfigRecords.concat(cloudMapConfigRecords)));
            let sumSimpleRecords = {
                readerConfig: sumReaderConfigRecords,
                listConfig: sumListConfigRecords,
                objectConfig: sumObjectConfigRecords,
                mapConfig: sumMapConfigRecords,
            };
            let configResult = {
                readerConfig: {
                    update: [],
                    upload: [],
                },
                listConfig: {
                    update: [],
                    upload: [],
                },
                objectConfig: {
                    update: [],
                    delete: [],
                    conflict: [],
                    upload: [],
                },
                mapConfig: {
                    update: [],
                    delete: [],
                    conflict: [],
                    upload: [],
                },
            };
            let simpleConfigs = ["readerConfig", "listConfig"];
            for (let item of simpleConfigs) {
                for (let record of sumSimpleRecords[item]) {
                    let recordKey = record;
                    let localRecord = localSyncRecords[record];
                    let cloudRecord = cloudSyncRecords[record];
                    if (!localRecord) {
                        configResult[item].update.push(recordKey);
                        localSyncRecords[record] = cloudRecord;
                    }
                    else if (!cloudRecord) {
                        configResult[item].upload.push(recordKey);
                    }
                    else {
                        if (localRecord.time < cloudRecord.time) {
                            configResult[item].update.push(recordKey);
                            localSyncRecords[record] = cloudRecord;
                        }
                        else if (localRecord.time > cloudRecord.time) {
                            configResult[item].upload.push(recordKey);
                        }
                        else {
                            console.log("ignore", cloudRecord);
                        }
                    }
                }
            }
            let complexConfigs = ["objectConfig", "mapConfig"];
            for (let item of complexConfigs) {
                for (let record of sumSimpleRecords[item]) {
                    let recordKey = record;
                    let localRecord = localSyncRecords[record];
                    let cloudRecord = cloudSyncRecords[record];
                    if (!localRecord) {
                        configResult[item].update.push(recordKey);
                        localSyncRecords[record] = cloudRecord;
                    }
                    else if (!cloudRecord) {
                        configResult[item].upload.push(recordKey);
                    }
                    else {
                        if (cloudRecord.operation === "delete") {
                            if (localRecord.operation === "update") {
                                if (localRecord.time < cloudRecord.time) {
                                    configResult[item].delete.push(recordKey);
                                    localSyncRecords[record] = cloudRecord;
                                }
                                else if (localRecord.time > cloudRecord.time) {
                                    configResult[item].conflict.push(recordKey);
                                }
                                else {
                                    console.log("ignore", cloudRecord);
                                }
                            }
                            if (localRecord.operation === "delete") {
                                console.log("ignore", cloudRecord);
                            }
                        }
                        if (cloudRecord.operation === "update") {
                            if (localRecord.operation === "update") {
                                if (localRecord.time < cloudRecord.time) {
                                    configResult[item].update.push(recordKey);
                                    localSyncRecords[record] = cloudRecord;
                                }
                                else if (localRecord.time > cloudRecord.time) {
                                    configResult[item].upload.push(recordKey);
                                }
                                else {
                                    console.log("ignore", cloudRecord);
                                }
                            }
                            if (localRecord.operation === "delete") {
                                if (localRecord.time < cloudRecord.time) {
                                    configResult[item].conflict.push(recordKey);
                                }
                                else if (localRecord.time > cloudRecord.time) {
                                    configResult[item].upload.push(recordKey);
                                }
                                else {
                                    console.log("ignore", cloudRecord);
                                }
                            }
                        }
                    }
                }
            }
            return {
                compareResult: configResult,
                syncRecords: localSyncRecords,
            };
        });
    }
    static compareAll(localSyncRecords, cloudSyncRecords) {
        return __awaiter(this, void 0, void 0, function* () {
            let { compareResult: databaseResult, syncRecords } = yield this.CompareDatabase(localSyncRecords, cloudSyncRecords);
            let { compareResult: configResult, syncRecords: updatedSyncRecords } = yield this.CompareConfig(syncRecords, cloudSyncRecords);
            return {
                compareResult: Object.assign(Object.assign({}, databaseResult), configResult),
                syncRecords: updatedSyncRecords,
            };
        });
    }
    static startSync(compareResult, ConfigService, DatabaseService, SyncService, ConfigUtil, BookUtil, CoverUtil) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.syncConfig(compareResult, ConfigService, DatabaseService, BookUtil, ConfigUtil);
            yield this.syncCover(SyncService, CoverUtil);
            yield this.syncBook(ConfigService, SyncService, BookUtil);
        });
    }
    static syncConfig(compareResult, ConfigService, DatabaseService, BookUtil, ConfigUtil) {
        return __awaiter(this, void 0, void 0, function* () {
            for (let database of databaseList) {
                if (compareResult[database].save.length +
                    compareResult[database].update.length >
                    0) {
                    let cloudRecords = yield ConfigUtil.getCloudDatabase(database);
                    for (let recordKey of compareResult[database].save) {
                        console.log(cloudRecords[0]);
                        console.log(cloudRecords[0].key);
                        let record = cloudRecords.find((item) => {
                            console.log(item);
                            console.log(item.key, recordKey);
                            return item.key === recordKey;
                        });
                        console.log(record, "record create");
                        if (record) {
                            yield DatabaseService.saveRecord(record, database);
                        }
                    }
                    console.log("4345", database);
                    for (let recordKey of compareResult[database].update) {
                        let record = cloudRecords.find((item) => item.key === recordKey);
                        console.log(record, "record update");
                        if (record) {
                            yield DatabaseService.updateRecord(record, database, false);
                        }
                    }
                }
                console.log("asdfsd");
                if (compareResult[database].delete.length > 0) {
                    for (let recordKey of compareResult[database].delete) {
                        yield DatabaseService.deleteRecord(recordKey, database);
                        if (database === "books") {
                            yield BookUtil.deleteOfflineBook(recordKey);
                        }
                    }
                }
            }
            console.log("234234");
            if (compareResult["readerConfig"].update.length > 0 ||
                compareResult["listConfig"].update.length > 0 ||
                compareResult["objectConfig"].update.length > 0 ||
                compareResult["mapConfig"].update.length > 0) {
                let cloudConfig = yield ConfigUtil.getCloudConfig("config");
                console.log(cloudConfig, "cloudConfig");
                for (let record of compareResult["readerConfig"].update) {
                    console.log(record);
                    let key = record.split(".")[3];
                    console.log(cloudConfig["readerConfig"], key);
                    if (cloudConfig["readerConfig"]) {
                        ConfigService.setReaderConfig(key, JSON.parse(cloudConfig["readerConfig"])[key], false);
                    }
                }
                for (let record of compareResult["listConfig"].update) {
                    console.log(record);
                    let key = record.split(".")[3];
                    console.log(cloudConfig[key], key);
                    if (cloudConfig[key]) {
                        ConfigService.setAllListConfig(JSON.parse(cloudConfig[key]), key, false);
                    }
                }
                for (let record of compareResult["objectConfig"].update) {
                    console.log(record);
                    let key = record.split(".")[3];
                    let name = record.split(".")[2];
                    console.log(cloudConfig[name], key, name);
                    if (cloudConfig[name] &&
                        JSON.parse(cloudConfig[name]) &&
                        JSON.parse(cloudConfig[name])[key]) {
                        ConfigService.setObjectConfig(key, JSON.parse(cloudConfig[name])[key], name, false);
                    }
                }
                for (let record of compareResult["mapConfig"].update) {
                    console.log(record);
                    let key = record.split(".")[3];
                    let name = record.split(".")[2];
                    console.log(cloudConfig[name], key, name);
                    if (cloudConfig[name] &&
                        JSON.parse(cloudConfig[name]) &&
                        JSON.parse(cloudConfig[name])[key]) {
                        let mapConfig = JSON.parse(cloudConfig[name])[key];
                        ConfigService.setOneMapConfig(key, mapConfig, name, false);
                    }
                }
            }
            if (compareResult["objectConfig"].delete.length > 0 ||
                compareResult["mapConfig"].delete.length > 0) {
                for (let record of compareResult["objectConfig"].delete) {
                    console.log(record);
                    let key = record.split(".")[3];
                    let name = record.split(".")[2];
                    ConfigService.deleteObjectConfig(key, name);
                }
                for (let record of compareResult["mapConfig"].delete) {
                    console.log(record);
                    let key = record.split(".")[3];
                    let name = record.split(".")[2];
                    ConfigService.deleteMapConfig(key, name);
                }
            }
            for (let database of databaseList) {
                if (compareResult[database].upload.length > 0) {
                    console.log("uploading " + database);
                    yield ConfigUtil.uploadDatabase(database);
                }
            }
            if (compareResult["readerConfig"].upload.length > 0 ||
                compareResult["listConfig"].upload.length > 0 ||
                compareResult["objectConfig"].upload.length > 0 ||
                compareResult["mapConfig"].upload.length > 0) {
                console.log("uploading config");
                yield ConfigUtil.uploadConfig("config");
            }
            console.log("uploading sync");
            yield ConfigUtil.uploadConfig("sync");
        });
    }
    static syncCover(SyncService, CoverUtil) {
        return __awaiter(this, void 0, void 0, function* () {
            let localCoverList = yield CoverUtil.getLocalCoverList();
            console.log(localCoverList, "localCoverList");
            let syncUtil = yield SyncService.getSyncUtil();
            let cloudCoverList = yield syncUtil.listFiles("cover");
            console.log(localCoverList, cloudCoverList, "coverList");
            //去重
            let sumCoverList = Array.from(new Set([...localCoverList, ...cloudCoverList]));
            for (let cover of sumCoverList) {
                if (localCoverList.includes(cover) && !cloudCoverList.includes(cover)) {
                    yield CoverUtil.uploadCover(cover);
                }
                if (!localCoverList.includes(cover) && cloudCoverList.includes(cover)) {
                    yield CoverUtil.downloadCover(cover);
                }
            }
        });
    }
    static syncBook(ConfigService, SyncService, BookUtil) {
        return __awaiter(this, void 0, void 0, function* () {
            let localBookList = yield BookUtil.getLocalBookList();
            let syncUtil = yield SyncService.getSyncUtil();
            let cloudBookList = yield syncUtil.listFiles("book");
            console.log(localBookList, cloudBookList, "bookList");
            //去重
            let sumBookList = Array.from(new Set([...localBookList, ...cloudBookList]));
            for (let book of sumBookList) {
                if (localBookList.includes(book) && !cloudBookList.includes(book)) {
                    let key = book.split(".")[0];
                    let format = book.split(".")[1];
                    yield BookUtil.uploadBook(key, format);
                }
                let isAutoOffline = ConfigService.getReaderConfig("autoOffline") === "yes";
                if (!localBookList.includes(book) &&
                    cloudBookList.includes(book) &&
                    isAutoOffline) {
                    let key = book.split(".")[0];
                    let format = book.split(".")[1];
                    yield BookUtil.downloadBook(key, format);
                }
            }
        });
    }
}

const createDynamicService = (baseService) => {
    return class extends baseService {
        static getReaderConfig(key) {
            let readerConfig = JSON.parse(this.getItem("readerConfig") || "{}");
            return readerConfig[key];
        }
        static setReaderConfig(key, value, isRecord = true) {
            let readerConfig = JSON.parse(this.getItem("readerConfig") || "{}");
            readerConfig[key] = value;
            this.setItem("readerConfig", JSON.stringify(readerConfig));
            if (isRecord) {
                console.log(key, "sadfs2342df");
                this.setSyncRecord({
                    type: "config",
                    catergory: "readerConfig",
                    name: "",
                    key: key,
                }, {
                    operation: "update",
                    time: Date.now(),
                });
            }
            console.log(readerConfig, "87878");
        }
        static getAllListConfig(key) {
            let itemArr = this.getItem(key) !== "{}" && this.getItem(key)
                ? JSON.parse(this.getItem(key) || "")
                : [];
            return itemArr || [];
        }
        static deleteListConfig(itemName, key) {
            let itemArr = this.getAllListConfig(key);
            const index = itemArr.indexOf(itemName);
            if (index > -1) {
                itemArr.splice(index, 1);
            }
            this.setAllListConfig(itemArr, key);
        }
        static setListConfig(itemName, key) {
            let itemArr = this.getAllListConfig(key);
            const index = itemArr.indexOf(itemName);
            if (index > -1) {
                itemArr.splice(index, 1);
                itemArr.unshift(itemName);
            }
            else {
                itemArr.unshift(itemName);
            }
            this.setAllListConfig(itemArr, key);
        }
        static setAllListConfig(itemArr, key, isRecord = true) {
            this.setItem(key, JSON.stringify(itemArr));
            if (isRecord) {
                this.setSyncRecord({
                    type: "config",
                    catergory: "listConfig",
                    name: "general",
                    key: key,
                }, {
                    operation: "update",
                    time: Date.now(),
                });
            }
        }
        static setObjectConfig(itemName, item, key, isRecord = true) {
            let obj = this.getAllObjectConfig(key);
            obj[itemName] = item;
            if (isRecord) {
                this.setSyncRecord({
                    type: "config",
                    catergory: "objectConfig",
                    name: key,
                    key: itemName,
                }, {
                    operation: "update",
                    time: Date.now(),
                });
            }
            this.setAllObjectConfig(obj, key);
        }
        static getObjectConfig(itemName, key, defaultValue) {
            let obj = this.getAllObjectConfig(key);
            return obj[itemName] || defaultValue;
        }
        static getAllObjectConfig(key) {
            let json = this.getItem(key);
            let obj = JSON.parse(json) || {};
            return obj;
        }
        static setAllObjectConfig(obj, key) {
            this.setItem(key, JSON.stringify(obj));
        }
        static deleteObjectConfig(itemName, key) {
            let obj = this.getAllObjectConfig(key);
            delete obj[itemName];
            this.setSyncRecord({
                type: "config",
                catergory: "objectConfig",
                name: key,
                key: itemName,
            }, {
                operation: "delete",
                time: Date.now(),
            });
            this.setAllObjectConfig(obj, key);
        }
        static getAllMapConfig(key) {
            let json = this.getItem(key);
            let obj = JSON.parse(json) || {};
            return obj;
        }
        static getMapConfig(objectName, key) {
            let obj = this.getAllMapConfig(key);
            return obj[objectName] || [];
        }
        static setAllMapConfig(obj, key) {
            this.setItem(key, JSON.stringify(obj));
        }
        static setMapConfig(objectName, itemName, key) {
            let obj = this.getAllMapConfig(key);
            if (obj[objectName] === undefined) {
                obj[objectName] = [];
            }
            if (itemName && obj[objectName].indexOf(itemName) === -1) {
                obj[objectName].unshift(itemName);
            }
            this.setSyncRecord({
                type: "config",
                catergory: "mapConfig",
                name: key,
                key: objectName,
            }, {
                operation: "update",
                time: Date.now(),
            });
            this.setAllMapConfig(obj, key);
        }
        static setOneMapConfig(objectName, itemArr, key, isRecord = true) {
            console.log(objectName, itemArr, key, "sad68568fsdf");
            let obj = this.getAllMapConfig(key);
            obj[objectName] = itemArr;
            console.log(obj, key, "sadfsds254f");
            if (isRecord) {
                this.setSyncRecord({
                    type: "config",
                    catergory: "mapConfig",
                    name: key,
                    key: objectName,
                }, {
                    operation: "update",
                    time: Date.now(),
                });
            }
            console.log(obj, key, "sadfsdf");
            this.setAllMapConfig(obj, key);
        }
        static deleteFromMapConfig(objectName, itemName, key) {
            let obj = this.getAllMapConfig(key);
            let index = obj[objectName].indexOf(itemName);
            obj[objectName].splice(index, 1);
            this.setSyncRecord({
                type: "config",
                catergory: "mapConfig",
                name: key,
                key: objectName,
            }, {
                operation: "update",
                time: Date.now(),
            });
            this.setAllMapConfig(obj, key);
        }
        static deleteFromAllMapConfig(itemName, key) {
            let obj = this.getAllMapConfig(key);
            let objectNameList = Object.keys(obj);
            objectNameList.forEach((item) => {
                let index = obj[item].indexOf(itemName);
                if (index > -1) {
                    obj[item].splice(index, 1);
                    this.setSyncRecord({
                        type: "config",
                        catergory: "mapConfig",
                        name: key,
                        key: item,
                    }, {
                        operation: "update",
                        time: Date.now(),
                    });
                }
            });
            this.setAllMapConfig(obj, key);
        }
        static deleteMapConfig(objectName, key) {
            let obj = this.getAllMapConfig(key);
            delete obj[objectName];
            this.setSyncRecord({
                type: "config",
                catergory: "mapConfig",
                name: key,
                key: objectName,
            }, {
                operation: "delete",
                time: Date.now(),
            });
            this.setAllMapConfig(obj, key);
        }
        static getFromAllMapConfig(itemName, key) {
            let obj = this.getAllMapConfig(key);
            let objectNameList = [];
            for (let item in obj) {
                if (obj[item] && obj[item].indexOf(itemName) > -1) {
                    objectNameList.push(item);
                }
            }
            return objectNameList;
        }
        static getSyncRecord(syncId) {
            let syncRecord = JSON.parse(this.getItem("syncRecord") || "{}");
            return (syncRecord[syncId.type +
                "." +
                syncId.catergory +
                "." +
                syncId.name +
                "." +
                syncId.key] || { operation: "", time: 0 });
        }
        static getAllSyncRecord() {
            let syncRecord = JSON.parse(this.getItem("syncRecord") || "{}");
            return syncRecord;
        }
        static setSyncRecord(syncId, record) {
            let syncRecord = JSON.parse(this.getItem("syncRecord") || "{}");
            syncRecord[syncId.type +
                "." +
                syncId.catergory +
                "." +
                syncId.name +
                "." +
                syncId.key] = record;
            this.setItem("syncRecord", JSON.stringify(syncRecord));
        }
        static setAllSyncRecord(syncRecord) {
            this.setItem("syncRecord", JSON.stringify(syncRecord));
        }
    };
};

class DesktopService {
    static getItem(key) {
        return localStorage.getItem(key);
    }
    static setItem(key, value) {
        localStorage.setItem(key, value);
    }
    static removeItem(key) {
        localStorage.removeItem(key);
    }
}
const ConfigService = createDynamicService(DesktopService);

export { BookHelper, common as CommonTool, ConfigService, config as KookitConfig, loginHelper as LoginHelper, ReaderRequest, sqlStatement$1 as SqlStatement, SyncHelper, SyncUtil, ThirdpartyRequest, UserRequest };
